{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/hexo-theme-next-6.2.0/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next-6.2.0/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next-6.2.0/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next-6.2.0/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next-6.2.0/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next-6.2.0/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next-6.2.0/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next-6.2.0/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next-6.2.0/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next-6.2.0/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next-6.2.0/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next-6.2.0/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next-6.2.0/source/images/icons8-whale-16.png","path":"images/icons8-whale-16.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next-6.2.0/source/images/icons8-whale-32.png","path":"images/icons8-whale-32.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next-6.2.0/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next-6.2.0/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next-6.2.0/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next-6.2.0/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next-6.2.0/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next-6.2.0/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next-6.2.0/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next-6.2.0/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next-6.2.0/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next-6.2.0/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next-6.2.0/source/js/src/exturl.js","path":"js/src/exturl.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next-6.2.0/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next-6.2.0/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next-6.2.0/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next-6.2.0/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next-6.2.0/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next-6.2.0/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next-6.2.0/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next-6.2.0/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next-6.2.0/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next-6.2.0/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next-6.2.0/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next-6.2.0/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1}],"Cache":[{"_id":"themes/hexo-theme-next-6.2.0/.bowerrc","hash":"334da94ca6f024d60d012cc26ea655681e724ad8","modified":1540191401714},{"_id":"themes/hexo-theme-next-6.2.0/.editorconfig","hash":"211d2c92bfdddb3e81ea946f4ca7a539f150f4da","modified":1540191401718},{"_id":"themes/hexo-theme-next-6.2.0/.gitattributes","hash":"8454b9313cb1a97b63fb87e2d29daee497ce6249","modified":1540191401723},{"_id":"themes/hexo-theme-next-6.2.0/.gitignore","hash":"0378adb9c2dc4855b3198184df4863cb30e4059c","modified":1540191401763},{"_id":"themes/hexo-theme-next-6.2.0/.hound.yml","hash":"289dcf5bfe92dbd680d54d6e0668f41c9c9c0c78","modified":1540191401767},{"_id":"themes/hexo-theme-next-6.2.0/.javascript_ignore","hash":"cd250ad74ca22bd2c054476456a73d9687f05f87","modified":1540191401772},{"_id":"themes/hexo-theme-next-6.2.0/.stylintrc","hash":"3b7f9785e9ad0dab764e1c535b40df02f4ff5fd6","modified":1540191401781},{"_id":"themes/hexo-theme-next-6.2.0/.jshintrc","hash":"b7d23f2ce8d99fa073f22f9960605f318acd7710","modified":1540191401777},{"_id":"themes/hexo-theme-next-6.2.0/LICENSE.md","hash":"f0190c7d83a98464549a6b3a51bb206148d88e1b","modified":1540191401793},{"_id":"themes/hexo-theme-next-6.2.0/.travis.yml","hash":"6674fbdfe0d0c03b8a04527ffb8ab66a94253acd","modified":1540191401786},{"_id":"themes/hexo-theme-next-6.2.0/README.md","hash":"4803a2fc3101612ecad7f59182427350700ddbc6","modified":1540191401800},{"_id":"themes/hexo-theme-next-6.2.0/_config.yml","hash":"14f0312602475bb6b7aee048fdeaabbc163a7f27","modified":1540191401806},{"_id":"themes/hexo-theme-next-6.2.0/bower.json","hash":"7ba085560656f4ce1f5bb60b722d77e9dfeb5e55","modified":1540191401812},{"_id":"themes/hexo-theme-next-6.2.0/crowdin.yml","hash":"4a53f5985e545c635cb56b2a57ed290cb8cf8942","modified":1540191401817},{"_id":"themes/hexo-theme-next-6.2.0/gulpfile.coffee","hash":"67eaf2515100971f6195b60eeebbfe5e8de895ab","modified":1540191401962},{"_id":"themes/hexo-theme-next-6.2.0/package.json","hash":"42d8b37c8b313fdfce98059bd4a629b928e47ba2","modified":1540191402723},{"_id":"source/_posts/machine-learning-for-trading.md","hash":"f3173580bd18930f8ba2e6902bfa86eecc368dc3","modified":1540191401545},{"_id":"source/_posts/minjiekaifa.md","hash":"01739271d1925417b54e0c861a14a66c536cbd9e","modified":1540191401619},{"_id":"source/_posts/python_for_finance.md","hash":"cea10d0aaed9254ecbe07eeb4bdcb95a6e94c7e0","modified":1540191401632},{"_id":"source/_posts/pythoncore.md","hash":"566adbb99ebfadc7bed69447b3ee7d625403dda8","modified":1540191401649},{"_id":"source/_posts/rljs.md","hash":"11f3e1a78953c1a287173c3f5cf60f734bffd7f4","modified":1540191401657},{"_id":"source/_posts/website.md","hash":"2556a40d4f477683747427e269e084dceccbdbf3","modified":1540191401673},{"_id":"source/_posts/wuhezhizhong.md","hash":"4ebc57e86e5d3398292159c02d98381feec12cb2","modified":1540191401680},{"_id":"source/_posts/机器学习开放课程：三、分类、决策树和K近邻.md","hash":"4e9ccb4e2c24d203c4d375e1a6d1ee3e4e2e005d","modified":1541116652229},{"_id":"source/_posts/机器学习开放课程：五、Bagging与随机森林.md","hash":"dcc00f43cddf4e022bfdcf3d292987c7f0e13d3f","modified":1541667988609},{"_id":"source/_posts/机器学习开放课程：六、特征工程和特征选取.md","hash":"6c61920a090e0dfac2cb8bc3e35e901ec43733e2","modified":1542077151680},{"_id":"source/_posts/机器学习开放课程：四、线性分类与线性回归.md","hash":"4727d156f8dfac5b394d73e6db4510cdbd751dfa","modified":1541041445818},{"_id":"source/_posts/机器学习手记.md","hash":"8120c2f39b25cc8db44c06a376a3f103936ebc86","modified":1542073477793},{"_id":"source/_posts/概率论基础教程.md","hash":"5f7c4b10e000e5bc8a981be314faf8d150a7d853","modified":1540191401694},{"_id":"source/categories/index.md","hash":"4b3881645bf9c41b413f54be201fa22df67c91d7","modified":1540191401704},{"_id":"source/tags/index.md","hash":"19115235a4e8c976c655d37888edc99e75e75cb9","modified":1540191401709},{"_id":"themes/hexo-theme-next-6.2.0/.github/CODE_OF_CONDUCT.md","hash":"22f2ccc5522563b67c8663849fc1d6cbae93a8ff","modified":1540191401730},{"_id":"themes/hexo-theme-next-6.2.0/.github/PULL_REQUEST_TEMPLATE.md","hash":"36201119490a04107c8179b10202548a9d0e5e60","modified":1540191401751},{"_id":"themes/hexo-theme-next-6.2.0/.github/CONTRIBUTING.md","hash":"869dcd36524e2c61ddd2315c1266edca7f0da6c9","modified":1540191401740},{"_id":"themes/hexo-theme-next-6.2.0/.github/ISSUE_TEMPLATE.md","hash":"1e212fe229bd659726b4a3bcf4b5b14e0310ba3a","modified":1540191401746},{"_id":"themes/hexo-theme-next-6.2.0/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1540191401753},{"_id":"themes/hexo-theme-next-6.2.0/.github/stale.yml","hash":"dbd5e6bf89b76ad1f2b081578b239c7ae32755af","modified":1540191401758},{"_id":"themes/hexo-theme-next-6.2.0/docs/ALGOLIA-SEARCH.md","hash":"1dada3c3404445a00367882b8f97cdf092b7943d","modified":1540191401830},{"_id":"themes/hexo-theme-next-6.2.0/docs/AGPL3.md","hash":"f463f95b169d64983f59fa6f3e4b6760290a0e6b","modified":1540191401824},{"_id":"themes/hexo-theme-next-6.2.0/docs/AUTHORS.md","hash":"51a0a13da55ff3d596970b2f9ab4531c6b2211f2","modified":1540191401835},{"_id":"themes/hexo-theme-next-6.2.0/docs/DATA-FILES.md","hash":"9a1895c0a0db705c4c48f512e86917f9af1ec3fb","modified":1540191401841},{"_id":"themes/hexo-theme-next-6.2.0/docs/INSTALLATION.md","hash":"b74ef6fedf76cdb156e2265759ee0a789ddd49cc","modified":1540191401847},{"_id":"themes/hexo-theme-next-6.2.0/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"d0bc29c02b61e4433108987412685d991afd1a95","modified":1540191401856},{"_id":"themes/hexo-theme-next-6.2.0/docs/LICENSE","hash":"5b702310012d480b40529fd10cf1872f687277a0","modified":1540191401863},{"_id":"themes/hexo-theme-next-6.2.0/docs/MATH.md","hash":"bdbbcaf88f86de3d762fd1459fd5a0893cf4bce6","modified":1540191401873},{"_id":"themes/hexo-theme-next-6.2.0/docs/UPDATE-FROM-5.1.X.md","hash":"c9f2ed8e15c137b1885d9ca8b7197d9f457971e9","modified":1540191401879},{"_id":"themes/hexo-theme-next-6.2.0/languages/de.yml","hash":"ee9543b3a2487f713562c726ec0c7d08533864b5","modified":1540191401966},{"_id":"themes/hexo-theme-next-6.2.0/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1540191401971},{"_id":"themes/hexo-theme-next-6.2.0/languages/en.yml","hash":"cb5dd7b59c126aafaa6f6b5763d0b24cd65fb0f6","modified":1540191401976},{"_id":"themes/hexo-theme-next-6.2.0/languages/fr.yml","hash":"83db90d90c27a587dde82e1dcd34fffb9f73659e","modified":1540191401981},{"_id":"themes/hexo-theme-next-6.2.0/languages/id.yml","hash":"1d6a87905286701958cbbba60943c1f26671d271","modified":1540191401986},{"_id":"themes/hexo-theme-next-6.2.0/languages/ja.yml","hash":"29b71f703352a303377be1723490bb91cb9fb0c9","modified":1540191401996},{"_id":"themes/hexo-theme-next-6.2.0/languages/it.yml","hash":"7f5e58c97da9e5fb594d3bb872e912577f454151","modified":1540191401991},{"_id":"themes/hexo-theme-next-6.2.0/languages/ko.yml","hash":"7f481acf4debafac1ebe382eae73a0e2ce2c6ce9","modified":1540191402001},{"_id":"themes/hexo-theme-next-6.2.0/languages/nl.yml","hash":"1cbc1fdbb9dcbd6542df7623d01498eabf5cc9fb","modified":1540191402007},{"_id":"themes/hexo-theme-next-6.2.0/languages/pt.yml","hash":"c168a5fe202ececf2a32d60678b78cffcfa38dfd","modified":1540191402017},{"_id":"themes/hexo-theme-next-6.2.0/languages/pt-BR.yml","hash":"891dcc00e002c6dfceda95155459034501337023","modified":1540191402012},{"_id":"themes/hexo-theme-next-6.2.0/languages/ru.yml","hash":"30622bbf65529ae74737ccf6e1ccd9198b2684fe","modified":1540191402021},{"_id":"themes/hexo-theme-next-6.2.0/languages/vi.yml","hash":"1676223a98dbc9e9dab4463afc6092f1ac7d9a19","modified":1540191402030},{"_id":"themes/hexo-theme-next-6.2.0/languages/tr.yml","hash":"4e8748afbd7a1409d63f833f233d19d1330c57f9","modified":1540191402026},{"_id":"themes/hexo-theme-next-6.2.0/languages/zh-CN.yml","hash":"b2ae2d067f180f6c71f400c8222a1d468a05c895","modified":1540191402035},{"_id":"themes/hexo-theme-next-6.2.0/languages/zh-HK.yml","hash":"5737600de3fa42136a583c676605a0a337fc4bf6","modified":1540191402041},{"_id":"themes/hexo-theme-next-6.2.0/languages/zh-TW.yml","hash":"f1291813d6edafec28ed0ac4c932e949704811ef","modified":1540191402046},{"_id":"themes/hexo-theme-next-6.2.0/layout/_layout.swig","hash":"a1dc3c4f6a9023e5987bd11971703656834d4aa9","modified":1540191402057},{"_id":"themes/hexo-theme-next-6.2.0/layout/archive.swig","hash":"678a6cab739b54da9dfb2d6634848cffdc7aab6a","modified":1540191402687},{"_id":"themes/hexo-theme-next-6.2.0/layout/category.swig","hash":"3cbb3f72429647411f9e85f2544bdf0e3ad2e6b2","modified":1540191402691},{"_id":"themes/hexo-theme-next-6.2.0/layout/page.swig","hash":"fbf2c3d14c3e5730fad75d7d106bf7f070ccd69c","modified":1540191402701},{"_id":"themes/hexo-theme-next-6.2.0/layout/index.swig","hash":"555a357ecf17128db4e29346c92bb6298e66547a","modified":1540191402697},{"_id":"themes/hexo-theme-next-6.2.0/layout/post.swig","hash":"92d40ba2f58e88d8a722ea2c9be0e1340f7381b7","modified":1542077349296},{"_id":"themes/hexo-theme-next-6.2.0/layout/schedule.swig","hash":"87ad6055df01fa2e63e51887d34a2d8f0fbd2f5a","modified":1540191402712},{"_id":"themes/hexo-theme-next-6.2.0/layout/tag.swig","hash":"34e1c016cbdf94a31f9c5d494854ff46b2a182e9","modified":1540191402717},{"_id":"themes/hexo-theme-next-6.2.0/scripts/helpers.js","hash":"85811e77311b7b8255ef2c124a59fa4e6b6ac819","modified":1540191402730},{"_id":"themes/hexo-theme-next-6.2.0/scripts/merge-configs.js","hash":"176952dfe3605c2ab57f3f7cdbac4f2487825c41","modified":1540191402736},{"_id":"themes/hexo-theme-next-6.2.0/scripts/merge.js","hash":"39b84b937b2a9608b94e5872349a47200e1800ff","modified":1540191402750},{"_id":"themes/hexo-theme-next-6.2.0/test/.jshintrc","hash":"c9fca43ae0d99718e45a6f5ce736a18ba5fc8fb6","modified":1540191404266},{"_id":"themes/hexo-theme-next-6.2.0/test/helpers.js","hash":"f25e7f3265eb5a6e1ccbb5e5012fa9bebf134105","modified":1540191404278},{"_id":"themes/hexo-theme-next-6.2.0/test/intern.js","hash":"db90b1063356727d72be0d77054fdc32fa882a66","modified":1540191404290},{"_id":"themes/hexo-theme-next-6.2.0/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1540191403971},{"_id":"source/_posts/machine-learning-for-trading/1531304006175.png","hash":"65303fd3f43ec7f97c99982f3ea87781b6a0e606","modified":1540191401547},{"_id":"source/_posts/machine-learning-for-trading/1531383436936.png","hash":"96bac03df5f6e7cd62a63bd1fc13436e7e783ef6","modified":1540191401548},{"_id":"source/_posts/machine-learning-for-trading/1531465284221.png","hash":"96aa4011aaf6eca8ca7daae586d6ac60269b6306","modified":1540191401552},{"_id":"source/_posts/machine-learning-for-trading/1531384011994.png","hash":"3e75da2e6a10de454a42020b3fe6e8637984ede1","modified":1540191401550},{"_id":"source/_posts/machine-learning-for-trading/1531632440578.png","hash":"b3e99c490f32f21079d69997c2d0a4337ff1507b","modified":1540191401554},{"_id":"source/_posts/machine-learning-for-trading/1531634310060.png","hash":"4b25c05c012aaf32410b71b03a3caf8e967fa6e5","modified":1540191401556},{"_id":"source/_posts/machine-learning-for-trading/1531635134977.png","hash":"c361388c7de59fe3e79f2152a3c4f1f86ae41010","modified":1540191401557},{"_id":"source/_posts/machine-learning-for-trading/1532508276951.png","hash":"662381d0eb84b58ef484458f0d273200cdae2203","modified":1540191401560},{"_id":"source/_posts/machine-learning-for-trading/1532508260900.png","hash":"470ecf6ef9e41ca4e0994d6ccc214bdd24f88dd4","modified":1540191401559},{"_id":"source/_posts/machine-learning-for-trading/1532570705884.png","hash":"96c6d6447732d6ab59130ed921800f38112196b2","modified":1540191401562},{"_id":"source/_posts/machine-learning-for-trading/1532570720355.png","hash":"fd61c9e6a75456310e6b8084bb5bffec7c1fd22a","modified":1540191401564},{"_id":"source/_posts/machine-learning-for-trading/1532571574686.png","hash":"6b76e6e280bca3cf24b7815bab061b0c4672b02b","modified":1540191401566},{"_id":"source/_posts/machine-learning-for-trading/1532659982849.png","hash":"e5491d9c146a7959219945d6418d46173e8215aa","modified":1540191401567},{"_id":"source/_posts/machine-learning-for-trading/1532660052844.png","hash":"d826f9c9483e267aa37083749bf5a7867aeb09b4","modified":1540191401570},{"_id":"source/_posts/machine-learning-for-trading/1532677809156.png","hash":"069b552817c1f6bfd67c1e7c3cffb5722e86f4f3","modified":1540191401574},{"_id":"source/_posts/machine-learning-for-trading/1532677939302.png","hash":"f1f48d301022a803282d11612f4b6612d1b493d7","modified":1540191401576},{"_id":"source/_posts/machine-learning-for-trading/1532678552063.png","hash":"17a766ff1c7c0513d83f4c773c52402824f78a9b","modified":1540191401578},{"_id":"source/_posts/machine-learning-for-trading/image-20180811213410404.png","hash":"7805f1823db0017777522ee1b89840bdc5ae9521","modified":1540191401614},{"_id":"source/_posts/minjiekaifa/498627-20160828231647539-1014399922.png","hash":"5e4c0bd573f1931e9b37f709e003de5002c0f4c0","modified":1540191401621},{"_id":"source/_posts/minjiekaifa/498627-20160828231739089-846443922.png","hash":"8171fb5b1f923deaa6e488726d37f72b0fd2061a","modified":1540191401623},{"_id":"source/_posts/python_for_finance/1533087934260.png","hash":"1cebbc36198b005067482d047e79b437626e263b","modified":1540191401634},{"_id":"source/_posts/python_for_finance/1533087972105.png","hash":"3f3fa5bb6ade271b6e1ec460a4aebcd6f129c718","modified":1540191401636},{"_id":"source/_posts/python_for_finance/1533088423103.png","hash":"7207a7f22d543536c10c7b646f901e9054f219f8","modified":1540191401638},{"_id":"source/_posts/python_for_finance/1533088473653.png","hash":"224f47968d5d8e6c46dd01190043124d4ed102c8","modified":1540191401640},{"_id":"source/_posts/python_for_finance/1533088496598.png","hash":"73702fcf5f2c67ebbcbcc9e7657ab97b418bb954","modified":1540191401642},{"_id":"source/_posts/机器学习开放课程：三、分类、决策树和K近邻/tmp_w3pmy_5.png","hash":"b0a4705222347c3a3819d313b2c512dd635f7c75","modified":1540263425782},{"_id":"source/_posts/机器学习开放课程：六、特征工程和特征选取/1542006955920.png","hash":"8fa6e1870ce5b41b78ada38fb7d8c7554f8fbb7a","modified":1542006961842},{"_id":"source/_posts/机器学习开放课程：六、特征工程和特征选取/1542007030968.png","hash":"de96b47eb19aa830e8bcc55f31ab940e8af8cc5d","modified":1542007034209},{"_id":"source/_posts/机器学习开放课程：六、特征工程和特征选取/314px-Max_pooling.png","hash":"a541526bdc11d755b86cd2949110eae833725a51","modified":1541987855172},{"_id":"source/_posts/机器学习开放课程：四、线性分类与线性回归/TIM20181031095548.png","hash":"cdf14c9e18a4adaa8c4e0b2a9fa8c402fe1b524a","modified":1540950963826},{"_id":"source/_posts/机器学习开放课程：四、线性分类与线性回归/TIM20181031100050.png","hash":"1bb1c975325c1a6bbb22fadf869f840f738447d8","modified":1540951254183},{"_id":"source/_posts/概率论基础教程/image-20180722135552842.png","hash":"3b5d0ec5dc5b6e6e48d91abea8b6691dc1de8341","modified":1540191401696},{"_id":"themes/hexo-theme-next-6.2.0/docs/ru/DATA-FILES.md","hash":"a51de08657f5946f4028b11373280ddc04639525","modified":1540191401884},{"_id":"themes/hexo-theme-next-6.2.0/docs/ru/INSTALLATION.md","hash":"7b2963daac19b0c14f98ebef375d5fbce8fc3f44","modified":1540191401889},{"_id":"themes/hexo-theme-next-6.2.0/docs/ru/README.md","hash":"f80fc5b6678a104de086856a25dcfded73f07bc6","modified":1540191401897},{"_id":"themes/hexo-theme-next-6.2.0/docs/ru/UPDATE-FROM-5.1.X.md","hash":"1a4e41adcf5831057f3f7b3025ed4a5ef7c442b4","modified":1540191401901},{"_id":"themes/hexo-theme-next-6.2.0/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"e771c5b745608c6fb5ae2fa1c06c61b3699627ec","modified":1540191401907},{"_id":"themes/hexo-theme-next-6.2.0/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"9b512cb820627fcc45c9f77c7a122aa99e021bd5","modified":1540191401912},{"_id":"themes/hexo-theme-next-6.2.0/docs/zh-CN/CONTRIBUTING.md","hash":"f2a2d6e68c5f65e27303b40f5285a8a4a5adae4c","modified":1540191401919},{"_id":"themes/hexo-theme-next-6.2.0/docs/zh-CN/DATA-FILES.md","hash":"67f4a987e7db0ab1ce1ea4c311f2961df07b6681","modified":1540191401924},{"_id":"themes/hexo-theme-next-6.2.0/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"684dffabee3132055df10f66ff65c482a9b57a66","modified":1540191401938},{"_id":"themes/hexo-theme-next-6.2.0/docs/zh-CN/INSTALLATION.md","hash":"baca12cc24be082f1db28c7f283493569666321c","modified":1540191401930},{"_id":"themes/hexo-theme-next-6.2.0/docs/zh-CN/MATH.md","hash":"08c630dc7bd479e49d7d5aa813df628e7726bd7f","modified":1540191401945},{"_id":"themes/hexo-theme-next-6.2.0/docs/zh-CN/README.md","hash":"15a61c2eb19d3eceac479db415ca4a30587456c7","modified":1540191401951},{"_id":"themes/hexo-theme-next-6.2.0/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"1ec7a0e9ac64b2c84aa1fd7ba2c662be1dbcb407","modified":1540191401955},{"_id":"themes/hexo-theme-next-6.2.0/layout/_custom/head.swig","hash":"a223919d2e1bf17ca4d6abb2c86f2efca9883dc1","modified":1540191402051},{"_id":"themes/hexo-theme-next-6.2.0/layout/_custom/header.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1540191402051},{"_id":"themes/hexo-theme-next-6.2.0/layout/_custom/sidebar.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1540191402052},{"_id":"themes/hexo-theme-next-6.2.0/layout/_macro/post-collapse.swig","hash":"8c56dd26157cbc580ae41d97ac34b90ab48ced3f","modified":1540191402073},{"_id":"themes/hexo-theme-next-6.2.0/layout/_macro/post-copyright.swig","hash":"949bf640c011689e518ad480299ab19785df4b80","modified":1540191402078},{"_id":"themes/hexo-theme-next-6.2.0/layout/_macro/post.swig","hash":"866e92690c8188f711186fed65f720f12b9f2b11","modified":1540191402093},{"_id":"themes/hexo-theme-next-6.2.0/layout/_macro/reward.swig","hash":"8dc3b6ba76c389aaa0810cbd0df206f7096d76a0","modified":1540191402098},{"_id":"themes/hexo-theme-next-6.2.0/layout/_macro/sidebar.swig","hash":"2d8e3b4a211d55f4861eb2375b6fdd786484bf71","modified":1540191402105},{"_id":"themes/hexo-theme-next-6.2.0/layout/_partials/breadcrumb.swig","hash":"4b48fdbfe3bf41ddeda4ff74c1ff17ab9f15c14e","modified":1540191402115},{"_id":"themes/hexo-theme-next-6.2.0/layout/_partials/comments.swig","hash":"2e8c3df265e9ae38003d1321fb80fb3b12cb6a97","modified":1540191402120},{"_id":"themes/hexo-theme-next-6.2.0/layout/_partials/footer.swig","hash":"96feda6cf096297a17f07ee81254cc41768d2184","modified":1540191402126},{"_id":"themes/hexo-theme-next-6.2.0/layout/_macro/wechat-subscriber.swig","hash":"616ffee93e84958e72ee0f996808f866c4ccdbf7","modified":1540191402110},{"_id":"themes/hexo-theme-next-6.2.0/layout/_partials/page-header.swig","hash":"206cbd6ac9ca6a219a8516f59beae25b3c770199","modified":1540191402174},{"_id":"themes/hexo-theme-next-6.2.0/layout/_partials/pagination.swig","hash":"914155d5d758306cff405beefd4a07973fd8fc77","modified":1540191402180},{"_id":"themes/hexo-theme-next-6.2.0/layout/_scripts/boostrap.swig","hash":"c0f5a0955f69ca4ed9ee64a2d5f8aa75064935ad","modified":1540191402254},{"_id":"themes/hexo-theme-next-6.2.0/layout/_scripts/noscript.swig","hash":"f8c7e729ad6e72b4c705a2c5d5041589c2b4cc52","modified":1540191402262},{"_id":"themes/hexo-theme-next-6.2.0/layout/_scripts/commons.swig","hash":"931808ad9b8d8390c0dcf9bdeb0954eeb9185d68","modified":1540191402258},{"_id":"themes/hexo-theme-next-6.2.0/layout/_scripts/vendors.swig","hash":"f134aeb8d5bee351e5277edb92ac694af314b75f","modified":1540191402285},{"_id":"themes/hexo-theme-next-6.2.0/layout/_third-party/bookmark.swig","hash":"ed62ea83d3f2c9db2ea57bf23a7d765ed82504c2","modified":1540191402441},{"_id":"themes/hexo-theme-next-6.2.0/layout/_third-party/copy-code.swig","hash":"6a2c6c5766667943b320066d3b293afacb3b8c6e","modified":1540191402542},{"_id":"themes/hexo-theme-next-6.2.0/layout/_third-party/exturl.swig","hash":"8301c9600bb3e47f7fb98b0e0332ef3c51bb1688","modified":1540191402546},{"_id":"themes/hexo-theme-next-6.2.0/layout/_third-party/github-banner.swig","hash":"736cb278fa09d3b4ed6f305b56353941ea918793","modified":1540191402552},{"_id":"themes/hexo-theme-next-6.2.0/layout/_third-party/pangu.swig","hash":"ccf0035086e14dcefa24c2907301edf4c37d5448","modified":1540191402590},{"_id":"themes/hexo-theme-next-6.2.0/layout/_third-party/rating.swig","hash":"554ec568e9d2c71e4a624a8de3cb5929050811d6","modified":1540191402600},{"_id":"themes/hexo-theme-next-6.2.0/layout/_macro/post-related.swig","hash":"e8dfb86eb62b9c2bc1435d6d1afa95d3b4c7b931","modified":1540191402083},{"_id":"themes/hexo-theme-next-6.2.0/layout/_third-party/schedule.swig","hash":"db15d7e1552aa2d2386a6b8a33b3b3a40bf9e43d","modified":1540191402616},{"_id":"themes/hexo-theme-next-6.2.0/layout/_third-party/scroll-cookie.swig","hash":"9a188938d46931d5f3882a140aa1c48b3a893f0c","modified":1540191402621},{"_id":"themes/hexo-theme-next-6.2.0/layout/_third-party/needsharebutton.swig","hash":"debba9b7110f635204a15df148194d4c2fd2668b","modified":1540191402585},{"_id":"themes/hexo-theme-next-6.2.0/scripts/tags/center-quote.js","hash":"5c87817385986748617fa87dee9cba654566adcd","modified":1540191402764},{"_id":"themes/hexo-theme-next-6.2.0/scripts/tags/full-image.js","hash":"2118895d2d5e379240b27399a6c988a74f25a427","modified":1540191402784},{"_id":"themes/hexo-theme-next-6.2.0/scripts/tags/exturl.js","hash":"4f928ef9ad0ae8e3d766352b8861bc22f96de5d8","modified":1540191402776},{"_id":"themes/hexo-theme-next-6.2.0/scripts/tags/group-pictures.js","hash":"696157d4e4382fdbe29c674b0f4b433d47db449b","modified":1540191402799},{"_id":"themes/hexo-theme-next-6.2.0/scripts/tags/button.js","hash":"496e3846f353d253dad944b2ed8fdc4e02dcc28a","modified":1540191402758},{"_id":"themes/hexo-theme-next-6.2.0/scripts/tags/include-raw.js","hash":"1f7bafba9cf3c94f5735873bd52e93ddcf37f8a2","modified":1540191402808},{"_id":"themes/hexo-theme-next-6.2.0/scripts/tags/label.js","hash":"d8bfb2974c6afef2c085642857b70b6569b4a097","modified":1540191402814},{"_id":"themes/hexo-theme-next-6.2.0/scripts/tags/lazy-image.js","hash":"92c0ead5f503cfc4ee7c254ebfb00a2623fa1890","modified":1540191402823},{"_id":"themes/hexo-theme-next-6.2.0/scripts/tags/note.js","hash":"1cec218c9fcaa8fb4144bf9d0b39babcaafac8d4","modified":1540191402829},{"_id":"themes/hexo-theme-next-6.2.0/scripts/tags/tabs.js","hash":"aa7fc94a5ec27737458d9fe1a75c0db7593352fd","modified":1540191402838},{"_id":"themes/hexo-theme-next-6.2.0/source/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1540191403976},{"_id":"themes/hexo-theme-next-6.2.0/source/css/main.styl","hash":"2a62e2a11e9cdcc69e538d856d6f9ce228a07c93","modified":1540191403970},{"_id":"themes/hexo-theme-next-6.2.0/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1540191403982},{"_id":"themes/hexo-theme-next-6.2.0/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1540191403978},{"_id":"themes/hexo-theme-next-6.2.0/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1540191403977},{"_id":"themes/hexo-theme-next-6.2.0/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1540191403988},{"_id":"themes/hexo-theme-next-6.2.0/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1540191403993},{"_id":"themes/hexo-theme-next-6.2.0/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1540191403998},{"_id":"themes/hexo-theme-next-6.2.0/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1540191404002},{"_id":"themes/hexo-theme-next-6.2.0/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1540191404008},{"_id":"themes/hexo-theme-next-6.2.0/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1540191404012},{"_id":"themes/hexo-theme-next-6.2.0/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1540191404013},{"_id":"themes/hexo-theme-next-6.2.0/source/images/icons8-whale-16.png","hash":"b0f7d967de363cba6ec74143c8649e35b67e3ecb","modified":1540191404015},{"_id":"themes/hexo-theme-next-6.2.0/source/images/icons8-whale-32.png","hash":"6a9f81750551e526052fcfdfce9fb415157c5435","modified":1540191404016},{"_id":"themes/hexo-theme-next-6.2.0/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1540191404017},{"_id":"themes/hexo-theme-next-6.2.0/source/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1540191404022},{"_id":"themes/hexo-theme-next-6.2.0/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1540191404023},{"_id":"themes/hexo-theme-next-6.2.0/source/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1540191404028},{"_id":"themes/hexo-theme-next-6.2.0/source/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1540191404032},{"_id":"themes/hexo-theme-next-6.2.0/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1540191404034},{"_id":"source/_posts/machine-learning-for-trading/1532675498707.png","hash":"075394cee50dd46a9d0667d54cc4b4010423d145","modified":1540191401572},{"_id":"source/_posts/机器学习开放课程：三、分类、决策树和K近邻/3VT+hGyI.png","hash":"647132684a57561aa3d2430d2af07c103b825684","modified":1540531764137},{"_id":"source/_posts/机器学习开放课程：三、分类、决策树和K近邻/NZXca6g.png","hash":"19478fc1bdb3057490c45dc18c9ccfc8e8905165","modified":1540531762377},{"_id":"themes/hexo-theme-next-6.2.0/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1540191404014},{"_id":"themes/hexo-theme-next-6.2.0/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1540191402273},{"_id":"themes/hexo-theme-next-6.2.0/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1540191402273},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1540191403292},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1540191403292},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1540191403304},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1540191403952},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1540191403965},{"_id":"source/_posts/machine-learning-for-trading/1534238787357.png","hash":"f24576340fdcd959c52a6843281e9cd4b2666100","modified":1540191401605},{"_id":"source/_posts/pythoncore/pythoncore.png","hash":"0e2116f9d1e6f149c302d19df2ec46d6dfa12077","modified":1540191401652},{"_id":"source/_posts/rljs/rljs.png","hash":"1d8cc0451c74287e7ee59589c55d3e2e03dada6f","modified":1540191401661},{"_id":"themes/hexo-theme-next-6.2.0/layout/_macro/menu/menu-badge.swig","hash":"4eb8e222dc337211efb0d3bbdb5e29af3e6ecdb8","modified":1540191402063},{"_id":"themes/hexo-theme-next-6.2.0/layout/_macro/menu/menu-item.swig","hash":"aab518204d3125e948796a9ba6b56b09cade2d92","modified":1540191402067},{"_id":"themes/hexo-theme-next-6.2.0/layout/_partials/head/external-fonts.swig","hash":"f5e487b0d213ca0bd94aa30bc23b240d65081627","modified":1540191402131},{"_id":"themes/hexo-theme-next-6.2.0/layout/_partials/head/head-unique.swig","hash":"2048f9a47bfcc14b689d776028626f46d2865732","modified":1540191402140},{"_id":"themes/hexo-theme-next-6.2.0/layout/_partials/head/head.swig","hash":"60555b19a3b4bf203baa9bc0ea6267674f95235c","modified":1540191402150},{"_id":"themes/hexo-theme-next-6.2.0/layout/_partials/header/brand.swig","hash":"82e4a5e469d6f39b3e503ed879e4f32db31ec4f1","modified":1540191402155},{"_id":"themes/hexo-theme-next-6.2.0/layout/_partials/header/index.swig","hash":"83f6256070bad5f56f9298b046b00d4bfc562ffd","modified":1540191402160},{"_id":"themes/hexo-theme-next-6.2.0/layout/_partials/header/menu.swig","hash":"f3ae3168801304af3d80ec3b84264e1d4201cb89","modified":1540191402164},{"_id":"themes/hexo-theme-next-6.2.0/layout/_partials/header/sub-menu.swig","hash":"3f11ae8e9084f39628cd2006931d39a2069b9dd6","modified":1540191402170},{"_id":"themes/hexo-theme-next-6.2.0/layout/_partials/search/index.swig","hash":"f6454c452b2e90a8c760321bce7e3dc6119b71fa","modified":1540191402184},{"_id":"themes/hexo-theme-next-6.2.0/layout/_partials/search/localsearch.swig","hash":"b2f0d247b213e4cf8de47af6a304d98070cc7256","modified":1540191402189},{"_id":"themes/hexo-theme-next-6.2.0/layout/_partials/search/swiftype.swig","hash":"a8c7f9ca7c605d039a1f3bf4e4d3183700a3dd62","modified":1540191402199},{"_id":"themes/hexo-theme-next-6.2.0/layout/_partials/search/tinysou.swig","hash":"b25002a83cbd2ca0c4a5df87ad5bff26477c0457","modified":1540191402203},{"_id":"themes/hexo-theme-next-6.2.0/layout/_partials/share/add-this.swig","hash":"9e3d133ac5bcc6cb51702c83b2611a49811abad1","modified":1540191402210},{"_id":"themes/hexo-theme-next-6.2.0/layout/_partials/share/baidushare.swig","hash":"d9e2d9282f9be6e04eae105964abb81e512bffed","modified":1540191402233},{"_id":"themes/hexo-theme-next-6.2.0/layout/_partials/share/duoshuo_share.swig","hash":"d4fbffd7fa8f2090eb32a871872665d90a885fac","modified":1540191402239},{"_id":"themes/hexo-theme-next-6.2.0/layout/_partials/share/jiathis.swig","hash":"0a9cdd6958395fcdffc80ab60f0c6301b63664a5","modified":1540191402249},{"_id":"themes/hexo-theme-next-6.2.0/layout/_scripts/pages/post-details.swig","hash":"9775c1493597595c0fabd9f02010697e5ea6f03b","modified":1542077351953},{"_id":"themes/hexo-theme-next-6.2.0/layout/_scripts/schemes/gemini.swig","hash":"a9a3995b9615adfb8d6b127c78c6771627bee19a","modified":1540191402273},{"_id":"themes/hexo-theme-next-6.2.0/layout/_scripts/schemes/pisces.swig","hash":"a9a3995b9615adfb8d6b127c78c6771627bee19a","modified":1540191402275},{"_id":"themes/hexo-theme-next-6.2.0/layout/_third-party/analytics/analytics-with-widget.swig","hash":"ff947f3561b229bc528cb1837d4ca19612219411","modified":1540191402289},{"_id":"themes/hexo-theme-next-6.2.0/layout/_third-party/analytics/application-insights.swig","hash":"71397a5823e8ec8aad3b68aace13150623b3e19d","modified":1540191402303},{"_id":"themes/hexo-theme-next-6.2.0/layout/_third-party/analytics/baidu-analytics.swig","hash":"753d262911c27baf663fcaf199267133528656af","modified":1540191402319},{"_id":"themes/hexo-theme-next-6.2.0/layout/_third-party/analytics/busuanzi-counter.swig","hash":"c43f41b7f3c0743d1e673af2e787ea34a67fc9cb","modified":1540191402325},{"_id":"themes/hexo-theme-next-6.2.0/layout/_third-party/analytics/cnzz-analytics.swig","hash":"a10b7f19d7b5725527514622899df413a34a89db","modified":1540191402331},{"_id":"themes/hexo-theme-next-6.2.0/layout/_third-party/analytics/facebook-sdk.swig","hash":"7d94845f96197d9d84a405fa5d4ede75fb81b225","modified":1540191402342},{"_id":"themes/hexo-theme-next-6.2.0/layout/_third-party/analytics/firestore.swig","hash":"d67d9a176a276cdab6f2bcb7eb3650fbca5459c4","modified":1540191402357},{"_id":"themes/hexo-theme-next-6.2.0/layout/_third-party/analytics/google-analytics.swig","hash":"cfc932c5db04fef64cc56d3ba0b8ddf3a15a63bd","modified":1540191402368},{"_id":"themes/hexo-theme-next-6.2.0/layout/_third-party/analytics/index.swig","hash":"45f3f629c2aacc381095750e1c8649041a71a84b","modified":1540191402373},{"_id":"themes/hexo-theme-next-6.2.0/layout/_third-party/analytics/lean-analytics.swig","hash":"7973b4741863362cd9d023216de4a43eb23dc227","modified":1540191402395},{"_id":"themes/hexo-theme-next-6.2.0/layout/_third-party/analytics/tencent-analytics.swig","hash":"8a399df90dadba5ad4e781445b58f4765aeb701e","modified":1540191402410},{"_id":"themes/hexo-theme-next-6.2.0/layout/_third-party/analytics/tencent-mta.swig","hash":"5a8027328f060f965b3014060bebec1d7cf149c1","modified":1540191402421},{"_id":"themes/hexo-theme-next-6.2.0/layout/_third-party/analytics/vkontakte-api.swig","hash":"f9a1647a8f1866deeb94052d1f87a5df99cb1e70","modified":1540191402432},{"_id":"themes/hexo-theme-next-6.2.0/layout/_third-party/comments/changyan.swig","hash":"4c501ea0b9c494181eb3c607c5526a5754e7fbd8","modified":1540191402464},{"_id":"themes/hexo-theme-next-6.2.0/layout/_third-party/comments/disqus.swig","hash":"a693a2c00497471d06113443f548b676ee2e527d","modified":1540191402477},{"_id":"themes/hexo-theme-next-6.2.0/layout/_third-party/comments/gitment.swig","hash":"292cdd1059b76d3d10486b71c99d9afb3e59ea44","modified":1540191402489},{"_id":"themes/hexo-theme-next-6.2.0/layout/_third-party/comments/hypercomments.swig","hash":"787d482d797c38e77d69629ebb88d45f972216b7","modified":1540191402499},{"_id":"themes/hexo-theme-next-6.2.0/layout/_third-party/comments/index.swig","hash":"18a58db53f1eef50462ee0065d4445b7fbb04fb5","modified":1540191402503},{"_id":"themes/hexo-theme-next-6.2.0/layout/_third-party/comments/livere.swig","hash":"7cf0c589d95a2d1848266ffe2357e91c95d2e7f8","modified":1540191402514},{"_id":"themes/hexo-theme-next-6.2.0/layout/_third-party/comments/valine.swig","hash":"de1fac9bb3f0cab88b1ed1950f76c7eb0037aeda","modified":1540191402525},{"_id":"themes/hexo-theme-next-6.2.0/layout/_third-party/comments/youyan.swig","hash":"ab181c036cda9656f87bb1a749e3e7cbc437f012","modified":1540191402531},{"_id":"themes/hexo-theme-next-6.2.0/layout/_third-party/math/index.swig","hash":"30e9e55d9af2ced6e6b156a042026a8b480f0ab0","modified":1540191402557},{"_id":"themes/hexo-theme-next-6.2.0/layout/_third-party/math/katex.swig","hash":"860de4ce6fccc516d2f779a4b600a4214d8c18e2","modified":1540191402561},{"_id":"themes/hexo-theme-next-6.2.0/layout/_third-party/math/mathjax.swig","hash":"61f483d93dde1e1d1c4293412687a19ece1ba24f","modified":1540366505845},{"_id":"themes/hexo-theme-next-6.2.0/layout/_third-party/search/index.swig","hash":"34599633658f3b0ffb487728b7766e1c7b551f5a","modified":1540191402637},{"_id":"themes/hexo-theme-next-6.2.0/layout/_third-party/search/localsearch.swig","hash":"71c897f9b107dd0de1b7f649633cf583c206a9db","modified":1540191402657},{"_id":"themes/hexo-theme-next-6.2.0/layout/_third-party/search/tinysou.swig","hash":"fe95dd3d166634c466e19aa756e65ad6e8254d3e","modified":1540191402669},{"_id":"themes/hexo-theme-next-6.2.0/layout/_third-party/seo/baidu-push.swig","hash":"d8c98938719284fa06492c114d99a1904652a555","modified":1540191402681},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_custom/custom.styl","hash":"3403fdd8efde1a0afd11ae8a5a97673f5903087f","modified":1540191403287},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_mixins/Gemini.styl","hash":"07f7da320689f828f6e36a6123807964a45157a0","modified":1540191403291},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_mixins/Pisces.styl","hash":"8aa98ae349908736ba43196c42498fd5bdeb780a","modified":1540191403296},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_mixins/base.styl","hash":"4d6dd32dae6f0ea93d43c5cfa0106b6cb46c3b00","modified":1540191403304},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_variables/Gemini.styl","hash":"8b5fc9e6621a5de04ae7d9ef117683c69965fb00","modified":1540191403947},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_variables/Mist.styl","hash":"a25408534f8fe6e321db4bbf9dd03335d648fe17","modified":1540191403952},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_variables/Pisces.styl","hash":"b89e68789e6dac24e00250528f4fc9ae8aa3599b","modified":1540191403957},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_variables/base.styl","hash":"2be0b78c4879163fb13bd85602273815a0f14041","modified":1540564918903},{"_id":"themes/hexo-theme-next-6.2.0/source/js/src/affix.js","hash":"1b509c3b5b290a6f4607f0f06461a0c33acb69b1","modified":1540191404044},{"_id":"themes/hexo-theme-next-6.2.0/source/js/src/algolia-search.js","hash":"cb431b54ba9c692165a1f5a12e4c564a560f8058","modified":1540191404053},{"_id":"themes/hexo-theme-next-6.2.0/source/js/src/bootstrap.js","hash":"8e9ed6392620ba68726c0ade4868100d831daba8","modified":1540191404063},{"_id":"themes/hexo-theme-next-6.2.0/source/js/src/exturl.js","hash":"a2a0f0de07e46211f74942a468f42ee270aa555c","modified":1540191404076},{"_id":"themes/hexo-theme-next-6.2.0/source/js/src/js.cookie.js","hash":"1512c751d219577d338ac0780fb2bbd9075d5298","modified":1540191404092},{"_id":"themes/hexo-theme-next-6.2.0/source/js/src/motion.js","hash":"bea49fc6392bd38fb6f80d041d95d23051423aa2","modified":1540191404105},{"_id":"themes/hexo-theme-next-6.2.0/source/js/src/post-details.js","hash":"02acfa1862d5e4345d6a7cee08841cc9e2fb0259","modified":1540191404116},{"_id":"themes/hexo-theme-next-6.2.0/source/js/src/scroll-cookie.js","hash":"02cf91514e41200bc9df5d8bdbeb58575ec06074","modified":1540191404133},{"_id":"themes/hexo-theme-next-6.2.0/source/js/src/scrollspy.js","hash":"b7657be25fc52ec67c75ab5481bdcb483573338b","modified":1540191404146},{"_id":"themes/hexo-theme-next-6.2.0/source/js/src/utils.js","hash":"d8d288bc41af85fc72882239529131cbd6a13f9d","modified":1540191404159},{"_id":"themes/hexo-theme-next-6.2.0/source/lib/velocity/velocity.min.js","hash":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1540191404233},{"_id":"themes/hexo-theme-next-6.2.0/source/lib/velocity/velocity.ui.js","hash":"dbbfb50f6502f6b81dcc9fee7b31f1e812da3464","modified":1540191404245},{"_id":"themes/hexo-theme-next-6.2.0/source/lib/velocity/velocity.ui.min.js","hash":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1540191404261},{"_id":"source/_posts/machine-learning-for-trading/1533869822902.png","hash":"34972fcd325e1dde1960d19d0bdbe7309028493a","modified":1540191401581},{"_id":"source/_posts/machine-learning-for-trading/1536045019373.png","hash":"9a3e6520ff76ecbad723c9e2a7d0cd9affe2de97","modified":1540191401612},{"_id":"source/_posts/rljs/timg.jpg","hash":"457ce08cba0552e30e94cd2475a0f9a19585c9d0","modified":1540191401667},{"_id":"source/_posts/website/website.png","hash":"e64dc62eb242fed34431c0e180f3e05d5b3e01e8","modified":1540191401675},{"_id":"source/_posts/概率论基础教程/image-20180722140112814.png","hash":"8bfa98bc255f13899cc4ed30b01100c9b1721e90","modified":1540191401700},{"_id":"themes/hexo-theme-next-6.2.0/source/lib/jquery/index.js","hash":"17a740d68a1c330876c198b6a4d9319f379f3af2","modified":1540191404192},{"_id":"source/_posts/minjiekaifa/minjiekaifa.png","hash":"d0e6bec98c4b0412b6fdcb2d3ee000c5894ceb42","modified":1540191401626},{"_id":"themes/hexo-theme-next-6.2.0/layout/_third-party/search/algolia-search/assets.swig","hash":"218cc936ba3518a3591b2c9eda46bc701edf7710","modified":1540191402626},{"_id":"themes/hexo-theme-next-6.2.0/layout/_third-party/search/algolia-search/dom.swig","hash":"2530de0f3125a912756f6c0e9090cd012134a4c5","modified":1540191402632},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_common/components/back-to-top-sidebar.styl","hash":"8f86f694c0749a18ab3ad6f6df75466ca137a4bc","modified":1540191402844},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_common/components/back-to-top.styl","hash":"237d185ac62ec9877e300947fa0109c44fb8db19","modified":1540191402849},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_common/components/buttons.styl","hash":"8b32928686c327151e13d3ab100157f9a03cd59f","modified":1540191402854},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_common/components/comments.styl","hash":"ff4489cd582f518bba6909a301ac1292a38b4e96","modified":1540191402858},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_common/components/components.styl","hash":"7ad4081466b397e2a6204141bb7768b7c01bd93c","modified":1540191402864},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_common/components/pagination.styl","hash":"4f2801fc4cf3f31bf2069f41db8c6ce0e3da9e39","modified":1540191402948},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_common/components/tag-cloud.styl","hash":"6eb4bcc3056bd279d000607e8b4dad50d368ca69","modified":1540191403086},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_common/outline/outline.styl","hash":"12662536c7a07fff548abe94171f34b768dd610f","modified":1540191403196},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_common/scaffolding/base.styl","hash":"9afffb78858b94ebbfee2ae5ea21d420a052e469","modified":1542030869162},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_common/scaffolding/helpers.styl","hash":"1da5c800d025345f212a3bf1be035060f4e5e6ed","modified":1540191403218},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_common/scaffolding/normalize.styl","hash":"3f40e8a9fe8e7bd5cfc4cf4cbbbcb9539462e973","modified":1540191403230},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_common/scaffolding/mobile.styl","hash":"91ca75492cd51f2553f4d294ed2f48239fcd55eb","modified":1540191403224},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_common/scaffolding/scaffolding.styl","hash":"a17e2b871a335f290afb392a08f94fd35f59c715","modified":1540191403244},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_common/scaffolding/tables.styl","hash":"52bc8ba71b91d954530b35dfc63b402a02b1321d","modified":1540191403251},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_schemes/Gemini/index.styl","hash":"c08eb379718fa5af267fd8c5fe9b926003c0c7c7","modified":1540191403315},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_schemes/Mist/_header.styl","hash":"d0bfd1bef988c76f7d7dd72d88af6f0908a8b0db","modified":1540191403621},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_schemes/Mist/_base.styl","hash":"d0e9065b0dbbc01811259f0597d1790268b4881b","modified":1540191403323},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_schemes/Mist/_menu.styl","hash":"f3aa863adf972569b72f2df6bc6a914e7daace99","modified":1540191403632},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_schemes/Mist/_logo.styl","hash":"b1025c421406d2c24cc92a02ae28c1915b01e240","modified":1540191403626},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_schemes/Mist/_posts-expanded.styl","hash":"2798224276a40a1978c47a6c251a942666b216ba","modified":1540191403639},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_schemes/Mist/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1540191403645},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_schemes/Mist/index.styl","hash":"e3b275a5bbd7ce5e8937691a432bb45fc4818ba7","modified":1540191403663},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_schemes/Muse/_layout.styl","hash":"31127dcbf4c7b4ada53ffbf1638b5fe325b7cbc0","modified":1540191403679},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_schemes/Muse/_logo.styl","hash":"748dbfbf9c08e719ddc775958003c64b00d39dab","modified":1540191403683},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_schemes/Muse/_menu.styl","hash":"3cc7646583218d16925ced7b70865e63a901d4a7","modified":1540191403688},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_schemes/Muse/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1540191403690},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_schemes/Muse/index.styl","hash":"b26f8a3394d8357a5bfd24d9f8bf62d7b4063ebb","modified":1540191403695},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_schemes/Pisces/_brand.styl","hash":"bce344d3a665b4c55230d2a91eac2ad16d6f32fd","modified":1540191403702},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_schemes/Pisces/_layout.styl","hash":"ab7eb1d66e300264a225feb6f8bed55683c96cdf","modified":1540191403708},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_schemes/Pisces/_menu.styl","hash":"cc961108b12ab97d9216606ceb1cd1cd31ab20f0","modified":1540191403713},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_schemes/Pisces/_posts.styl","hash":"1f6e2ce674735269599acc6d77b3ea18d31967fc","modified":1540191403718},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_schemes/Pisces/_sidebar.styl","hash":"df16dc995eb9ad498df2edcfc3e20528fc9aa133","modified":1540191403733},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_schemes/Pisces/index.styl","hash":"a558803ca81cceae2bdc22c18ef638fcc023681b","modified":1540191403941},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_schemes/Pisces/_sub-menu.styl","hash":"be72740313a9a0477b8a22f62e4c8ffa6d23a2e5","modified":1540191403740},{"_id":"themes/hexo-theme-next-6.2.0/source/js/src/schemes/pisces.js","hash":"f1d0b5d7af32c423eaa8bb93ab6a0b45655645dc","modified":1540191404125},{"_id":"source/_posts/machine-learning-for-trading/1533886709495.png","hash":"7523fbb409d296617ce52b85fc24a11882df839b","modified":1540191401598},{"_id":"source/_posts/machine-learning-for-trading/1535439244770.png","hash":"cf526468b877d5cb0eb70df70ce92c13b9a1162f","modified":1540191401609},{"_id":"themes/hexo-theme-next-6.2.0/source/lib/velocity/velocity.js","hash":"4237c6e9d59da349639de20e559e87c2c0218cfd","modified":1540191404213},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_common/components/footer/footer.styl","hash":"7dd247c8869fdefb5a007045d00f3ef8ceecf300","modified":1540191402869},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_common/components/header/headerband.styl","hash":"d63e0cacc53dd375fcc113465a4328c59ff5f2c1","modified":1540191402882},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_common/components/header/header.styl","hash":"34f5ac3c1ed2dd31e9297cc4c0733e71bc2e252f","modified":1540191402878},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_common/components/header/menu.styl","hash":"1a0d059799a298fe17c49a44298d32cebde93785","modified":1540191402888},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_common/components/header/site-meta.styl","hash":"0656e753f182c9f47fef7304c847b7587a85ef0d","modified":1540191402893},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_common/components/header/site-nav.styl","hash":"1727702eac5d326b5c81a667944a245016668231","modified":1540191402897},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_common/components/highlight/diff.styl","hash":"167986d0f649516671ddf7193eebba7b421cd115","modified":1540191402903},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_common/components/highlight/highlight.styl","hash":"835c1340571bd6c4ec263c482cf13283fb047e49","modified":1540191402908},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_common/components/highlight/theme.styl","hash":"7fe4d4d656e86276c17cb4e48a560cb6a4def703","modified":1540191402913},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_common/components/pages/archive.styl","hash":"b6f3a06a94a6ee5470c956663164d58eda818a64","modified":1540191402919},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_common/components/pages/breadcrumb.styl","hash":"630be616447a982413030e561bbd3a80ac14b120","modified":1540191402923},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_common/components/pages/categories.styl","hash":"7fb593f90d74a99c21840679933b9ef6fdc16a61","modified":1540191402928},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_common/components/pages/pages.styl","hash":"ad4cae23c8e383f4fabc9a2a95bca6055020d22e","modified":1540191402934},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_common/components/pages/post-detail.styl","hash":"4e3838d7ac81d9ad133960f0f7ed58a44a015285","modified":1540191402939},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_common/components/pages/schedule.styl","hash":"8cf318644acc8b4978537c263290363e21c7f5af","modified":1540191402944},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_common/components/post/post-button.styl","hash":"62fbbd32cf5a99ae550c45c763a2c4813a138d01","modified":1540191402953},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_common/components/post/post-collapse.styl","hash":"875cbe88d5c7f6248990e2beb97c9828920e7e24","modified":1540191402960},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_common/components/post/post-copyright.styl","hash":"caf263d1928496688c0e1419801eafd7e6919ce5","modified":1540191402964},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_common/components/post/post-eof.styl","hash":"a200c0a1c5a895ac9dc41e0641a5dfcd766be99b","modified":1540191402969},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_common/components/post/post-expand.styl","hash":"317c9ceda655e9dc373ce8e7b71d20b794fce9a4","modified":1540191402977},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_common/components/post/post-gallery.styl","hash":"c3271c206c5ce67c6c641a865b9bd8bbcafbed21","modified":1540191402982},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_common/components/post/post-meta.styl","hash":"330c8884efb5612e7eb03986d87d29e8b0651974","modified":1540191402986},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_common/components/post/post-nav.styl","hash":"27deb3d3a243d30022055dac7dad851024099a8b","modified":1540191402991},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_common/components/post/post-reading_progress.styl","hash":"82bc7fa5d38d98e98cc25f9a73189024fda25e63","modified":1540191402995},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_common/components/post/post-reward.styl","hash":"ca88ea6999a61fb905eb6e72eba5f92d4ee31e6e","modified":1540191403000},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_common/components/post/post-rtl.styl","hash":"b2495ae5e04dcca610aacadc47881d9e716cd440","modified":1540191403005},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_common/components/post/post-tags.styl","hash":"5a982d8ef3b3623ea5f59e63728990f5623c1b57","modified":1540191403010},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_common/components/post/post-title.styl","hash":"adfd6d2d3b34adc4b476a0ea91e19020456a3b1a","modified":1540191403014},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_common/components/post/post-type.styl","hash":"01567edaea6978628aa5521a122a85434c418bfd","modified":1540191403020},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_common/components/post/post-widgets.styl","hash":"7968343e41f8b94b318c36289dff1196c3eb1791","modified":1540191403025},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_common/components/post/post.styl","hash":"1faeb3fca899df9d033e4e6ad9a4867cdce7ef9d","modified":1540191403030},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"fa57ec9a6f1943c0558856dfba2d6b8faca0cd4d","modified":1540191403036},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_common/components/sidebar/sidebar-author.styl","hash":"761eba9811b050b25d548cc0854de4824b41eb08","modified":1540191403041},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"8dd9a1c6f4f6baa00c2cf01837e7617120cf9660","modified":1540191403045},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"11c22f0fb3f6beb13e5a425ec064a4ff974c13b7","modified":1540191403051},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"61f8cea3c01acd600e90e1bc2a07def405503748","modified":1540191403055},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"1153bb71edf253765145559674390e16dd67c633","modified":1540191403061},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"9e05a2232faabb41bcebb51d545d897a76f077da","modified":1540191403067},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_common/components/sidebar/sidebar.styl","hash":"94d76e6da600a36d80e2470326ebb6b3be447ccb","modified":1540191403077},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_common/components/sidebar/site-state.styl","hash":"e71652d3216e289c8548b1ea2357822c1476a425","modified":1540191403081},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_common/components/tags/blockquote-center.styl","hash":"2fe76476432b31993338cb45cdb3b29a518b6379","modified":1540191403092},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_common/components/tags/exturl.styl","hash":"a3bdd71237afc112b2aa255f278cab6baeb25351","modified":1540191403099},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"a1521d48bb06d8d703753f52a198baa197af7da2","modified":1540191403072},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_common/components/tags/full-image.styl","hash":"d79c051abb8ab7b5ee5da29a28587704fd5108f5","modified":1540191403105},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_common/components/tags/group-pictures.styl","hash":"2ad1a2a9bbf6742d1b0762c4c623b68113d1e0fe","modified":1540191403109},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_common/components/tags/label.styl","hash":"2ab1322fe52ab5aafd49e68f5bd890e8380ee927","modified":1540191403114},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_common/components/tags/note-modern.styl","hash":"b7076e58d647265ee0ad2b461fe8ce72c9373bc5","modified":1540191403119},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_common/components/tags/note.styl","hash":"9a409b798decdefdaf7a23f0b11004a8c27e82f3","modified":1540191403124},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_common/components/tags/tabs.styl","hash":"154a87a32d2fead480d5e909c37f6c476671c5e6","modified":1540191403132},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_common/components/tags/tags.styl","hash":"b80604868e4f5cf20fccafd7ee415c20c804f700","modified":1540191403137},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_common/components/third-party/algolia-search.styl","hash":"f4d8144c22544bdb89787c14ab9d39578dae4b7c","modified":1540191403144},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_common/components/third-party/baidushare.styl","hash":"5dbeed535d63a50265d96b396a5440f9bb31e4ba","modified":1540191403148},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"a6e7d698702c2e383dde3fde2abde27951679084","modified":1540191403153},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_common/components/third-party/gitment.styl","hash":"874278147115601d2abf15987f5f7a84ada1ac6b","modified":1540191403157},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_common/components/third-party/han.styl","hash":"10599e16414a8b7a76c4e79e6617b5fe3d4d1adf","modified":1540191403162},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_common/components/third-party/jiathis.styl","hash":"15975ba7456b96916b1dbac448a1a0d2c38b8f3d","modified":1540191403167},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_common/components/third-party/localsearch.styl","hash":"16087276945fa038f199692e3eabb1c52b8ea633","modified":1540191403171},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_common/components/third-party/needsharebutton.styl","hash":"28825ae15fa20ae3942cdaa7bcc1f3523ce59acc","modified":1540191403178},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_common/components/third-party/related-posts.styl","hash":"acfdd76b1c90d2e384affb3d0006a39b524609d2","modified":1540191403183},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_common/components/third-party/third-party.styl","hash":"0b9c4140d7bc526553553552c3ed92da7c81e0b6","modified":1540191403188},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_schemes/Mist/outline/outline.styl","hash":"a07aa12cc36ac5c819670c2a3c17d07ed7a08986","modified":1540191403668},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1540191403673},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1540191403697},{"_id":"source/_posts/machine-learning-for-trading/1533890419564.png","hash":"9c6cbac75b29b50f85e25ad453907ac6a75a94ad","modified":1540191401603},{"_id":"source/_posts/wuhezhizhong/wuhezhizhong.png","hash":"18e722b200bb820067b9608d9c72847a38f81fde","modified":1540191401683},{"_id":"themes/hexo-theme-next-6.2.0/source/css/_common/components/header/github-banner.styl","hash":"3f3d2a43d1a326bad25b633c8ec9ddd87867224c","modified":1540191402873},{"_id":"source/_posts/machine-learning-for-trading/1533883259793.png","hash":"5fc8ecb62a2852d7dcb93d0e40c511f771d464b0","modified":1540191401586},{"_id":"source/_posts/machine-learning-for-trading/1533883675299.png","hash":"d74a7e5f3401c6f8fd6761126e3df5a55cb651d1","modified":1540191401593},{"_id":"source/_posts/机器学习开放课程：五、Bagging与随机森林/credit_scoring_sample.csv","hash":"cbd078df1cc059c07039b1bb522057861ea49ea8","modified":1541050792493},{"_id":"source/_posts/机器学习开放课程：三、分类、决策树和K近邻/mlbootcamp5_train.csv","hash":"9567e14eeb73f78a8169051eb9ade443e78fe068","modified":1540265576713},{"_id":"source/_posts/机器学习开放课程：六、特征工程和特征选取/信息检索导论.pdf","hash":"85edc3e047ab1236f343cd413ce6c59ff3b1c3f3","modified":1541984109974}],"Category":[{"name":"编程","_id":"cjof51pjo0004rgue255kmxn1"},{"name":"Python","parent":"cjof51pjo0004rgue255kmxn1","_id":"cjof51pk5000drgue5mw9qc58"},{"name":"阅读","_id":"cjof51pks000lrgueg8jzb780"},{"name":"机器学习","parent":"cjof51pk5000drgue5mw9qc58","_id":"cjof51pl40013rguee9aotn9b"},{"name":"金融","parent":"cjof51pk5000drgue5mw9qc58","_id":"cjof51pl9001arguexmk5ctax"},{"name":"数学","_id":"cjof51ple001prgueptuwmxvo"},{"name":"股票","parent":"cjof51pl9001arguexmk5ctax","_id":"cjof51plj0025rgue1bs6w71d"}],"Data":[],"Page":[{"title":"分类","date":"2018-04-23T11:59:24.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2018-04-23 19:59:24\ntype: \"categories\"\ncomments: false\n---\n","updated":"2018-10-22T06:56:41.704Z","path":"categories/index.html","layout":"page","_id":"cjof51pjf0001rguexr6lnd88","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"标签","date":"2018-04-23T11:58:04.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2018-04-23 19:58:04\ntype: \"tags\"\ncomments: false\n---\n","updated":"2018-10-22T06:56:41.709Z","path":"tags/index.html","layout":"page","_id":"cjof51pjl0003rguej49org4i","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Machine Learning for Trading","date":"2018-07-11T09:07:13.000Z","updated":"2018-09-02T16:00:00.000Z","typora-root-url":"machine-learning-for-trading","mathjax":true,"description":"<!—more—->","_content":"\n教程Youtube链接:[https://www.youtube.com/playlist?list=PLAwxTw4SYaPnIRwl6rad_mYwEk4Gmj7Mx](https://www.youtube.com/playlist?list=PLAwxTw4SYaPnIRwl6rad_mYwEk4Gmj7Mx)\n\n### 单一股票收益\n\n#### The Data (介绍CSV文件)\n\n#### Our Stock Data (介绍股票每日成交汇总数据格式)\n\n* Date\n* Open\n* High\n* Low\n* Close\n* Volume -> 成交量\n* Adj Close -> 调整收盘价（除权除息价）\n\n#### Pandas Dataframe\n\n#### Actual CSV\n\n#### Interesting Stuff\n\n切片：取 `Dataframe` 中的部分数据\n\n[pandas.DataFrame.loc](http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.loc.html#pandas.DataFrame.loc)\n\n#### Compute max closing price\n\n[pandas.Series.max](http://pandas.pydata.org/pandas-docs/stable/generated/pandas.Series.max.html#pandas-series-max)\n\n#### Plotting stock price data (绘图)\n\n#### Plot two columns (绘制多个数据)\n\n```python\nimport matplotlib.pyplot as plt\nimport pandas as pd\nfrom finance_datareader_py.eastmoney.daily import EastMoneyDailyReader\n\ndf1 = EastMoneyDailyReader('601398').read()\ndf2 = EastMoneyDailyReader('601398', type='ba').read()\ndf = pd.DataFrame()\ndf['Close'] = pd.to_numeric(df1['Close'])\ndf['Adj Close'] = pd.to_numeric(df2['Close'])\nprint(df.tail())\ndf.plot()\nplt.show()\n```\n\n![1531304006175](1531304006175.png)\n\n#### Pandas dataframe recap\n\n#### Problems to Solve\n\n##### Data ranges(使用日期索引取值)\n\n```\nfrom finance_datareader_py.eastmoney.daily import EastMoneyDailyReader\ndf = EastMoneyDailyReader('601398').read()\ndf.tail()\nOut[4]: \n            Open Close  High   Low   交易量(手)   成交金额     振幅   换手率\n日期                                                             \n2018-07-05  5.17  5.23  5.29  5.16  1865183  9.72亿  2.52%  0.07\n2018-07-06  5.23  5.29  5.34  5.18  1925444  10.1亿  3.06%  0.07\n2018-07-09  5.31  5.53  5.54  5.31  2155458  11.7亿  4.35%  0.08\n2018-07-10  5.56  5.52  5.57  5.46  1289900  7.10亿  1.99%  0.05\n2018-07-11  5.41  5.48  5.52  5.39  1520449  8.31亿  2.36%  0.06\n\ndf['2017-01-01':'2017-12-31'].tail()\nOut[6]: \n            Open Close  High   Low   交易量(手)   成交金额     振幅   换手率\n日期                                                             \n2017-12-25  5.93  6.00  6.03  5.93  2396364  14.4亿  1.69%  0.09\n2017-12-26  6.00  6.08  6.10  5.98  2165329  13.1亿     2%  0.08\n2017-12-27  6.09  6.05  6.15  6.02  2151401  13.1亿  2.14%  0.08\n2017-12-28  6.03  6.14  6.14  6.02  2100886  12.8亿  1.98%  0.08\n2017-12-29  6.13  6.20  6.22  6.12  2168998  13.4亿  1.63%  0.08\n```\n\n取沪深300指数（399300）+单个股票数据。\n\n取沪深300指数的意义在于，只要开市，那么指数就肯定有数据，而不像其他单一股票可能会出现不定期停牌的情况。\n\n看下面的数据：\n\n1. 2005年，300027还没有上市，所以数值为 `NaN`。\n2. 2018-07-07、2018-07-08两天是休息日，不开市。这时不会有数据。\n\n```\nimport pandas as pd\nfrom finance_datareader_py.eastmoney.daily import EastMoneyDailyReader\ndf1 = EastMoneyDailyReader('399300').read()\ndf2 = EastMoneyDailyReader('300027').read()\ndf = pd.DataFrame()\ndf['399300'] = df1['Close']\ndf['300027'] = df2['Close']\n\ndf.head()\nOut[4]: \n            399300 300027\n日期                       \n2005-01-04  982.79    NaN\n2005-01-05  992.56    NaN\n2005-01-06  983.17    NaN\n2005-01-07  983.96    NaN\n2005-01-10  993.88    NaN\n\ndf.tail()\nOut[3]: \n             399300 300027\n日期                        \n2018-07-05  3342.44   6.08\n2018-07-06  3365.12   6.09\n2018-07-09  3459.18   6.12\n2018-07-10  3467.52   6.03\n2018-07-11  3407.53   5.96\n```\n\n#### Create an exmpty data frame\n\n#### Join SPY data (使用Join关联数据，使用dropna丢弃空数据)\n\n```\nimport pandas as pd\nfrom finance_datareader_py.eastmoney.daily import EastMoneyDailyReader\ndf1 = EastMoneyDailyReader('399300').read()\ndates = pd.date_range('2010-01-01', '2010-01-05')\n# 创建空白DataFrame\ndf = pd.DataFrame(index=dates)\ndf = df.join(df1)\n\ndf['Close'].head()\nOut[3]: \n2010-01-01        NaN\n2010-01-02        NaN\n2010-01-03        NaN\n2010-01-04    3535.23\n2010-01-05    3564.04\nFreq: D, Name: Close, dtype: object\n\ndf['Close'].head().dropna()\nOut[4]: \n2010-01-04    3535.23\n2010-01-05    3564.04\nFreq: D, Name: Close, dtype: object\n```\n\n#### Read in more stocks(重命名，一个dataframe中不能出现同名的列)\n\n#### Slicing (数据切片)\n\n```python\nimport pandas as pd\nfrom finance_datareader_py.eastmoney.daily import EastMoneyDailyReader\n\nsymbols = ['399300', '300027', '601398']\n\ndates = pd.date_range('2010-01-01', '2010-01-05')\n# 创建空白DataFrame\ndf = pd.DataFrame(index=dates)\nfor symbol in symbols:\n    df_temp = EastMoneyDailyReader(symbol).read()\n    df_temp = df_temp.rename(columns={'Close': symbol})\n    df = df.join(df_temp[symbol])\n\nprint(df)\nprint('------------------------')\nprint(df.dropna())\nprint('------------------------')\nprint(df.loc['2010-01-04':'2010-01-04',['000002', '601398']])\n```\n\n```\n             399300 300027 601398\n2010-01-01      NaN    NaN    NaN\n2010-01-02      NaN    NaN    NaN\n2010-01-03      NaN    NaN    NaN\n2010-01-04  3535.23  55.53   5.35\n2010-01-05  3564.04  55.09   5.40\n------------------------\n             399300 300027 601398\n2010-01-04  3535.23  55.53   5.35\n2010-01-05  3564.04  55.09   5.40\n------------------------\n             399300 300027\n2010-01-04  3535.23  55.53\n\n```\n\n#### Problems with Plotting (判断时股价起点不同，很难在同一层面观察)\n\n```python\nimport matplotlib.pyplot as plt\nimport pandas as pd\nfrom finance_datareader_py.eastmoney.daily import EastMoneyDailyReader\n\nsymbols = ['600519', '000002', '601398']\n\n# 创建空白DataFrame\ndf = pd.DataFrame()\nfor symbol in symbols:\n    df_temp = EastMoneyDailyReader(symbol).read()\n    df[symbol] = df_temp['Close']\n\ndf = df.dropna()\ndf.loc['2017-01-01':'2017-12-31'].plot()\nplt.show()\n```\n\n![1531383436936](1531383436936.png)\n\n#### Normalizing (数据归一化)\n\n```\ndef normalize_data(df):\n    return df / df.iloc[0]\n\nnormalize_data(df.loc['2017-01-01':'2017-12-31']).plot()\n```\n\n让Dataframe的每一行数据除以第一行的值，从而使所有数据从1开始。\n\n![1531384011994](1531384011994.png)\n\n#### What is NumPy\n\n#### Relationship to Pandas (numpy与Pandas的关系)\n\n#### Compute global statistics\n\n[标准差](https://zh.wikipedia.org/wiki/%E6%A8%99%E6%BA%96%E5%B7%AE)\n\n> 例如，两组数的集合{0, 5, 9, 14}和{5, 6, 8, 9}其平均值都是7，但第二个集合具有较小的标准差。 \n\n#### Rolling statistics\n\n#### Bollinger Bands\n\n[布林带](https://zh.wikipedia.org/wiki/%E5%B8%83%E6%9E%97%E5%B8%A6)\n\n```python\ndf = pd.DataFrame()\ndf['Close'] = EastMoneyDailyReader('601398').read()['Close']\ndf['rol_30'] = pd.rolling_mean(df['Close'], window=30)\ndf.head(100).plot()\nplt.show()\n```\n\n![1531465284221](1531465284221.png)\n\n#### Daily returns (日收益)\n\n日收益基本上是围绕0上下浮动。\n\n`daily_ret[t]=(price[t]/price[t-1])-1`\n\n`(110/100)-1=1.1-1=0.1=10%`\n\n#### Cumulative returns (累计收益)\n\n累积收益和数据归一化在计算中的意思基本一致。\n\n#### A closer look at daily returns\n\n使用直方图展示日收益率的分布情况\n\n[峰度](https://zh.wikipedia.org/wiki/%E5%B3%B0%E5%BA%A6)\n\n> 峰度高就意味着方差增大是由低频度的大于或小于平均值的极端差值引起的。 \n\n[肥尾分布](https://zh.wikipedia.org/wiki/%E8%82%A5%E5%B0%BE%E5%88%86%E5%B8%83)\n\n#### Computing rolling statistics\n\n20日移动平均线\n\n```python\ndf = EastMoneyDailyReader('601398').read().tail(200)\nax = df['Close'].plot(title='601398 rolling mean')\nrm = pd.rolling_mean(df['Close'], window=20)\nrm.plot(label='Rolling mean', ax=ax)\n\nax.set_xlabel('Date')\nax.set_ylabel('Price')\nax.legend(loc='upper left')\nplt.show()\n```\n\n![1531632440578](1531632440578.png)\n\n#### Using fillna() (数据市场是不完整的，需要补齐)\n\n#### Histogram of daily returns (使用直方图来查看每日收益)\n\n#### How to plot a histogram (如何绘制直方图)\n\n```python\ndef compute_daily_returns(df):\n    return df[:-1].values / df[1:] - 1\n\n\ndf = EastMoneyDailyReader('601398').read()\ndaily_returns = compute_daily_returns(df['Close'])\ndaily_returns.hist(bins=50)\nprint(daily_returns.tail(100))\nplt.show()\n```\n\n![1531634310060](1531634310060.png)\n\n[关于证券收益分布原因的讨论](https://www.ricequant.com/community/topic/126/)\n\n#### 绘制平均值和标准差\n\n```python\n\nmean = daily_returns.mean()\nprint(\"mean=\", mean)\nstd = daily_returns.std()\nprint('std=', std)\nplt.axvline(mean, color='g')\nplt.axvline(std, color='r', linestyle='dashed')\nplt.axvline(-std, color='r', linestyle='dashed')\nplt.show()\n```\n\n![1531635134977](1531635134977.png)\n\n#### 计算峰度\n\n```python\nprint(daily_returns.kurtosis())\n```\n\n```\n7.34265127165\n```\n\n> 在机率论中，*肥尾分布**（英语：Fat-tailed distribution）是一种[机率分布](https://zh.wikipedia.org/wiki/%E6%A9%9F%E7%8E%87%E5%88%86%E5%B8%83)模型。它是一种[重尾分布](https://zh.wikipedia.org/wiki/%E9%87%8D%E5%B0%BE%E5%88%86%E5%B8%83)，但是它的[偏度](https://zh.wikipedia.org/wiki/%E5%81%8F%E5%BA%A6)或[峰度](https://zh.wikipedia.org/wiki/%E5%B3%B0%E5%BA%A6)极端的大。与无所不在的[正态分布](https://zh.wikipedia.org/wiki/%E5%B8%B8%E6%85%8B%E5%88%86%E5%B8%83)作比较，[正态分布](https://zh.wikipedia.org/wiki/%E5%B8%B8%E6%85%8B%E5%88%86%E5%B8%83)属于一种细尾分布，或[指数分布](https://zh.wikipedia.org/wiki/%E6%8C%87%E6%95%B0%E5%88%86%E5%B8%83)。 \n\n##### Plot two histograms together (合并绘制两个直方图)\n\n```python\nimport matplotlib.pyplot as plt\nimport pandas as pd\nfrom finance_datareader_py.eastmoney.daily import EastMoneyDailyReader\n\n\ndef compute_daily_returns(df):\n    return df[:-1].values / df[1:] - 1\n\n\ndf = pd.DataFrame()\ndf['601398'] = EastMoneyDailyReader('601398').read()['Close']\ndf['601939'] = EastMoneyDailyReader('601939').read()['Close']\n# 计算日收益率\ndaily_returns = compute_daily_returns(df)\n# 绘制直方图\ndaily_returns.hist()\n# 绘图\nplt.show()\n\n# 合并绘制两个直方图\ndaily_returns['601398'].hist(label='601398')\ndaily_returns['601939'].hist(label='601939')\nplt.legend(loc='upper right')\nplt.show()\n```\n\n![1532508260900](1532508260900.png)\n\n![1532508276951](1532508276951.png)\n\n股票和市场的日收益分布和高斯分布非常相似。这个性质对 *日收益、月收益、年收益* 来说同样适用。\n\n如果它们真的是高斯分布，那么我们就可以说它们是正态分布。\n\n**但是假定收益是正态分布的，却是非常危险的。因为它忽略了峰度或者尾部。** *正是因为这样才造成了08年的金融风暴。*\n\n#### Scatterplots (散点图)\n\n这是区分各支股票日收益的另一种方法。\n\n线性但离散的特点。\n\n\n\n{% blockquote Beta系数 https://zh.wikipedia.org/wiki/Beta%E7%B3%BB%E6%95%B0 %}\n贝他值（ $\\beta$ 值）：\n用以衡量基金之市场风险，或称系统性风险。其计算的方式为以过去12个月或24个月之基金月报酬率对同期市场月报酬率做回归，估计斜率系数而得，当 $\\beta$ >1（$\\beta$ < -1），表示基金坡动度较指数为大，当指数上扬 10%（下跌10%），基金会上扬超过 10%（下跌超过10%）；当 $\\beta$ = 1，表示指数涨跌多少，基金就跟着变动多少。\n{% endblockquote %}\n\n\n\n{% blockquote 阿尔法系数 https://zh.wikipedia.org/wiki/%E8%AF%81%E5%88%B8%E6%8A%95%E8%B5%84%E5%9F%BA%E9%87%91#%E9%98%BF%E5%B0%94%E6%B3%95%E7%B3%BB%E6%95%B0 %}\n阿尔法系数（ $\\alpha$）是基金的实际收益和按照β系数计算的期望收益之间的差额。其计算方法如下：超额收益是基金的收益减去无风险投资收益（在中国为1年期银行定期存款收益）；期望收益是贝塔系数 $\\beta$ 和市场收益的乘积，反映基金由于市场整体变动而获得的收益；超额收益和期望收益的差额即 $\\alpha$ 系数。该系数越大越好。\n{% endblockquote %}\n\n\n\n##### Slope does not equal correlation (斜率 $\\beta$ 系数与数据的相关性/拟合度无关)\n\n可能有很低的斜率，但是数据拟合度非常高。反之亦然。\n\n##### Scatterplots in python (散点图)\n\n```python\ndf = pd.DataFrame()\ndf['000300'] = SohuDailyReader('000300', prefix='zs_').read()['Close']\ndf['601398'] = SohuDailyReader('601398').read()['Close']\ndf['601939'] = SohuDailyReader('601939').read()['Close']\n# 计算日收益率\ndaily_returns = compute_daily_returns(df)\n# 绘制 601398 相对于 000300 的散点图\ndaily_returns.plot(kind='scatter', x='000300', y='601398')\nplt.show()\n# 绘制 601939 相对于 000300 的散点图\ndaily_returns.plot(kind='scatter', x='000300', y='601939')\nplt.show()\n```\n\n![1532570705884](1532570705884.png)\n\n![1532570720355](1532570720355.png)\n\n```python\nimport numpy as np\n\n# beta系数和alpha系数\nbeta, alpha = np.polyfit(daily_returns['000300'], daily_returns['601939'], 1)\n\ndaily_returns.plot(kind='scatter', x='000300', y='601939')\n# 绘制拟合线\nplt.plot(daily_returns['000300'], beta * daily_returns['000300'] + alpha, '-',\n         color='r')\nplt.show()\nprint('beta=' + str(beta))\nprint('alpha=' + str(alpha))\n```\n\n```\nbeta=0.590256550806\nalpha=-0.000246730309092\n```\n\n![1532571574686](1532571574686.png)\n\n### 投资组合\n\n#### Daily portfolio values\n\n[https://youtu.be/UweF-2-Tr9Y](https://youtu.be/UweF-2-Tr9Y)\n\n```\n投资组合假设：\nstart_val = 1000000 # 初始投资总额\nstart_date = 2011-01-01 # 初始投资日期\nend_date = 2011-12-31 # 结束投资日期\n# 投资组合：贵州茅台、中国平安、招商银行、格力电器\nsymbols = ['600519','601318','600036','000651'] \n# 比率分配\nallocs = [0.4,0.4,0.1,0.1]\n```\n\n#### 如何计算投资组合每日的总价值\n\n[https://youtu.be/UweF-2-Tr9Y](https://youtu.be/UweF-2-Tr9Y)\n\n1. 从价格 `DataFrame` 开始。\n2. 价格归一化（`normed=prices/prices[0]`）。开始日期的数据始终为1.0。\n3. 使用归一化以后的值乘以每支股票分配的资金比例（`alloced=normed*allocs`）。\n4. 使用初始投资总额乘以3的结果（`pos_vals=alloced*start_val`）\n5. 每一天的总价值：`port_val=pos_vals.sum(axis=1)`\n\n![1532675498707](1532675498707.png)\n\n计算后的每日收益的第一天的收益始终为 *0*，所以应该去除。 `daily_returns=daily_returns[1:]` \n\n有了每日收益之后可以计算很多有趣的数据。**评估投资组合时的常用数据**：\n\n* `cum_ret` 累计收益 `(port_val[-1]/port_val[0])-1`\n* `avg_daily_ret` 平均收益 `daily_rets.mean()`\n* `std_daily_ret` 每日收益标准差 `daily_rets.std()`\n* `sharpe_ratio` 夏普比率\n\n```python\nimport datetime\nimport pandas as pd\nfrom finance_datareader_py.sohu.daily import SohuDailyReader\n\ndef compute_daily_returns(df):\n    return df[:-1].values / df[1:] - 1\n\nSYMBOLS = ['600519', '601318', '600036', '000651']\nALLOCS = [0.4, 0.4, 0.1, 0.1]\nSTART = datetime.date(2009, 1, 1)\nEND = datetime.date(2011, 12, 31)\n\ndef get_datas(symbols, start, end):\n    df = pd.DataFrame()\n    df['000300'] = SohuDailyReader('000300', prefix='zs_', start=start,\n                                   end=end).read()['Close']\n    for symbol in symbols:\n        df1 = SohuDailyReader(symbol, start=start, end=end).read()\n        df1 = df1.rename(columns={'Close': symbol})\n        df = df.join(df1[symbol])\n    return df.fillna(method='bfill')  # 因为是倒序排序，所以使用bfill\n\ndf = get_datas(SYMBOLS, START, END)\ndf_ret = compute_daily_returns(df)\nprint(df)\nprint(df_ret)\nprint('-----------------')\nprint('平均收益:')\nprint(df_ret.mean())\nprint('-----------------')\nprint('每日收益标准差:')\nprint(df_ret.std())\nprint('-----------------')\nprint('累计收益:')\nprint(df.iloc[0] / df.iloc[-1] - 1)\n\n# 移除指数列，并按照比率分配\nalloced = df_nor.copy().drop('000300', axis=1) * ALLOCS\n# 按照比率分配后的各支股票的每日价值\npos_vals = alloced * START_VALS\n# 投资组合的每日价值\nport_val = pos_vals.sum(axis=1)\n```\n\n```\n-----------------\n平均收益:\n000300    0.000443\n600519    0.000973\n601318    0.000508\n600036    0.000162\n000651    0.000445\ndtype: float64\n-----------------\n每日收益标准差:\n000300    0.016803\n600519    0.018983\n601318    0.023065\n600036    0.021895\n000651    0.031399\ndtype: float64\n-----------------\n累计收益:\n000300    0.245773\n600519    0.783539\n601318    0.193761\n600036   -0.057188\n000651   -0.074906\ndtype: float64\n```\n\n#### Sharpe ratio (夏普比率)\n\n[https://youtu.be/5cqstpRndtI](https://youtu.be/5cqstpRndtI)\n\n{% blockquote 夏普比率 http://wiki.mbalib.com/wiki/%E5%A4%8F%E6%99%AE%E6%AF%94%E7%8E%87 %}\n\n　　现代投资理论的研究表明,风险的大小在决定组合的表现上具有基础性的作用。风险调整后的收益率就是一个可以同时对收益与风险加以考虑的综合指标,以期能够排除风险因素对绩效评估的不利影响。夏普比率就是一个可以同时对收益与风险加以综合考虑的三大经典指标之一。\n\n　　投资中有一个常规的特点，即投资标的的预期报酬越高，投资人所能忍受的波动风险越高；反之，预期报酬越低，波动风险也越低。所以理性的投资人选择投资标的与投资组合的主要目的为：在固定所能承受的风险下，追求最大的报酬；或在固定的预期报酬下，追求最低的风险。\n\n　　夏普比率计算公式：＝[E(Rp)－Rf]/σp\n\n　　其中E(Rp)：投资组合预期报酬率\n\n　　Rf：无风险利率\n\n　　σp：投资组合的标准差\n\n　　目的是计算投资组合每承受一单位总风险，会产生多少的超额报酬。比率依据资本市场线(Capital Market Line,CML)的观念而来，是市场上最常见的衡量比率。当投资组合内的资产皆为风险性资产时，适用夏普比率。夏普指数代表投资人每多承担一分风险，可以拿到几分报酬；若为正值，代表基金报酬率高过波动风险；若为负值，代表基金操作风险大过于报酬率。这样一来，每个投资组合都可以计算Sharpe Ratio,即投资回报与多冒风险的比例，这个比例越高，投资组合越佳。\n\n　　举例而言，假如国债的回报是3%，而您的投资组合预期回报是15%，您的投资组合的标准偏差是6%，那么用15%－3%,可以得出12%（代表您超出无风险投资的回报），再用12%÷6%＝2，代表投资者风险每增长1%，换来的是2%的多余收益。\n\n{% endblockquote %}\n\n##### 以下计算夏普比率的公式使用：\n\n`日收益 减去 日化无风险收益率 的均值 / 日收益 减去 日化无风险收益率 的标准差`\n\n`S = mean(daily_rets - daily_rf) / std(daily_rets - daily_rf)`\n\n什么是日化无风险收益率？视频中采用了 *伦敦银行同业拆放利率、3月期国债利率、0%*。\n\n如何计算日化收益率？假设年收益为10%，每年有252个交易日。那么日收益率：\n\ndaily_rf = $\\sqrt[252]{1.0+0.1}-1$\n\n将 daily_rf 视为一个常数时（和将常数视作0的效果一样），可以将计算公式改为：\n\n`S = mean(daily_rets - daily_rf) / std(daily_rets)`\n\n> 夏普比率对于相同资产可以有相当大的变化。**取决于采样的频繁度**\n>\n> 如果每年采样股票价格，并且基于年化统计量计算，会得到一个数字；如果每月采样，会得到不同的数字；如果改成每日采样，又会得到另一个数字。\n>\n> **最初版本的夏普比率是一个年化的测量值。所以如果需要以非年化的采样来计算，那么需要加上一个调整因子来使其正常工作。**\n>\n> `SRannualized = K * SR`\n>\n> 调整因子（K）是每年的采样数量值的平方根。\n>\n> 假设使用的是每日采样，一年共有252个交易日。daily K = $\\sqrt{252}$\n>\n> 假设使用的是每周采样，一年共有52个交易周。daily K = $\\sqrt{52}$\n>\n> 假设使用的是每月采样，一年共有12个交易月。daily K = $\\sqrt{12}$\n>\n> **即便某支股票一年只交易了80天，在以每日采样计算调整因子时，还是应该是用252来进行计算**\n\n#### What is an optimizer（优化器）\n\n* 用来寻找函数最小值\n* 从数据中查找并建立参数化模型（从实验数据中找到一个多项式来拟合实验数据）\n* 使用优化器来改善股票投资组合中的分配方式\n\n```python\nimport scipy.optimize as spo\n\ndef f(X):\n    Y = (X - 1.5) ** 2 + 0.5\n    print(\"X={0},Y={1}\".format(X, Y))\n    return Y\n\nXguess = 2.0\nmin_result = spo.minimize(f, Xguess, method='SLSQP', options={'disp': True})\nprint('Minima found at:')\nprint(\"X={0},Y={1}\".format(min_result.x, min_result.fun))\n```\n\n```\nX=[ 2.],Y=[ 0.75]\nX=[ 2.],Y=[ 0.75]\nX=[ 2.00000001],Y=[ 0.75000001]\nX=[ 0.99999999],Y=[ 0.75000001]\nX=[ 1.5],Y=[ 0.5]\nX=[ 1.5],Y=[ 0.5]\nX=[ 1.50000001],Y=[ 0.5]\nOptimization terminated successfully.    (Exit mode 0)\n            Current function value: 0.5\n            Iterations: 2\n            Function evaluations: 7\n            Gradient evaluations: 2\nMinima found at:\nX=[ 1.5],Y=0.5\n```\n\n```python\nXplot = np.linspace(0.5, 2.5, 21)\nYplot = f(Xplot)\nplt.plot(Xplot, Yplot)\nplt.plot(min_result.x, min_result.fun, 'ro')\nplt.title('Minima of an objective function')\nplt.show()\n```\n\n![1532659982849](1532660052844.png)\n\n#### Convex Problems (凸问题)\n\n**凸集必定有局部最小值，同时这个局部最小值也就是全局最小值。**\n\n#### 构建参数化模型\n\n什么是参数化模型？`f(x) = mx+b`这是个关于 x 的函数，它有两个参数 m 和 b。\n\n优化器就是通过不断的修改参数值并迭代函数，来找到函数的最优解。\n\n```python\ndef get_portfoilo(symbols, start, end, allocs, start_values):\n    \"\"\"获取投资组合与沪深300指数的收益比较\n\n    :param symbols: 投资组合\n    :param start: 开始日期\n    :param end: 结束日期\n    :param allocs: 投资组合比率\n    :param start_values: 初始总投资额\n    :return:\n    \"\"\"\n    df = get_datas(symbols, start, end)\n    normed = normalization(df)\n    alloced = normed.copy().drop('000300', axis=1) * allocs\n    pos_vals = alloced * start_values\n    port_val = pos_vals.sum(axis=1)\n    return normalization(pd.DataFrame(port_val.copy(),\n                                      columns=['Portfoilo']).join(df['000300']))\n\n# 投资组合一年的表现与沪深300指数的比较\nportpoilo = get_portfoilo(SYMBOLS, START, END, ALLOCS, START_VALS)\nportpoilo.show()\nplt.grid()\nplt.show()\n```\n\n![1532677809156](1532677939302.png)\n\n```python\n# 修改投资比率\nportpoilo = get_portfoilo(SYMBOLS, START, END, [0.5, 0, 0, 0.5], START_VALS)\nportpoilo.plot()\nplt.grid()\nplt.show()\n```\n\n![1532678552063](1532678552063.png)\n\n优化器的作用就在于确定如何找到最优的投资比率和股票组合。\n\n\n### Types of funds（基金类型）\n\n* ETF [交易所交易基金、交易所买卖基金](https://zh.wikipedia.org/wiki/ETF)\n* Mutual Fund [共同基金](https://zh.wikipedia.org/wiki/%E5%85%B1%E5%90%8C%E5%9F%BA%E9%87%91)\n* Hedge Fund [对冲基金](https://zh.wikipedia.org/wiki/%E5%AF%B9%E5%86%B2%E5%9F%BA%E9%87%91)\n\n| **Parameter**                     | **Hedge Fund**                            | **Mutual Fund**                                  | **ETF**                                           |\n| --------------------------------- | ----------------------------------------- | ------------------------------------------------ | ------------------------------------------------- |\n| **Return**                        | *Absolute return*                         | *Relative return*                                | *Relative return*                                 |\n| **Management**                    | *Actively managed*                        | *Comparatively less actively managed*            | *Passively managed*                               |\n| **Fees**                          | *Performance based fee*                   | *Percentage of assets managed fees*              | *–*                                               |\n| **Transaction Price**             | *–*                                       | *NAV*                                            | *Quoted price*                                    |\n| **Transparency**                  | *Information disclosed to investors only* | *Annually published reports and disclosure*      | *Daily disclosure of holdings*                    |\n| **Regulation**                    | *Less regulation*                         | *Regulated by SEBI*                              | *Regulated by Securities and Exchange Commission* |\n| **Liquidity**                     | *Low*                                     | *High*                                           | *High*                                            |\n| **Cost**                          | *–*                                       | *High average expense ratio*                     | *Low average expense ratio*                       |\n| **Investor Type**                 | *High net worth individuals*              | *Retail investors*                               | *Retail investors*                                |\n| **Fractional Shares**             | *No*                                      | *Yes*                                            | *No*                                              |\n| **Ownership of Fund Manager**     | *Substantial ownership*                   | *Non substantial ownership*                      | *–*                                               |\n| **Owners**                        | *Few owners*                              | *Many owners*                                    | *–*                                               |\n| **Minimum amount to be invested** | *High*                                    | *Low*                                            | *Low*                                             |\n| **Tax**                           | *–*                                       | *High percentage of tax levied on capital gains* | *Comparatively lower tax percentages are levied*  |\n\n\n### 如何计算估值\n\n{% blockquote 金钱的时间价值 https://zh.wikipedia.org/wiki/%E9%87%91%E9%8C%A2%E7%9A%84%E6%99%82%E9%96%93%E5%83%B9%E5%80%BC %}\n\n金钱的未来终值（future value）应大于现值（present value）\n\n{% endblockquote %}\n\n**计算:**\n\n假设某人以利率 $i$ （$i=5\\%$与$i=0.05$等同）借出或借入一笔款项，期限为 $t$ 年，则 $t$ 年后的 $C$ 个货币单位现值表达为：$C_{t}=\\frac{C}{(1+i)^{t}}$\n\n$t$ 年后的 $C$ 个莫比单位现时购买力也可以用上式计算，此时 $i$ 表示 *通货膨胀率*。\n\n同一组现金流可能根据利率的不同被分为数个时段，例如，从此时算起的第一年内的利率为 $i_1$ ，第二年的利率为 $i_2$ ，那么两年后的 $C$ 个货币单位的现值表达式为：$PV=\\frac{C}{(1+i_1)(1+i_2)}$\n\n* **内在价值**\n* **账面价值**：$总资产-无形资产-负债$\n* **市值**\n\n\n### 资本资产定价模型 （CAPM）\n\n{% blockquote 资本资产定价模型 https://zh.wikipedia.org/wiki/%E8%B5%84%E6%9C%AC%E8%B5%84%E4%BA%A7%E5%AE%9A%E4%BB%B7%E6%A8%A1%E5%9E%8B %}\n\n资本资产定价模型（英语：Capital Asset Pricing Model, CAPM）是由美国学者威廉·夏普（William Sharpe）、林特尔（John Lintner）、特里诺（Jack Treynor）和莫辛（Jan Mossin）等人在现代投资组合理论的基础上发展起来的，是现代金融市场价格理论的支柱，广泛应用于投资决策和公司理财领域。资本资产定价模型中，所谓资本资产主要指的是股票资产，而定价则试图解释资本市场如何决定股票收益率，进而决定股票价格。\n\n根据资本资产定价模型，对于一个给定的资产 $i$，它的期望收益率和市场投资组合的期望收益率之间的关系可以表示为：\n\n$E(r_i)=r_f+\\beta_im[E(r_m)-r_f]]$\n\n其中：\n\n* $E(r_i)$是资产 $i$ 的期望收益率（或普通股的资本成本率）\n* $r_f$ 是无风险收益率，通常以短期国债的利率来近似替代\n* $\\beta_{im}$ 是资产 $i$ 的系统性风险系数，$\\beta_{im}={\\frac{Cov(r_i,r_m)}{Var(r_m)}}$ \n* $E(r_{m})$市场投资组合 $m$ 的期望收益率，通常用股票价格指数收益率的平均值或所有股票的平均收益率来代替\n* $E(r_{m})-r_{f}$市场风险溢价（英语：Market Risk Premium），即市场投资组合的期望收益率与无风险收益率之差\n\nCAPM模型是建立在一系列假设的基础上的，其中主要包括：\n\n* 所有投资者均追求单期财富的期望效用最大化，并以各备选组合的期望收益和标准差为基础进行组合选择。\n* 所有投资者均可以无风险利率无限制地借入或贷出资金。\n* 所有投资者拥有同样预期，即对所有资产收益的均值、方差和协方差等，投资者均有完全相同的主观估计。\n* 所有资产均可被完全细分，拥有充分的流动性且没有交易成本。\n\n没有税金。\n\n* 所有投资者均为价格接受者。即任何一个投资者的买卖行为都不会对股票价格产生影响。\n* 所有资产的数量是给定的和固定不变的。\n\n近年的实证研究表明，CAPM模型在实际中并不能验证历史的投资收益，由此Roll在1977年提出了两种可能：一种是CAPM模型在市场上是无效的，一种是CAPM理论存在模型的设定误差；基于后一种可能，APT理论和不少多因子模型不断诞生——例如FAMA-FRENCH的三因子模型。但是由于CAPM的简单和便于理解，在业界运用非常广泛，特别是在估值分析中确定必要报酬率（英语：Required Return of Equity）。\n\n{% endblockquote %}\n\n![1533869822902](1533869822902.png)\n\n### 套利定价理论（APT）\n\n[https://youtu.be/yMMoukwU87I](https://youtu.be/yMMoukwU87I)\n\n[套利定价理论-MBAlib](http://wiki.mbalib.com/wiki/%E5%A5%97%E5%88%A9%E5%AE%9A%E4%BB%B7%E7%90%86%E8%AE%BA)\n\n### 技术分析\n\n#### 技术分析的特征\n\n* 只关注历史价格和成交量\n* 在时间序列中计算统计数据称为指标\n* 指标是启发式的\n\n#### 使技术分析有价值的因素 \n\n* 个别指标具有弱预测性，但结合多个指标可以增加价值\n* 寻找对比（单个股票 VS 市场）（找到比市场收益更好的单个或组合）\n* 在短时间内比在较长时间内工作得更有效\n\n> 持有时间越长，价值分析越重要，需要作出判断的时间越长，判断复杂度越高。（更适合人类进行分析）\n>\n> 反之，持有时间越短，技术分析越重要，需要作出判断的时间越短，判断复杂度越低。（更适合计算机做高频分析）\n\n![1533883675299](1533883675299.png)\n\n#### 部分技术分析的指标\n\n* 动量（momentum）\n\n  {% blockquote 运动量震荡指标 https://zh.wikipedia.org/wiki/%E9%81%8B%E5%8B%95%E9%87%8F%E9%9C%87%E7%9B%AA%E6%8C%87%E6%A8%99 %}\n\n  $MO_t=(P_t/P_{t-n})*100$\n  其中 $n$ 為天數，$P_t$ 為當日股價，$P_{t-n} $ 為  $n$ 日前的股價\n\n  1. MO>100时，表示目前股价行情较N日前偏多看待，相对该股票市场行情反应较为热络。\n  2. MO<100时，表示目前股价行情较N日前偏空看待，相对该股票行情市场反应较为冷淡。\n  3. MO由正转负，表示目前股价行情已转为偏空看待，多方投资人需要注意。\n  4. MO由负转正，表示目前股价行情已转为偏多看待，空方投资人需要注意。\n\n  {% endblockquote %}\n\n* 移动平均线（SMA）\n\n  >1. 寻找价格穿过简单移动平均线的点。\n  >\n  >   momentum+SMA cross可能会是买入或卖出的指标。\n  >\n  >2. 可以将移动平均线看成是一个时间段上的公司价值。股价会在移动平均线上下波动。\n\n  ![1533886709495](1533886709495.png)\n\n  {% blockquote 移动平均 https://zh.wikipedia.org/wiki/%E7%A7%BB%E5%8B%95%E5%B9%B3%E5%9D%87 %}\n\n  * **简单移动平均**（英语：simple moving average，SMA）是某变数之前 $n$ 个数值的未作加权算术平均。例如，收市价的10日简单移动平均指之前10日收市价的平均数。若设收市价为 $p_{1}$至 $p_{n}$，则方程式为：\n\n    $SMA={p_{1}+p_{2}+\\cdots +p_{n} \\over n}$\n    当计算连续的数值，一个新的数值加入，同时一个旧数值剔出，所以无需每次都重新逐个数值加起来：\n\n    $SMA_{t1,n}=SMA_{t0,n}-{p_{1} \\over n}+{p_{n+1} \\over n}$\n    在技术分析中，不同的市场对常用天数（$n$值）有不同的需求，例如：某些市场普遍的$n$值为10日、40日、200日；有些则是5日、10日、20日、60日、120日、240日，视乎分析时期长短而定。投资者冀从移动平均线的图表中分辨出支持位或阻力位。\n\n  * **指数移动平均**（英语：exponential moving average，EMA或EWMA）是以指数式递减加权的移动平均。各数值的加权影响力随时间而指数式递减，越近期的数据加权影响力越重，但较旧的数据也给予一定的加权值。右图是一例子。\n\n    加权的程度以常数 $α$ 决定，$α$ 数值介乎0至1。$α$ 也可用天数 $N$ 来代表： $\\alpha ={2 \\over {N+1}}$，所以，$N$=19天，代表$α=0.1$。\n\n    设时间 $t$ 的实际数值为$Y_t$，而时间 $t$ 的EMA则为$S_t$；时间 $t-1$ 的EMA则为$S_{t-1}$，计算时间 $t≥2$ 是方程式为：\n\n    $S_{t}=\\alpha * Y_{t}+(1-\\alpha )* S_{t-1}$\n    设今日（$t1$）价格为 $p$，则今日（$t1$）EMA的方程式为：\n\n    $EMA_{t1}={\\text{EMA}}_{t0}+\\alpha \\times (p-{\\text{EMA}}_{t0})$\n    将 ${\\text{EMA}}_{t0}$分拆开来如下：\n\n    ${\\text{EMA}}={p_{1}+(1-\\alpha )p_{2}+(1-\\alpha )^{2}p_{3}+(1-\\alpha )^{3}p_{4}+\\cdots \\over 1+(1-\\alpha )+(1-\\alpha )^{2}+(1-\\alpha )^{3}+\\cdots }$\n    理论上这是一个无穷级数，但由于 $1-α$ 少于1，各项的数值会越来越细，可以被忽略。分母方面，若有足够多项，则其数值趋向 $1/α$。即，\n\n    ${\\text{EMA}}=\\alpha \\times \\left(p_{1}+(1-\\alpha )p_{2}+(1-\\alpha )^{2}p_{3}+(1-\\alpha )^{3}p_{4}+\\cdots \\right)$\n    假设 $k$ 项及以后的项被忽略，即 $\\alpha \\times \\left((1-\\alpha )^{k}+(1-\\alpha )^{k+1}+\\cdots \\right)$，重写后可得$\\alpha \\times (1-\\alpha )^{k}\\times \\left(1+(1-\\alpha )+(1-\\alpha )^{2}\\cdots \\right)$，相当于 $(1-\\alpha )^{k}$。所以，若要包含99.9%的加权，解方程 $k={\\log(0.001) \\over \\log(1-\\alpha )}$即可得出$k$。由于当$N$不断增加， $\\log \\,(1-\\alpha )$将趋向 $-2 \\over N+1$，简化后k大约等于 $3.45\\times (N+1)$。\n\n  * **加权移动平均**（英语：weighted moving average，WMA）指计算平均值时将个别数据乘以不同数值，在技术分析中，$n$日WMA的最近期一个数值乘以$n$、次近的乘以$n-1$，如此类推，一直到0：\n\n    $WMA_{M}={np_{M}+(n-1)p_{M-1}+\\cdots +2p_{M-n+2}+p_{M-n+1} \\over n+(n-1)+\\cdots +2+1}$\n\n    由于 $WMA_{M+1}$与 $WMA_{M}$的分子相差 $np_{M+1}-p_{M}-\\cdots -p_{M-n+1}$，假设 $p_{M}+p_{M-1}+\\cdots +p_{M-n+1}$为总和$M$：\n\n    $总和_{M+1} =总和_{M}+p_{M+1}-p_{M-n+1}$\n    $分子_{M+1}=N_{M+1}=分子_M+np_{M+1}-总和_M$\n    $WMA_{M+1}={N_{M+1} \\over n+(n-1)+\\cdots +2+1}$\n    留意分母为三角形数，方程式为 $n(n+1) \\over 2$\n\n    右图显示出加权是随日子远离而递减，直至递减至零。\n\n  {% endblockquote %}\n\n* [布林带](https://zh.wikipedia.org/wiki/%E5%B8%83%E6%9E%97%E5%B8%A6) \n\n  {% blockquote 移动平均 https://zh.wikipedia.org/wiki/%E7%A7%BB%E5%8B%95%E5%B9%B3%E5%9D%87 %}\n\n  “布林带”是这样定义的：\n\n  中轨 = $N$ 时间段的简单移动平均线\n  上轨 = 中轨 + $K × N$时间段的标准差\n  下轨 = 中轨 − $K × N$时间段的标准差\n  一般情况下，设定N=20和K=2，这两个数值也是在布林带当中使用最多的。在日线图里，N=20其实就是“月均线”（MA20）。依照正态分布规则，约有95%的数值会分布在距离平均值有正负2个标准差（ $\\pm 2\\sigma$ ）的范围内。\n\n  {% endblockquote %}\n\n  ![1533890419564](1533890419564.png)\n\n> **单纯使用穿越布林带上轨和下轨来作为买入卖出依据虽然看上去很美，但是个人认为并不能作为唯一条件。**\n>\n> 以 2017-01-01 ~ 2017-12-31 日之间的 600016 交易数据判断。\n>\n> *模拟操作为 一次购买机会买入100股，每遇到一次卖出机会卖出持有的所有股份。*\n>\n> 在模拟日期间共出现 7 次购买机会，前六次购买后卖出时亏损了360元。\n>\n> ```\n>             Close_Adj   mean_20         top   ...    Rate      C     Sum\n> Date                                          ...                       \n> 2017-02-20     157.27  157.5570  159.230044   ...    0.53 -100.0  -914.0\n> 2017-03-06     154.61  156.3465  158.153251   ...    0.20 -100.0  -896.0\n> 2017-03-13     153.14  155.4830  158.303460   ...    0.15 -100.0  -886.0\n> 2017-03-23     149.15  153.3205  157.689392   ...    0.34 -100.0  -859.0\n> 2017-04-17     143.84  147.8400  152.270060   ...    0.51 -100.0  -823.0\n> 2017-04-21     138.97  145.6275  152.778017   ...    0.31 -100.0  -790.0\n> 2017-05-26     140.60  138.2060  141.390432   ...    0.71  600.0  4806.0\n> 2017-06-29     144.14  141.6690  144.347758   ...    0.26    NaN     NaN\n> 2017-07-18     151.00  144.9020  151.131555   ...    0.65    NaN     NaN\n> 2017-07-20     151.88  145.9120  153.310778   ...    0.45    NaN     NaN\n> 2017-08-15     146.28  150.4675  155.338483   ...    0.32 -100.0  -823.0\n> 2017-11-01     148.20  146.5935  148.700933   ...    0.27  100.0   824.0\n> 2017-11-09     150.11  147.4940  150.556908   ...    0.29    NaN     NaN\n> 2017-11-27     161.03  152.3635  161.544288   ...    0.76    NaN     NaN\n> \n> [14 rows x 16 columns]\n> 600016 : -361.0/0\n> ```\n>\n> 从图中可以看出 2017-02-17，2017-03-03 分别给出了从 布林带下方穿越布林带的信号，但是结果却非常不理想。\n>\n> ![image-20180811213410404](image-20180811213410404.png)\n>\n> 对于上证50指数的所有股票进行 2017-01-01 ~ 2017-12-31 期间的数据模拟，效果依然不是很理想。去年盈利10000+，但是截至 2017-12-31 却持有价值 80000+ 的股票。\n>\n> **应该参考之前的 “投资组合” 选出合适的能够跑赢指数均值的组合 和其他分析指标共同分析。**\n>\n> 代码：https://github.com/GuQiangJS/studySource/blob/master/codes/python/machine-learning-for-trading/tests/test_plot_bbands.py\n\n### 数据分析\n\n#### Survior bias\n\nhttps://youtu.be/RCB2hkiwqnA\n\n>  使用同样的时间间隔分析同一成分股集合时，选取成分股集合的时间点会造成不同的结果。采用分析时间结束时的成分股集合时会得到更加漂亮、诱人、但不真实的结果。**应该选取分析时间开始时的集合**。\n\n![1534238787357](1534238787357.png)\n\n#### 效率市场假说\n\n{% blockquote 效率市场假说 https://zh.wikipedia.org/wiki/%E6%95%88%E7%8E%87%E5%B8%82%E5%A0%B4%E5%81%87%E8%AA%AA %}\n\n* 弱式效率（Weak Form Efficiency）\n\n  目前股票价格已充分反映了过去股票价格所提供的各项情报。所以，投资人无法再运用各种方法对过去股票价格进行分析，再利用分析结果来预测未来股票价格，基于随机游走假说，未来消息是随机而来的。意即投资者无法再利用过去资讯来获得高额报酬。所以，弱势效率越高，若以过去价量为基础的技术分析来进行预测效果将会十分不准确。\n\n  > 留下了可以从事基本面分析的口子。\n\n* 半强式效率（Semi-Strong Form Efficiency）\n\n  目前股票价格已充分反应了所有公开资讯，所以，投资者无法利用情报分析结果来进行股票价格预测而获取高额报酬。因此，半强式效率越高，依赖公开的财务报表、经济情况及政治情势来进行基本面分析，然后再预测股票价格是徒劳无功。\n\n  > 连基本面分析都不行了。只能通过内幕交易了。\n\n* 强式效率（Strong Form Efficiency）\n\n  目前股票价格充分反应了所有已公开和未公开之所有情报。虽然情报未公开，但投资者能利用各种管道来获得资讯，所以，所谓未公开的消息，实际上是已公开的资讯且已反应于股票价格上。此种情形下，投资者也无法因拥有某些股票内幕消息而获取高额报酬。 \n\n  > 连内部交易都没机会了。\n\n{% endblockquote %}\n\n#### Grinold's fundamental law\n\nhttps://youtu.be/W6yUgs1OLx0\n\n$performance=Skill \\times \\sqrt{breadth}$\n\n#### 通过协方差构建投资组合（获得相同回报，但降低波动性）\n\n[现代投资组合理论](https://zh.wikipedia.org/wiki/%E7%8E%B0%E4%BB%A3%E6%8A%95%E8%B5%84%E7%BB%84%E5%90%88%E7%90%86%E8%AE%BA)\n\n### 机器学习\n\n#### 监督回归学习\n\n* 线性回归（参数式）\n* [最近邻居法](https://zh.wikipedia.org/wiki/%E6%9C%80%E8%BF%91%E9%84%B0%E5%B1%85%E6%B3%95)（实例式）\n* 决策树\n* 决策森林\n\n#### Price forecasting demo\n\nhttps://youtu.be/GVOEnkjmBZU\n\n![1535439244770](1535439244770.png)\n\n#### 强化学习\n\n### 过拟合\n\n#### 集成学习 ([Ensemble learning](https://en.wikipedia.org/wiki/Ensemble_learning))\n\n![1536045019373](1536045019373.png)\n\n#### Bagging算法([Bootstrap aggregating](https://zh.wikipedia.org/wiki/Bagging%E7%AE%97%E6%B3%95))\n\n#### [AdaBoost](https://zh.wikipedia.org/wiki/AdaBoost)\n\nhttps://www.youtube.com/watch?v=GM3CDQfQ4sw&list=PLAwxTw4SYaPnIRwl6rad_mYwEk4Gmj7Mx&index=194\n\n\n\n### 数据特征缩放\n\n**标准化：** $normed={values-mean \\over values.std()}$\n\n标准化后，数据均值为0，数值将在 -1 和 1 之间变化。\n\n{% blockquote 重新缩放 https://zh.wikipedia.org/wiki/%E7%89%B9%E5%BE%B5%E7%B8%AE%E6%94%BE %}\n\n最简单的方式是重新缩放特征的范围到[0, 1]或[-1, 1]， 依据原始的资料选择目标范围，通式如下：$ x'={x-min(x) \\over max(x)-min(x)}$\n\n$x$ 是原始的值，$x'$ 是被标准化后的值。例如，假设我们有学生的体重资料，范围落在[160磅, 200磅]，为了重新缩放这个资料，我们会先将每个学生的体重减掉160，接着除与40(最大体重与最小体重的差值) \n\n{% endblockquote %}","source":"_posts/machine-learning-for-trading.md","raw":"---\ntitle: Machine Learning for Trading\ndate: 2018-07-11 17:07:13\nupdated: 2018-09-03\ntags:\n - 编程\n - Python\n - 金融\n - 股票\ncategories:\n - 编程\n - Python\n - 金融\n - 股票\ntypora-root-url: machine-learning-for-trading\nmathjax: true\ndescription: <!—more—->\n---\n\n教程Youtube链接:[https://www.youtube.com/playlist?list=PLAwxTw4SYaPnIRwl6rad_mYwEk4Gmj7Mx](https://www.youtube.com/playlist?list=PLAwxTw4SYaPnIRwl6rad_mYwEk4Gmj7Mx)\n\n### 单一股票收益\n\n#### The Data (介绍CSV文件)\n\n#### Our Stock Data (介绍股票每日成交汇总数据格式)\n\n* Date\n* Open\n* High\n* Low\n* Close\n* Volume -> 成交量\n* Adj Close -> 调整收盘价（除权除息价）\n\n#### Pandas Dataframe\n\n#### Actual CSV\n\n#### Interesting Stuff\n\n切片：取 `Dataframe` 中的部分数据\n\n[pandas.DataFrame.loc](http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.loc.html#pandas.DataFrame.loc)\n\n#### Compute max closing price\n\n[pandas.Series.max](http://pandas.pydata.org/pandas-docs/stable/generated/pandas.Series.max.html#pandas-series-max)\n\n#### Plotting stock price data (绘图)\n\n#### Plot two columns (绘制多个数据)\n\n```python\nimport matplotlib.pyplot as plt\nimport pandas as pd\nfrom finance_datareader_py.eastmoney.daily import EastMoneyDailyReader\n\ndf1 = EastMoneyDailyReader('601398').read()\ndf2 = EastMoneyDailyReader('601398', type='ba').read()\ndf = pd.DataFrame()\ndf['Close'] = pd.to_numeric(df1['Close'])\ndf['Adj Close'] = pd.to_numeric(df2['Close'])\nprint(df.tail())\ndf.plot()\nplt.show()\n```\n\n![1531304006175](1531304006175.png)\n\n#### Pandas dataframe recap\n\n#### Problems to Solve\n\n##### Data ranges(使用日期索引取值)\n\n```\nfrom finance_datareader_py.eastmoney.daily import EastMoneyDailyReader\ndf = EastMoneyDailyReader('601398').read()\ndf.tail()\nOut[4]: \n            Open Close  High   Low   交易量(手)   成交金额     振幅   换手率\n日期                                                             \n2018-07-05  5.17  5.23  5.29  5.16  1865183  9.72亿  2.52%  0.07\n2018-07-06  5.23  5.29  5.34  5.18  1925444  10.1亿  3.06%  0.07\n2018-07-09  5.31  5.53  5.54  5.31  2155458  11.7亿  4.35%  0.08\n2018-07-10  5.56  5.52  5.57  5.46  1289900  7.10亿  1.99%  0.05\n2018-07-11  5.41  5.48  5.52  5.39  1520449  8.31亿  2.36%  0.06\n\ndf['2017-01-01':'2017-12-31'].tail()\nOut[6]: \n            Open Close  High   Low   交易量(手)   成交金额     振幅   换手率\n日期                                                             \n2017-12-25  5.93  6.00  6.03  5.93  2396364  14.4亿  1.69%  0.09\n2017-12-26  6.00  6.08  6.10  5.98  2165329  13.1亿     2%  0.08\n2017-12-27  6.09  6.05  6.15  6.02  2151401  13.1亿  2.14%  0.08\n2017-12-28  6.03  6.14  6.14  6.02  2100886  12.8亿  1.98%  0.08\n2017-12-29  6.13  6.20  6.22  6.12  2168998  13.4亿  1.63%  0.08\n```\n\n取沪深300指数（399300）+单个股票数据。\n\n取沪深300指数的意义在于，只要开市，那么指数就肯定有数据，而不像其他单一股票可能会出现不定期停牌的情况。\n\n看下面的数据：\n\n1. 2005年，300027还没有上市，所以数值为 `NaN`。\n2. 2018-07-07、2018-07-08两天是休息日，不开市。这时不会有数据。\n\n```\nimport pandas as pd\nfrom finance_datareader_py.eastmoney.daily import EastMoneyDailyReader\ndf1 = EastMoneyDailyReader('399300').read()\ndf2 = EastMoneyDailyReader('300027').read()\ndf = pd.DataFrame()\ndf['399300'] = df1['Close']\ndf['300027'] = df2['Close']\n\ndf.head()\nOut[4]: \n            399300 300027\n日期                       \n2005-01-04  982.79    NaN\n2005-01-05  992.56    NaN\n2005-01-06  983.17    NaN\n2005-01-07  983.96    NaN\n2005-01-10  993.88    NaN\n\ndf.tail()\nOut[3]: \n             399300 300027\n日期                        \n2018-07-05  3342.44   6.08\n2018-07-06  3365.12   6.09\n2018-07-09  3459.18   6.12\n2018-07-10  3467.52   6.03\n2018-07-11  3407.53   5.96\n```\n\n#### Create an exmpty data frame\n\n#### Join SPY data (使用Join关联数据，使用dropna丢弃空数据)\n\n```\nimport pandas as pd\nfrom finance_datareader_py.eastmoney.daily import EastMoneyDailyReader\ndf1 = EastMoneyDailyReader('399300').read()\ndates = pd.date_range('2010-01-01', '2010-01-05')\n# 创建空白DataFrame\ndf = pd.DataFrame(index=dates)\ndf = df.join(df1)\n\ndf['Close'].head()\nOut[3]: \n2010-01-01        NaN\n2010-01-02        NaN\n2010-01-03        NaN\n2010-01-04    3535.23\n2010-01-05    3564.04\nFreq: D, Name: Close, dtype: object\n\ndf['Close'].head().dropna()\nOut[4]: \n2010-01-04    3535.23\n2010-01-05    3564.04\nFreq: D, Name: Close, dtype: object\n```\n\n#### Read in more stocks(重命名，一个dataframe中不能出现同名的列)\n\n#### Slicing (数据切片)\n\n```python\nimport pandas as pd\nfrom finance_datareader_py.eastmoney.daily import EastMoneyDailyReader\n\nsymbols = ['399300', '300027', '601398']\n\ndates = pd.date_range('2010-01-01', '2010-01-05')\n# 创建空白DataFrame\ndf = pd.DataFrame(index=dates)\nfor symbol in symbols:\n    df_temp = EastMoneyDailyReader(symbol).read()\n    df_temp = df_temp.rename(columns={'Close': symbol})\n    df = df.join(df_temp[symbol])\n\nprint(df)\nprint('------------------------')\nprint(df.dropna())\nprint('------------------------')\nprint(df.loc['2010-01-04':'2010-01-04',['000002', '601398']])\n```\n\n```\n             399300 300027 601398\n2010-01-01      NaN    NaN    NaN\n2010-01-02      NaN    NaN    NaN\n2010-01-03      NaN    NaN    NaN\n2010-01-04  3535.23  55.53   5.35\n2010-01-05  3564.04  55.09   5.40\n------------------------\n             399300 300027 601398\n2010-01-04  3535.23  55.53   5.35\n2010-01-05  3564.04  55.09   5.40\n------------------------\n             399300 300027\n2010-01-04  3535.23  55.53\n\n```\n\n#### Problems with Plotting (判断时股价起点不同，很难在同一层面观察)\n\n```python\nimport matplotlib.pyplot as plt\nimport pandas as pd\nfrom finance_datareader_py.eastmoney.daily import EastMoneyDailyReader\n\nsymbols = ['600519', '000002', '601398']\n\n# 创建空白DataFrame\ndf = pd.DataFrame()\nfor symbol in symbols:\n    df_temp = EastMoneyDailyReader(symbol).read()\n    df[symbol] = df_temp['Close']\n\ndf = df.dropna()\ndf.loc['2017-01-01':'2017-12-31'].plot()\nplt.show()\n```\n\n![1531383436936](1531383436936.png)\n\n#### Normalizing (数据归一化)\n\n```\ndef normalize_data(df):\n    return df / df.iloc[0]\n\nnormalize_data(df.loc['2017-01-01':'2017-12-31']).plot()\n```\n\n让Dataframe的每一行数据除以第一行的值，从而使所有数据从1开始。\n\n![1531384011994](1531384011994.png)\n\n#### What is NumPy\n\n#### Relationship to Pandas (numpy与Pandas的关系)\n\n#### Compute global statistics\n\n[标准差](https://zh.wikipedia.org/wiki/%E6%A8%99%E6%BA%96%E5%B7%AE)\n\n> 例如，两组数的集合{0, 5, 9, 14}和{5, 6, 8, 9}其平均值都是7，但第二个集合具有较小的标准差。 \n\n#### Rolling statistics\n\n#### Bollinger Bands\n\n[布林带](https://zh.wikipedia.org/wiki/%E5%B8%83%E6%9E%97%E5%B8%A6)\n\n```python\ndf = pd.DataFrame()\ndf['Close'] = EastMoneyDailyReader('601398').read()['Close']\ndf['rol_30'] = pd.rolling_mean(df['Close'], window=30)\ndf.head(100).plot()\nplt.show()\n```\n\n![1531465284221](1531465284221.png)\n\n#### Daily returns (日收益)\n\n日收益基本上是围绕0上下浮动。\n\n`daily_ret[t]=(price[t]/price[t-1])-1`\n\n`(110/100)-1=1.1-1=0.1=10%`\n\n#### Cumulative returns (累计收益)\n\n累积收益和数据归一化在计算中的意思基本一致。\n\n#### A closer look at daily returns\n\n使用直方图展示日收益率的分布情况\n\n[峰度](https://zh.wikipedia.org/wiki/%E5%B3%B0%E5%BA%A6)\n\n> 峰度高就意味着方差增大是由低频度的大于或小于平均值的极端差值引起的。 \n\n[肥尾分布](https://zh.wikipedia.org/wiki/%E8%82%A5%E5%B0%BE%E5%88%86%E5%B8%83)\n\n#### Computing rolling statistics\n\n20日移动平均线\n\n```python\ndf = EastMoneyDailyReader('601398').read().tail(200)\nax = df['Close'].plot(title='601398 rolling mean')\nrm = pd.rolling_mean(df['Close'], window=20)\nrm.plot(label='Rolling mean', ax=ax)\n\nax.set_xlabel('Date')\nax.set_ylabel('Price')\nax.legend(loc='upper left')\nplt.show()\n```\n\n![1531632440578](1531632440578.png)\n\n#### Using fillna() (数据市场是不完整的，需要补齐)\n\n#### Histogram of daily returns (使用直方图来查看每日收益)\n\n#### How to plot a histogram (如何绘制直方图)\n\n```python\ndef compute_daily_returns(df):\n    return df[:-1].values / df[1:] - 1\n\n\ndf = EastMoneyDailyReader('601398').read()\ndaily_returns = compute_daily_returns(df['Close'])\ndaily_returns.hist(bins=50)\nprint(daily_returns.tail(100))\nplt.show()\n```\n\n![1531634310060](1531634310060.png)\n\n[关于证券收益分布原因的讨论](https://www.ricequant.com/community/topic/126/)\n\n#### 绘制平均值和标准差\n\n```python\n\nmean = daily_returns.mean()\nprint(\"mean=\", mean)\nstd = daily_returns.std()\nprint('std=', std)\nplt.axvline(mean, color='g')\nplt.axvline(std, color='r', linestyle='dashed')\nplt.axvline(-std, color='r', linestyle='dashed')\nplt.show()\n```\n\n![1531635134977](1531635134977.png)\n\n#### 计算峰度\n\n```python\nprint(daily_returns.kurtosis())\n```\n\n```\n7.34265127165\n```\n\n> 在机率论中，*肥尾分布**（英语：Fat-tailed distribution）是一种[机率分布](https://zh.wikipedia.org/wiki/%E6%A9%9F%E7%8E%87%E5%88%86%E5%B8%83)模型。它是一种[重尾分布](https://zh.wikipedia.org/wiki/%E9%87%8D%E5%B0%BE%E5%88%86%E5%B8%83)，但是它的[偏度](https://zh.wikipedia.org/wiki/%E5%81%8F%E5%BA%A6)或[峰度](https://zh.wikipedia.org/wiki/%E5%B3%B0%E5%BA%A6)极端的大。与无所不在的[正态分布](https://zh.wikipedia.org/wiki/%E5%B8%B8%E6%85%8B%E5%88%86%E5%B8%83)作比较，[正态分布](https://zh.wikipedia.org/wiki/%E5%B8%B8%E6%85%8B%E5%88%86%E5%B8%83)属于一种细尾分布，或[指数分布](https://zh.wikipedia.org/wiki/%E6%8C%87%E6%95%B0%E5%88%86%E5%B8%83)。 \n\n##### Plot two histograms together (合并绘制两个直方图)\n\n```python\nimport matplotlib.pyplot as plt\nimport pandas as pd\nfrom finance_datareader_py.eastmoney.daily import EastMoneyDailyReader\n\n\ndef compute_daily_returns(df):\n    return df[:-1].values / df[1:] - 1\n\n\ndf = pd.DataFrame()\ndf['601398'] = EastMoneyDailyReader('601398').read()['Close']\ndf['601939'] = EastMoneyDailyReader('601939').read()['Close']\n# 计算日收益率\ndaily_returns = compute_daily_returns(df)\n# 绘制直方图\ndaily_returns.hist()\n# 绘图\nplt.show()\n\n# 合并绘制两个直方图\ndaily_returns['601398'].hist(label='601398')\ndaily_returns['601939'].hist(label='601939')\nplt.legend(loc='upper right')\nplt.show()\n```\n\n![1532508260900](1532508260900.png)\n\n![1532508276951](1532508276951.png)\n\n股票和市场的日收益分布和高斯分布非常相似。这个性质对 *日收益、月收益、年收益* 来说同样适用。\n\n如果它们真的是高斯分布，那么我们就可以说它们是正态分布。\n\n**但是假定收益是正态分布的，却是非常危险的。因为它忽略了峰度或者尾部。** *正是因为这样才造成了08年的金融风暴。*\n\n#### Scatterplots (散点图)\n\n这是区分各支股票日收益的另一种方法。\n\n线性但离散的特点。\n\n\n\n{% blockquote Beta系数 https://zh.wikipedia.org/wiki/Beta%E7%B3%BB%E6%95%B0 %}\n贝他值（ $\\beta$ 值）：\n用以衡量基金之市场风险，或称系统性风险。其计算的方式为以过去12个月或24个月之基金月报酬率对同期市场月报酬率做回归，估计斜率系数而得，当 $\\beta$ >1（$\\beta$ < -1），表示基金坡动度较指数为大，当指数上扬 10%（下跌10%），基金会上扬超过 10%（下跌超过10%）；当 $\\beta$ = 1，表示指数涨跌多少，基金就跟着变动多少。\n{% endblockquote %}\n\n\n\n{% blockquote 阿尔法系数 https://zh.wikipedia.org/wiki/%E8%AF%81%E5%88%B8%E6%8A%95%E8%B5%84%E5%9F%BA%E9%87%91#%E9%98%BF%E5%B0%94%E6%B3%95%E7%B3%BB%E6%95%B0 %}\n阿尔法系数（ $\\alpha$）是基金的实际收益和按照β系数计算的期望收益之间的差额。其计算方法如下：超额收益是基金的收益减去无风险投资收益（在中国为1年期银行定期存款收益）；期望收益是贝塔系数 $\\beta$ 和市场收益的乘积，反映基金由于市场整体变动而获得的收益；超额收益和期望收益的差额即 $\\alpha$ 系数。该系数越大越好。\n{% endblockquote %}\n\n\n\n##### Slope does not equal correlation (斜率 $\\beta$ 系数与数据的相关性/拟合度无关)\n\n可能有很低的斜率，但是数据拟合度非常高。反之亦然。\n\n##### Scatterplots in python (散点图)\n\n```python\ndf = pd.DataFrame()\ndf['000300'] = SohuDailyReader('000300', prefix='zs_').read()['Close']\ndf['601398'] = SohuDailyReader('601398').read()['Close']\ndf['601939'] = SohuDailyReader('601939').read()['Close']\n# 计算日收益率\ndaily_returns = compute_daily_returns(df)\n# 绘制 601398 相对于 000300 的散点图\ndaily_returns.plot(kind='scatter', x='000300', y='601398')\nplt.show()\n# 绘制 601939 相对于 000300 的散点图\ndaily_returns.plot(kind='scatter', x='000300', y='601939')\nplt.show()\n```\n\n![1532570705884](1532570705884.png)\n\n![1532570720355](1532570720355.png)\n\n```python\nimport numpy as np\n\n# beta系数和alpha系数\nbeta, alpha = np.polyfit(daily_returns['000300'], daily_returns['601939'], 1)\n\ndaily_returns.plot(kind='scatter', x='000300', y='601939')\n# 绘制拟合线\nplt.plot(daily_returns['000300'], beta * daily_returns['000300'] + alpha, '-',\n         color='r')\nplt.show()\nprint('beta=' + str(beta))\nprint('alpha=' + str(alpha))\n```\n\n```\nbeta=0.590256550806\nalpha=-0.000246730309092\n```\n\n![1532571574686](1532571574686.png)\n\n### 投资组合\n\n#### Daily portfolio values\n\n[https://youtu.be/UweF-2-Tr9Y](https://youtu.be/UweF-2-Tr9Y)\n\n```\n投资组合假设：\nstart_val = 1000000 # 初始投资总额\nstart_date = 2011-01-01 # 初始投资日期\nend_date = 2011-12-31 # 结束投资日期\n# 投资组合：贵州茅台、中国平安、招商银行、格力电器\nsymbols = ['600519','601318','600036','000651'] \n# 比率分配\nallocs = [0.4,0.4,0.1,0.1]\n```\n\n#### 如何计算投资组合每日的总价值\n\n[https://youtu.be/UweF-2-Tr9Y](https://youtu.be/UweF-2-Tr9Y)\n\n1. 从价格 `DataFrame` 开始。\n2. 价格归一化（`normed=prices/prices[0]`）。开始日期的数据始终为1.0。\n3. 使用归一化以后的值乘以每支股票分配的资金比例（`alloced=normed*allocs`）。\n4. 使用初始投资总额乘以3的结果（`pos_vals=alloced*start_val`）\n5. 每一天的总价值：`port_val=pos_vals.sum(axis=1)`\n\n![1532675498707](1532675498707.png)\n\n计算后的每日收益的第一天的收益始终为 *0*，所以应该去除。 `daily_returns=daily_returns[1:]` \n\n有了每日收益之后可以计算很多有趣的数据。**评估投资组合时的常用数据**：\n\n* `cum_ret` 累计收益 `(port_val[-1]/port_val[0])-1`\n* `avg_daily_ret` 平均收益 `daily_rets.mean()`\n* `std_daily_ret` 每日收益标准差 `daily_rets.std()`\n* `sharpe_ratio` 夏普比率\n\n```python\nimport datetime\nimport pandas as pd\nfrom finance_datareader_py.sohu.daily import SohuDailyReader\n\ndef compute_daily_returns(df):\n    return df[:-1].values / df[1:] - 1\n\nSYMBOLS = ['600519', '601318', '600036', '000651']\nALLOCS = [0.4, 0.4, 0.1, 0.1]\nSTART = datetime.date(2009, 1, 1)\nEND = datetime.date(2011, 12, 31)\n\ndef get_datas(symbols, start, end):\n    df = pd.DataFrame()\n    df['000300'] = SohuDailyReader('000300', prefix='zs_', start=start,\n                                   end=end).read()['Close']\n    for symbol in symbols:\n        df1 = SohuDailyReader(symbol, start=start, end=end).read()\n        df1 = df1.rename(columns={'Close': symbol})\n        df = df.join(df1[symbol])\n    return df.fillna(method='bfill')  # 因为是倒序排序，所以使用bfill\n\ndf = get_datas(SYMBOLS, START, END)\ndf_ret = compute_daily_returns(df)\nprint(df)\nprint(df_ret)\nprint('-----------------')\nprint('平均收益:')\nprint(df_ret.mean())\nprint('-----------------')\nprint('每日收益标准差:')\nprint(df_ret.std())\nprint('-----------------')\nprint('累计收益:')\nprint(df.iloc[0] / df.iloc[-1] - 1)\n\n# 移除指数列，并按照比率分配\nalloced = df_nor.copy().drop('000300', axis=1) * ALLOCS\n# 按照比率分配后的各支股票的每日价值\npos_vals = alloced * START_VALS\n# 投资组合的每日价值\nport_val = pos_vals.sum(axis=1)\n```\n\n```\n-----------------\n平均收益:\n000300    0.000443\n600519    0.000973\n601318    0.000508\n600036    0.000162\n000651    0.000445\ndtype: float64\n-----------------\n每日收益标准差:\n000300    0.016803\n600519    0.018983\n601318    0.023065\n600036    0.021895\n000651    0.031399\ndtype: float64\n-----------------\n累计收益:\n000300    0.245773\n600519    0.783539\n601318    0.193761\n600036   -0.057188\n000651   -0.074906\ndtype: float64\n```\n\n#### Sharpe ratio (夏普比率)\n\n[https://youtu.be/5cqstpRndtI](https://youtu.be/5cqstpRndtI)\n\n{% blockquote 夏普比率 http://wiki.mbalib.com/wiki/%E5%A4%8F%E6%99%AE%E6%AF%94%E7%8E%87 %}\n\n　　现代投资理论的研究表明,风险的大小在决定组合的表现上具有基础性的作用。风险调整后的收益率就是一个可以同时对收益与风险加以考虑的综合指标,以期能够排除风险因素对绩效评估的不利影响。夏普比率就是一个可以同时对收益与风险加以综合考虑的三大经典指标之一。\n\n　　投资中有一个常规的特点，即投资标的的预期报酬越高，投资人所能忍受的波动风险越高；反之，预期报酬越低，波动风险也越低。所以理性的投资人选择投资标的与投资组合的主要目的为：在固定所能承受的风险下，追求最大的报酬；或在固定的预期报酬下，追求最低的风险。\n\n　　夏普比率计算公式：＝[E(Rp)－Rf]/σp\n\n　　其中E(Rp)：投资组合预期报酬率\n\n　　Rf：无风险利率\n\n　　σp：投资组合的标准差\n\n　　目的是计算投资组合每承受一单位总风险，会产生多少的超额报酬。比率依据资本市场线(Capital Market Line,CML)的观念而来，是市场上最常见的衡量比率。当投资组合内的资产皆为风险性资产时，适用夏普比率。夏普指数代表投资人每多承担一分风险，可以拿到几分报酬；若为正值，代表基金报酬率高过波动风险；若为负值，代表基金操作风险大过于报酬率。这样一来，每个投资组合都可以计算Sharpe Ratio,即投资回报与多冒风险的比例，这个比例越高，投资组合越佳。\n\n　　举例而言，假如国债的回报是3%，而您的投资组合预期回报是15%，您的投资组合的标准偏差是6%，那么用15%－3%,可以得出12%（代表您超出无风险投资的回报），再用12%÷6%＝2，代表投资者风险每增长1%，换来的是2%的多余收益。\n\n{% endblockquote %}\n\n##### 以下计算夏普比率的公式使用：\n\n`日收益 减去 日化无风险收益率 的均值 / 日收益 减去 日化无风险收益率 的标准差`\n\n`S = mean(daily_rets - daily_rf) / std(daily_rets - daily_rf)`\n\n什么是日化无风险收益率？视频中采用了 *伦敦银行同业拆放利率、3月期国债利率、0%*。\n\n如何计算日化收益率？假设年收益为10%，每年有252个交易日。那么日收益率：\n\ndaily_rf = $\\sqrt[252]{1.0+0.1}-1$\n\n将 daily_rf 视为一个常数时（和将常数视作0的效果一样），可以将计算公式改为：\n\n`S = mean(daily_rets - daily_rf) / std(daily_rets)`\n\n> 夏普比率对于相同资产可以有相当大的变化。**取决于采样的频繁度**\n>\n> 如果每年采样股票价格，并且基于年化统计量计算，会得到一个数字；如果每月采样，会得到不同的数字；如果改成每日采样，又会得到另一个数字。\n>\n> **最初版本的夏普比率是一个年化的测量值。所以如果需要以非年化的采样来计算，那么需要加上一个调整因子来使其正常工作。**\n>\n> `SRannualized = K * SR`\n>\n> 调整因子（K）是每年的采样数量值的平方根。\n>\n> 假设使用的是每日采样，一年共有252个交易日。daily K = $\\sqrt{252}$\n>\n> 假设使用的是每周采样，一年共有52个交易周。daily K = $\\sqrt{52}$\n>\n> 假设使用的是每月采样，一年共有12个交易月。daily K = $\\sqrt{12}$\n>\n> **即便某支股票一年只交易了80天，在以每日采样计算调整因子时，还是应该是用252来进行计算**\n\n#### What is an optimizer（优化器）\n\n* 用来寻找函数最小值\n* 从数据中查找并建立参数化模型（从实验数据中找到一个多项式来拟合实验数据）\n* 使用优化器来改善股票投资组合中的分配方式\n\n```python\nimport scipy.optimize as spo\n\ndef f(X):\n    Y = (X - 1.5) ** 2 + 0.5\n    print(\"X={0},Y={1}\".format(X, Y))\n    return Y\n\nXguess = 2.0\nmin_result = spo.minimize(f, Xguess, method='SLSQP', options={'disp': True})\nprint('Minima found at:')\nprint(\"X={0},Y={1}\".format(min_result.x, min_result.fun))\n```\n\n```\nX=[ 2.],Y=[ 0.75]\nX=[ 2.],Y=[ 0.75]\nX=[ 2.00000001],Y=[ 0.75000001]\nX=[ 0.99999999],Y=[ 0.75000001]\nX=[ 1.5],Y=[ 0.5]\nX=[ 1.5],Y=[ 0.5]\nX=[ 1.50000001],Y=[ 0.5]\nOptimization terminated successfully.    (Exit mode 0)\n            Current function value: 0.5\n            Iterations: 2\n            Function evaluations: 7\n            Gradient evaluations: 2\nMinima found at:\nX=[ 1.5],Y=0.5\n```\n\n```python\nXplot = np.linspace(0.5, 2.5, 21)\nYplot = f(Xplot)\nplt.plot(Xplot, Yplot)\nplt.plot(min_result.x, min_result.fun, 'ro')\nplt.title('Minima of an objective function')\nplt.show()\n```\n\n![1532659982849](1532660052844.png)\n\n#### Convex Problems (凸问题)\n\n**凸集必定有局部最小值，同时这个局部最小值也就是全局最小值。**\n\n#### 构建参数化模型\n\n什么是参数化模型？`f(x) = mx+b`这是个关于 x 的函数，它有两个参数 m 和 b。\n\n优化器就是通过不断的修改参数值并迭代函数，来找到函数的最优解。\n\n```python\ndef get_portfoilo(symbols, start, end, allocs, start_values):\n    \"\"\"获取投资组合与沪深300指数的收益比较\n\n    :param symbols: 投资组合\n    :param start: 开始日期\n    :param end: 结束日期\n    :param allocs: 投资组合比率\n    :param start_values: 初始总投资额\n    :return:\n    \"\"\"\n    df = get_datas(symbols, start, end)\n    normed = normalization(df)\n    alloced = normed.copy().drop('000300', axis=1) * allocs\n    pos_vals = alloced * start_values\n    port_val = pos_vals.sum(axis=1)\n    return normalization(pd.DataFrame(port_val.copy(),\n                                      columns=['Portfoilo']).join(df['000300']))\n\n# 投资组合一年的表现与沪深300指数的比较\nportpoilo = get_portfoilo(SYMBOLS, START, END, ALLOCS, START_VALS)\nportpoilo.show()\nplt.grid()\nplt.show()\n```\n\n![1532677809156](1532677939302.png)\n\n```python\n# 修改投资比率\nportpoilo = get_portfoilo(SYMBOLS, START, END, [0.5, 0, 0, 0.5], START_VALS)\nportpoilo.plot()\nplt.grid()\nplt.show()\n```\n\n![1532678552063](1532678552063.png)\n\n优化器的作用就在于确定如何找到最优的投资比率和股票组合。\n\n\n### Types of funds（基金类型）\n\n* ETF [交易所交易基金、交易所买卖基金](https://zh.wikipedia.org/wiki/ETF)\n* Mutual Fund [共同基金](https://zh.wikipedia.org/wiki/%E5%85%B1%E5%90%8C%E5%9F%BA%E9%87%91)\n* Hedge Fund [对冲基金](https://zh.wikipedia.org/wiki/%E5%AF%B9%E5%86%B2%E5%9F%BA%E9%87%91)\n\n| **Parameter**                     | **Hedge Fund**                            | **Mutual Fund**                                  | **ETF**                                           |\n| --------------------------------- | ----------------------------------------- | ------------------------------------------------ | ------------------------------------------------- |\n| **Return**                        | *Absolute return*                         | *Relative return*                                | *Relative return*                                 |\n| **Management**                    | *Actively managed*                        | *Comparatively less actively managed*            | *Passively managed*                               |\n| **Fees**                          | *Performance based fee*                   | *Percentage of assets managed fees*              | *–*                                               |\n| **Transaction Price**             | *–*                                       | *NAV*                                            | *Quoted price*                                    |\n| **Transparency**                  | *Information disclosed to investors only* | *Annually published reports and disclosure*      | *Daily disclosure of holdings*                    |\n| **Regulation**                    | *Less regulation*                         | *Regulated by SEBI*                              | *Regulated by Securities and Exchange Commission* |\n| **Liquidity**                     | *Low*                                     | *High*                                           | *High*                                            |\n| **Cost**                          | *–*                                       | *High average expense ratio*                     | *Low average expense ratio*                       |\n| **Investor Type**                 | *High net worth individuals*              | *Retail investors*                               | *Retail investors*                                |\n| **Fractional Shares**             | *No*                                      | *Yes*                                            | *No*                                              |\n| **Ownership of Fund Manager**     | *Substantial ownership*                   | *Non substantial ownership*                      | *–*                                               |\n| **Owners**                        | *Few owners*                              | *Many owners*                                    | *–*                                               |\n| **Minimum amount to be invested** | *High*                                    | *Low*                                            | *Low*                                             |\n| **Tax**                           | *–*                                       | *High percentage of tax levied on capital gains* | *Comparatively lower tax percentages are levied*  |\n\n\n### 如何计算估值\n\n{% blockquote 金钱的时间价值 https://zh.wikipedia.org/wiki/%E9%87%91%E9%8C%A2%E7%9A%84%E6%99%82%E9%96%93%E5%83%B9%E5%80%BC %}\n\n金钱的未来终值（future value）应大于现值（present value）\n\n{% endblockquote %}\n\n**计算:**\n\n假设某人以利率 $i$ （$i=5\\%$与$i=0.05$等同）借出或借入一笔款项，期限为 $t$ 年，则 $t$ 年后的 $C$ 个货币单位现值表达为：$C_{t}=\\frac{C}{(1+i)^{t}}$\n\n$t$ 年后的 $C$ 个莫比单位现时购买力也可以用上式计算，此时 $i$ 表示 *通货膨胀率*。\n\n同一组现金流可能根据利率的不同被分为数个时段，例如，从此时算起的第一年内的利率为 $i_1$ ，第二年的利率为 $i_2$ ，那么两年后的 $C$ 个货币单位的现值表达式为：$PV=\\frac{C}{(1+i_1)(1+i_2)}$\n\n* **内在价值**\n* **账面价值**：$总资产-无形资产-负债$\n* **市值**\n\n\n### 资本资产定价模型 （CAPM）\n\n{% blockquote 资本资产定价模型 https://zh.wikipedia.org/wiki/%E8%B5%84%E6%9C%AC%E8%B5%84%E4%BA%A7%E5%AE%9A%E4%BB%B7%E6%A8%A1%E5%9E%8B %}\n\n资本资产定价模型（英语：Capital Asset Pricing Model, CAPM）是由美国学者威廉·夏普（William Sharpe）、林特尔（John Lintner）、特里诺（Jack Treynor）和莫辛（Jan Mossin）等人在现代投资组合理论的基础上发展起来的，是现代金融市场价格理论的支柱，广泛应用于投资决策和公司理财领域。资本资产定价模型中，所谓资本资产主要指的是股票资产，而定价则试图解释资本市场如何决定股票收益率，进而决定股票价格。\n\n根据资本资产定价模型，对于一个给定的资产 $i$，它的期望收益率和市场投资组合的期望收益率之间的关系可以表示为：\n\n$E(r_i)=r_f+\\beta_im[E(r_m)-r_f]]$\n\n其中：\n\n* $E(r_i)$是资产 $i$ 的期望收益率（或普通股的资本成本率）\n* $r_f$ 是无风险收益率，通常以短期国债的利率来近似替代\n* $\\beta_{im}$ 是资产 $i$ 的系统性风险系数，$\\beta_{im}={\\frac{Cov(r_i,r_m)}{Var(r_m)}}$ \n* $E(r_{m})$市场投资组合 $m$ 的期望收益率，通常用股票价格指数收益率的平均值或所有股票的平均收益率来代替\n* $E(r_{m})-r_{f}$市场风险溢价（英语：Market Risk Premium），即市场投资组合的期望收益率与无风险收益率之差\n\nCAPM模型是建立在一系列假设的基础上的，其中主要包括：\n\n* 所有投资者均追求单期财富的期望效用最大化，并以各备选组合的期望收益和标准差为基础进行组合选择。\n* 所有投资者均可以无风险利率无限制地借入或贷出资金。\n* 所有投资者拥有同样预期，即对所有资产收益的均值、方差和协方差等，投资者均有完全相同的主观估计。\n* 所有资产均可被完全细分，拥有充分的流动性且没有交易成本。\n\n没有税金。\n\n* 所有投资者均为价格接受者。即任何一个投资者的买卖行为都不会对股票价格产生影响。\n* 所有资产的数量是给定的和固定不变的。\n\n近年的实证研究表明，CAPM模型在实际中并不能验证历史的投资收益，由此Roll在1977年提出了两种可能：一种是CAPM模型在市场上是无效的，一种是CAPM理论存在模型的设定误差；基于后一种可能，APT理论和不少多因子模型不断诞生——例如FAMA-FRENCH的三因子模型。但是由于CAPM的简单和便于理解，在业界运用非常广泛，特别是在估值分析中确定必要报酬率（英语：Required Return of Equity）。\n\n{% endblockquote %}\n\n![1533869822902](1533869822902.png)\n\n### 套利定价理论（APT）\n\n[https://youtu.be/yMMoukwU87I](https://youtu.be/yMMoukwU87I)\n\n[套利定价理论-MBAlib](http://wiki.mbalib.com/wiki/%E5%A5%97%E5%88%A9%E5%AE%9A%E4%BB%B7%E7%90%86%E8%AE%BA)\n\n### 技术分析\n\n#### 技术分析的特征\n\n* 只关注历史价格和成交量\n* 在时间序列中计算统计数据称为指标\n* 指标是启发式的\n\n#### 使技术分析有价值的因素 \n\n* 个别指标具有弱预测性，但结合多个指标可以增加价值\n* 寻找对比（单个股票 VS 市场）（找到比市场收益更好的单个或组合）\n* 在短时间内比在较长时间内工作得更有效\n\n> 持有时间越长，价值分析越重要，需要作出判断的时间越长，判断复杂度越高。（更适合人类进行分析）\n>\n> 反之，持有时间越短，技术分析越重要，需要作出判断的时间越短，判断复杂度越低。（更适合计算机做高频分析）\n\n![1533883675299](1533883675299.png)\n\n#### 部分技术分析的指标\n\n* 动量（momentum）\n\n  {% blockquote 运动量震荡指标 https://zh.wikipedia.org/wiki/%E9%81%8B%E5%8B%95%E9%87%8F%E9%9C%87%E7%9B%AA%E6%8C%87%E6%A8%99 %}\n\n  $MO_t=(P_t/P_{t-n})*100$\n  其中 $n$ 為天數，$P_t$ 為當日股價，$P_{t-n} $ 為  $n$ 日前的股價\n\n  1. MO>100时，表示目前股价行情较N日前偏多看待，相对该股票市场行情反应较为热络。\n  2. MO<100时，表示目前股价行情较N日前偏空看待，相对该股票行情市场反应较为冷淡。\n  3. MO由正转负，表示目前股价行情已转为偏空看待，多方投资人需要注意。\n  4. MO由负转正，表示目前股价行情已转为偏多看待，空方投资人需要注意。\n\n  {% endblockquote %}\n\n* 移动平均线（SMA）\n\n  >1. 寻找价格穿过简单移动平均线的点。\n  >\n  >   momentum+SMA cross可能会是买入或卖出的指标。\n  >\n  >2. 可以将移动平均线看成是一个时间段上的公司价值。股价会在移动平均线上下波动。\n\n  ![1533886709495](1533886709495.png)\n\n  {% blockquote 移动平均 https://zh.wikipedia.org/wiki/%E7%A7%BB%E5%8B%95%E5%B9%B3%E5%9D%87 %}\n\n  * **简单移动平均**（英语：simple moving average，SMA）是某变数之前 $n$ 个数值的未作加权算术平均。例如，收市价的10日简单移动平均指之前10日收市价的平均数。若设收市价为 $p_{1}$至 $p_{n}$，则方程式为：\n\n    $SMA={p_{1}+p_{2}+\\cdots +p_{n} \\over n}$\n    当计算连续的数值，一个新的数值加入，同时一个旧数值剔出，所以无需每次都重新逐个数值加起来：\n\n    $SMA_{t1,n}=SMA_{t0,n}-{p_{1} \\over n}+{p_{n+1} \\over n}$\n    在技术分析中，不同的市场对常用天数（$n$值）有不同的需求，例如：某些市场普遍的$n$值为10日、40日、200日；有些则是5日、10日、20日、60日、120日、240日，视乎分析时期长短而定。投资者冀从移动平均线的图表中分辨出支持位或阻力位。\n\n  * **指数移动平均**（英语：exponential moving average，EMA或EWMA）是以指数式递减加权的移动平均。各数值的加权影响力随时间而指数式递减，越近期的数据加权影响力越重，但较旧的数据也给予一定的加权值。右图是一例子。\n\n    加权的程度以常数 $α$ 决定，$α$ 数值介乎0至1。$α$ 也可用天数 $N$ 来代表： $\\alpha ={2 \\over {N+1}}$，所以，$N$=19天，代表$α=0.1$。\n\n    设时间 $t$ 的实际数值为$Y_t$，而时间 $t$ 的EMA则为$S_t$；时间 $t-1$ 的EMA则为$S_{t-1}$，计算时间 $t≥2$ 是方程式为：\n\n    $S_{t}=\\alpha * Y_{t}+(1-\\alpha )* S_{t-1}$\n    设今日（$t1$）价格为 $p$，则今日（$t1$）EMA的方程式为：\n\n    $EMA_{t1}={\\text{EMA}}_{t0}+\\alpha \\times (p-{\\text{EMA}}_{t0})$\n    将 ${\\text{EMA}}_{t0}$分拆开来如下：\n\n    ${\\text{EMA}}={p_{1}+(1-\\alpha )p_{2}+(1-\\alpha )^{2}p_{3}+(1-\\alpha )^{3}p_{4}+\\cdots \\over 1+(1-\\alpha )+(1-\\alpha )^{2}+(1-\\alpha )^{3}+\\cdots }$\n    理论上这是一个无穷级数，但由于 $1-α$ 少于1，各项的数值会越来越细，可以被忽略。分母方面，若有足够多项，则其数值趋向 $1/α$。即，\n\n    ${\\text{EMA}}=\\alpha \\times \\left(p_{1}+(1-\\alpha )p_{2}+(1-\\alpha )^{2}p_{3}+(1-\\alpha )^{3}p_{4}+\\cdots \\right)$\n    假设 $k$ 项及以后的项被忽略，即 $\\alpha \\times \\left((1-\\alpha )^{k}+(1-\\alpha )^{k+1}+\\cdots \\right)$，重写后可得$\\alpha \\times (1-\\alpha )^{k}\\times \\left(1+(1-\\alpha )+(1-\\alpha )^{2}\\cdots \\right)$，相当于 $(1-\\alpha )^{k}$。所以，若要包含99.9%的加权，解方程 $k={\\log(0.001) \\over \\log(1-\\alpha )}$即可得出$k$。由于当$N$不断增加， $\\log \\,(1-\\alpha )$将趋向 $-2 \\over N+1$，简化后k大约等于 $3.45\\times (N+1)$。\n\n  * **加权移动平均**（英语：weighted moving average，WMA）指计算平均值时将个别数据乘以不同数值，在技术分析中，$n$日WMA的最近期一个数值乘以$n$、次近的乘以$n-1$，如此类推，一直到0：\n\n    $WMA_{M}={np_{M}+(n-1)p_{M-1}+\\cdots +2p_{M-n+2}+p_{M-n+1} \\over n+(n-1)+\\cdots +2+1}$\n\n    由于 $WMA_{M+1}$与 $WMA_{M}$的分子相差 $np_{M+1}-p_{M}-\\cdots -p_{M-n+1}$，假设 $p_{M}+p_{M-1}+\\cdots +p_{M-n+1}$为总和$M$：\n\n    $总和_{M+1} =总和_{M}+p_{M+1}-p_{M-n+1}$\n    $分子_{M+1}=N_{M+1}=分子_M+np_{M+1}-总和_M$\n    $WMA_{M+1}={N_{M+1} \\over n+(n-1)+\\cdots +2+1}$\n    留意分母为三角形数，方程式为 $n(n+1) \\over 2$\n\n    右图显示出加权是随日子远离而递减，直至递减至零。\n\n  {% endblockquote %}\n\n* [布林带](https://zh.wikipedia.org/wiki/%E5%B8%83%E6%9E%97%E5%B8%A6) \n\n  {% blockquote 移动平均 https://zh.wikipedia.org/wiki/%E7%A7%BB%E5%8B%95%E5%B9%B3%E5%9D%87 %}\n\n  “布林带”是这样定义的：\n\n  中轨 = $N$ 时间段的简单移动平均线\n  上轨 = 中轨 + $K × N$时间段的标准差\n  下轨 = 中轨 − $K × N$时间段的标准差\n  一般情况下，设定N=20和K=2，这两个数值也是在布林带当中使用最多的。在日线图里，N=20其实就是“月均线”（MA20）。依照正态分布规则，约有95%的数值会分布在距离平均值有正负2个标准差（ $\\pm 2\\sigma$ ）的范围内。\n\n  {% endblockquote %}\n\n  ![1533890419564](1533890419564.png)\n\n> **单纯使用穿越布林带上轨和下轨来作为买入卖出依据虽然看上去很美，但是个人认为并不能作为唯一条件。**\n>\n> 以 2017-01-01 ~ 2017-12-31 日之间的 600016 交易数据判断。\n>\n> *模拟操作为 一次购买机会买入100股，每遇到一次卖出机会卖出持有的所有股份。*\n>\n> 在模拟日期间共出现 7 次购买机会，前六次购买后卖出时亏损了360元。\n>\n> ```\n>             Close_Adj   mean_20         top   ...    Rate      C     Sum\n> Date                                          ...                       \n> 2017-02-20     157.27  157.5570  159.230044   ...    0.53 -100.0  -914.0\n> 2017-03-06     154.61  156.3465  158.153251   ...    0.20 -100.0  -896.0\n> 2017-03-13     153.14  155.4830  158.303460   ...    0.15 -100.0  -886.0\n> 2017-03-23     149.15  153.3205  157.689392   ...    0.34 -100.0  -859.0\n> 2017-04-17     143.84  147.8400  152.270060   ...    0.51 -100.0  -823.0\n> 2017-04-21     138.97  145.6275  152.778017   ...    0.31 -100.0  -790.0\n> 2017-05-26     140.60  138.2060  141.390432   ...    0.71  600.0  4806.0\n> 2017-06-29     144.14  141.6690  144.347758   ...    0.26    NaN     NaN\n> 2017-07-18     151.00  144.9020  151.131555   ...    0.65    NaN     NaN\n> 2017-07-20     151.88  145.9120  153.310778   ...    0.45    NaN     NaN\n> 2017-08-15     146.28  150.4675  155.338483   ...    0.32 -100.0  -823.0\n> 2017-11-01     148.20  146.5935  148.700933   ...    0.27  100.0   824.0\n> 2017-11-09     150.11  147.4940  150.556908   ...    0.29    NaN     NaN\n> 2017-11-27     161.03  152.3635  161.544288   ...    0.76    NaN     NaN\n> \n> [14 rows x 16 columns]\n> 600016 : -361.0/0\n> ```\n>\n> 从图中可以看出 2017-02-17，2017-03-03 分别给出了从 布林带下方穿越布林带的信号，但是结果却非常不理想。\n>\n> ![image-20180811213410404](image-20180811213410404.png)\n>\n> 对于上证50指数的所有股票进行 2017-01-01 ~ 2017-12-31 期间的数据模拟，效果依然不是很理想。去年盈利10000+，但是截至 2017-12-31 却持有价值 80000+ 的股票。\n>\n> **应该参考之前的 “投资组合” 选出合适的能够跑赢指数均值的组合 和其他分析指标共同分析。**\n>\n> 代码：https://github.com/GuQiangJS/studySource/blob/master/codes/python/machine-learning-for-trading/tests/test_plot_bbands.py\n\n### 数据分析\n\n#### Survior bias\n\nhttps://youtu.be/RCB2hkiwqnA\n\n>  使用同样的时间间隔分析同一成分股集合时，选取成分股集合的时间点会造成不同的结果。采用分析时间结束时的成分股集合时会得到更加漂亮、诱人、但不真实的结果。**应该选取分析时间开始时的集合**。\n\n![1534238787357](1534238787357.png)\n\n#### 效率市场假说\n\n{% blockquote 效率市场假说 https://zh.wikipedia.org/wiki/%E6%95%88%E7%8E%87%E5%B8%82%E5%A0%B4%E5%81%87%E8%AA%AA %}\n\n* 弱式效率（Weak Form Efficiency）\n\n  目前股票价格已充分反映了过去股票价格所提供的各项情报。所以，投资人无法再运用各种方法对过去股票价格进行分析，再利用分析结果来预测未来股票价格，基于随机游走假说，未来消息是随机而来的。意即投资者无法再利用过去资讯来获得高额报酬。所以，弱势效率越高，若以过去价量为基础的技术分析来进行预测效果将会十分不准确。\n\n  > 留下了可以从事基本面分析的口子。\n\n* 半强式效率（Semi-Strong Form Efficiency）\n\n  目前股票价格已充分反应了所有公开资讯，所以，投资者无法利用情报分析结果来进行股票价格预测而获取高额报酬。因此，半强式效率越高，依赖公开的财务报表、经济情况及政治情势来进行基本面分析，然后再预测股票价格是徒劳无功。\n\n  > 连基本面分析都不行了。只能通过内幕交易了。\n\n* 强式效率（Strong Form Efficiency）\n\n  目前股票价格充分反应了所有已公开和未公开之所有情报。虽然情报未公开，但投资者能利用各种管道来获得资讯，所以，所谓未公开的消息，实际上是已公开的资讯且已反应于股票价格上。此种情形下，投资者也无法因拥有某些股票内幕消息而获取高额报酬。 \n\n  > 连内部交易都没机会了。\n\n{% endblockquote %}\n\n#### Grinold's fundamental law\n\nhttps://youtu.be/W6yUgs1OLx0\n\n$performance=Skill \\times \\sqrt{breadth}$\n\n#### 通过协方差构建投资组合（获得相同回报，但降低波动性）\n\n[现代投资组合理论](https://zh.wikipedia.org/wiki/%E7%8E%B0%E4%BB%A3%E6%8A%95%E8%B5%84%E7%BB%84%E5%90%88%E7%90%86%E8%AE%BA)\n\n### 机器学习\n\n#### 监督回归学习\n\n* 线性回归（参数式）\n* [最近邻居法](https://zh.wikipedia.org/wiki/%E6%9C%80%E8%BF%91%E9%84%B0%E5%B1%85%E6%B3%95)（实例式）\n* 决策树\n* 决策森林\n\n#### Price forecasting demo\n\nhttps://youtu.be/GVOEnkjmBZU\n\n![1535439244770](1535439244770.png)\n\n#### 强化学习\n\n### 过拟合\n\n#### 集成学习 ([Ensemble learning](https://en.wikipedia.org/wiki/Ensemble_learning))\n\n![1536045019373](1536045019373.png)\n\n#### Bagging算法([Bootstrap aggregating](https://zh.wikipedia.org/wiki/Bagging%E7%AE%97%E6%B3%95))\n\n#### [AdaBoost](https://zh.wikipedia.org/wiki/AdaBoost)\n\nhttps://www.youtube.com/watch?v=GM3CDQfQ4sw&list=PLAwxTw4SYaPnIRwl6rad_mYwEk4Gmj7Mx&index=194\n\n\n\n### 数据特征缩放\n\n**标准化：** $normed={values-mean \\over values.std()}$\n\n标准化后，数据均值为0，数值将在 -1 和 1 之间变化。\n\n{% blockquote 重新缩放 https://zh.wikipedia.org/wiki/%E7%89%B9%E5%BE%B5%E7%B8%AE%E6%94%BE %}\n\n最简单的方式是重新缩放特征的范围到[0, 1]或[-1, 1]， 依据原始的资料选择目标范围，通式如下：$ x'={x-min(x) \\over max(x)-min(x)}$\n\n$x$ 是原始的值，$x'$ 是被标准化后的值。例如，假设我们有学生的体重资料，范围落在[160磅, 200磅]，为了重新缩放这个资料，我们会先将每个学生的体重减掉160，接着除与40(最大体重与最小体重的差值) \n\n{% endblockquote %}","slug":"machine-learning-for-trading","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cjof51pja0000rgueytd1x2ru","content":"<p>教程Youtube链接:<a href=\"https://www.youtube.com/playlist?list=PLAwxTw4SYaPnIRwl6rad_mYwEk4Gmj7Mx\" target=\"_blank\" rel=\"noopener\">https://www.youtube.com/playlist?list=PLAwxTw4SYaPnIRwl6rad_mYwEk4Gmj7Mx</a></p>\n<h3 id=\"单一股票收益\"><a href=\"#单一股票收益\" class=\"headerlink\" title=\"单一股票收益\"></a>单一股票收益</h3><h4 id=\"The-Data-介绍CSV文件\"><a href=\"#The-Data-介绍CSV文件\" class=\"headerlink\" title=\"The Data (介绍CSV文件)\"></a>The Data (介绍CSV文件)</h4><h4 id=\"Our-Stock-Data-介绍股票每日成交汇总数据格式\"><a href=\"#Our-Stock-Data-介绍股票每日成交汇总数据格式\" class=\"headerlink\" title=\"Our Stock Data (介绍股票每日成交汇总数据格式)\"></a>Our Stock Data (介绍股票每日成交汇总数据格式)</h4><ul>\n<li>Date</li>\n<li>Open</li>\n<li>High</li>\n<li>Low</li>\n<li>Close</li>\n<li>Volume -&gt; 成交量</li>\n<li>Adj Close -&gt; 调整收盘价（除权除息价）</li>\n</ul>\n<h4 id=\"Pandas-Dataframe\"><a href=\"#Pandas-Dataframe\" class=\"headerlink\" title=\"Pandas Dataframe\"></a>Pandas Dataframe</h4><h4 id=\"Actual-CSV\"><a href=\"#Actual-CSV\" class=\"headerlink\" title=\"Actual CSV\"></a>Actual CSV</h4><h4 id=\"Interesting-Stuff\"><a href=\"#Interesting-Stuff\" class=\"headerlink\" title=\"Interesting Stuff\"></a>Interesting Stuff</h4><p>切片：取 <code>Dataframe</code> 中的部分数据</p>\n<p><a href=\"http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.loc.html#pandas.DataFrame.loc\" target=\"_blank\" rel=\"noopener\">pandas.DataFrame.loc</a></p>\n<h4 id=\"Compute-max-closing-price\"><a href=\"#Compute-max-closing-price\" class=\"headerlink\" title=\"Compute max closing price\"></a>Compute max closing price</h4><p><a href=\"http://pandas.pydata.org/pandas-docs/stable/generated/pandas.Series.max.html#pandas-series-max\" target=\"_blank\" rel=\"noopener\">pandas.Series.max</a></p>\n<h4 id=\"Plotting-stock-price-data-绘图\"><a href=\"#Plotting-stock-price-data-绘图\" class=\"headerlink\" title=\"Plotting stock price data (绘图)\"></a>Plotting stock price data (绘图)</h4><h4 id=\"Plot-two-columns-绘制多个数据\"><a href=\"#Plot-two-columns-绘制多个数据\" class=\"headerlink\" title=\"Plot two columns (绘制多个数据)\"></a>Plot two columns (绘制多个数据)</h4><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"><span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd</span><br><span class=\"line\"><span class=\"keyword\">from</span> finance_datareader_py.eastmoney.daily <span class=\"keyword\">import</span> EastMoneyDailyReader</span><br><span class=\"line\"></span><br><span class=\"line\">df1 = EastMoneyDailyReader(<span class=\"string\">'601398'</span>).read()</span><br><span class=\"line\">df2 = EastMoneyDailyReader(<span class=\"string\">'601398'</span>, type=<span class=\"string\">'ba'</span>).read()</span><br><span class=\"line\">df = pd.DataFrame()</span><br><span class=\"line\">df[<span class=\"string\">'Close'</span>] = pd.to_numeric(df1[<span class=\"string\">'Close'</span>])</span><br><span class=\"line\">df[<span class=\"string\">'Adj Close'</span>] = pd.to_numeric(df2[<span class=\"string\">'Close'</span>])</span><br><span class=\"line\">print(df.tail())</span><br><span class=\"line\">df.plot()</span><br><span class=\"line\">plt.show()</span><br></pre></td></tr></table></figure>\n<p><img src=\"1531304006175.png\" alt=\"1531304006175\"></p>\n<h4 id=\"Pandas-dataframe-recap\"><a href=\"#Pandas-dataframe-recap\" class=\"headerlink\" title=\"Pandas dataframe recap\"></a>Pandas dataframe recap</h4><h4 id=\"Problems-to-Solve\"><a href=\"#Problems-to-Solve\" class=\"headerlink\" title=\"Problems to Solve\"></a>Problems to Solve</h4><h5 id=\"Data-ranges-使用日期索引取值\"><a href=\"#Data-ranges-使用日期索引取值\" class=\"headerlink\" title=\"Data ranges(使用日期索引取值)\"></a>Data ranges(使用日期索引取值)</h5><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">from finance_datareader_py.eastmoney.daily import EastMoneyDailyReader</span><br><span class=\"line\">df = EastMoneyDailyReader(&apos;601398&apos;).read()</span><br><span class=\"line\">df.tail()</span><br><span class=\"line\">Out[4]: </span><br><span class=\"line\">            Open Close  High   Low   交易量(手)   成交金额     振幅   换手率</span><br><span class=\"line\">日期                                                             </span><br><span class=\"line\">2018-07-05  5.17  5.23  5.29  5.16  1865183  9.72亿  2.52%  0.07</span><br><span class=\"line\">2018-07-06  5.23  5.29  5.34  5.18  1925444  10.1亿  3.06%  0.07</span><br><span class=\"line\">2018-07-09  5.31  5.53  5.54  5.31  2155458  11.7亿  4.35%  0.08</span><br><span class=\"line\">2018-07-10  5.56  5.52  5.57  5.46  1289900  7.10亿  1.99%  0.05</span><br><span class=\"line\">2018-07-11  5.41  5.48  5.52  5.39  1520449  8.31亿  2.36%  0.06</span><br><span class=\"line\"></span><br><span class=\"line\">df[&apos;2017-01-01&apos;:&apos;2017-12-31&apos;].tail()</span><br><span class=\"line\">Out[6]: </span><br><span class=\"line\">            Open Close  High   Low   交易量(手)   成交金额     振幅   换手率</span><br><span class=\"line\">日期                                                             </span><br><span class=\"line\">2017-12-25  5.93  6.00  6.03  5.93  2396364  14.4亿  1.69%  0.09</span><br><span class=\"line\">2017-12-26  6.00  6.08  6.10  5.98  2165329  13.1亿     2%  0.08</span><br><span class=\"line\">2017-12-27  6.09  6.05  6.15  6.02  2151401  13.1亿  2.14%  0.08</span><br><span class=\"line\">2017-12-28  6.03  6.14  6.14  6.02  2100886  12.8亿  1.98%  0.08</span><br><span class=\"line\">2017-12-29  6.13  6.20  6.22  6.12  2168998  13.4亿  1.63%  0.08</span><br></pre></td></tr></table></figure>\n<p>取沪深300指数（399300）+单个股票数据。</p>\n<p>取沪深300指数的意义在于，只要开市，那么指数就肯定有数据，而不像其他单一股票可能会出现不定期停牌的情况。</p>\n<p>看下面的数据：</p>\n<ol>\n<li>2005年，300027还没有上市，所以数值为 <code>NaN</code>。</li>\n<li>2018-07-07、2018-07-08两天是休息日，不开市。这时不会有数据。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">import pandas as pd</span><br><span class=\"line\">from finance_datareader_py.eastmoney.daily import EastMoneyDailyReader</span><br><span class=\"line\">df1 = EastMoneyDailyReader(&apos;399300&apos;).read()</span><br><span class=\"line\">df2 = EastMoneyDailyReader(&apos;300027&apos;).read()</span><br><span class=\"line\">df = pd.DataFrame()</span><br><span class=\"line\">df[&apos;399300&apos;] = df1[&apos;Close&apos;]</span><br><span class=\"line\">df[&apos;300027&apos;] = df2[&apos;Close&apos;]</span><br><span class=\"line\"></span><br><span class=\"line\">df.head()</span><br><span class=\"line\">Out[4]: </span><br><span class=\"line\">            399300 300027</span><br><span class=\"line\">日期                       </span><br><span class=\"line\">2005-01-04  982.79    NaN</span><br><span class=\"line\">2005-01-05  992.56    NaN</span><br><span class=\"line\">2005-01-06  983.17    NaN</span><br><span class=\"line\">2005-01-07  983.96    NaN</span><br><span class=\"line\">2005-01-10  993.88    NaN</span><br><span class=\"line\"></span><br><span class=\"line\">df.tail()</span><br><span class=\"line\">Out[3]: </span><br><span class=\"line\">             399300 300027</span><br><span class=\"line\">日期                        </span><br><span class=\"line\">2018-07-05  3342.44   6.08</span><br><span class=\"line\">2018-07-06  3365.12   6.09</span><br><span class=\"line\">2018-07-09  3459.18   6.12</span><br><span class=\"line\">2018-07-10  3467.52   6.03</span><br><span class=\"line\">2018-07-11  3407.53   5.96</span><br></pre></td></tr></table></figure>\n<h4 id=\"Create-an-exmpty-data-frame\"><a href=\"#Create-an-exmpty-data-frame\" class=\"headerlink\" title=\"Create an exmpty data frame\"></a>Create an exmpty data frame</h4><h4 id=\"Join-SPY-data-使用Join关联数据，使用dropna丢弃空数据\"><a href=\"#Join-SPY-data-使用Join关联数据，使用dropna丢弃空数据\" class=\"headerlink\" title=\"Join SPY data (使用Join关联数据，使用dropna丢弃空数据)\"></a>Join SPY data (使用Join关联数据，使用dropna丢弃空数据)</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">import pandas as pd</span><br><span class=\"line\">from finance_datareader_py.eastmoney.daily import EastMoneyDailyReader</span><br><span class=\"line\">df1 = EastMoneyDailyReader(&apos;399300&apos;).read()</span><br><span class=\"line\">dates = pd.date_range(&apos;2010-01-01&apos;, &apos;2010-01-05&apos;)</span><br><span class=\"line\"># 创建空白DataFrame</span><br><span class=\"line\">df = pd.DataFrame(index=dates)</span><br><span class=\"line\">df = df.join(df1)</span><br><span class=\"line\"></span><br><span class=\"line\">df[&apos;Close&apos;].head()</span><br><span class=\"line\">Out[3]: </span><br><span class=\"line\">2010-01-01        NaN</span><br><span class=\"line\">2010-01-02        NaN</span><br><span class=\"line\">2010-01-03        NaN</span><br><span class=\"line\">2010-01-04    3535.23</span><br><span class=\"line\">2010-01-05    3564.04</span><br><span class=\"line\">Freq: D, Name: Close, dtype: object</span><br><span class=\"line\"></span><br><span class=\"line\">df[&apos;Close&apos;].head().dropna()</span><br><span class=\"line\">Out[4]: </span><br><span class=\"line\">2010-01-04    3535.23</span><br><span class=\"line\">2010-01-05    3564.04</span><br><span class=\"line\">Freq: D, Name: Close, dtype: object</span><br></pre></td></tr></table></figure>\n<h4 id=\"Read-in-more-stocks-重命名，一个dataframe中不能出现同名的列\"><a href=\"#Read-in-more-stocks-重命名，一个dataframe中不能出现同名的列\" class=\"headerlink\" title=\"Read in more stocks(重命名，一个dataframe中不能出现同名的列)\"></a>Read in more stocks(重命名，一个dataframe中不能出现同名的列)</h4><h4 id=\"Slicing-数据切片\"><a href=\"#Slicing-数据切片\" class=\"headerlink\" title=\"Slicing (数据切片)\"></a>Slicing (数据切片)</h4><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd</span><br><span class=\"line\"><span class=\"keyword\">from</span> finance_datareader_py.eastmoney.daily <span class=\"keyword\">import</span> EastMoneyDailyReader</span><br><span class=\"line\"></span><br><span class=\"line\">symbols = [<span class=\"string\">'399300'</span>, <span class=\"string\">'300027'</span>, <span class=\"string\">'601398'</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">dates = pd.date_range(<span class=\"string\">'2010-01-01'</span>, <span class=\"string\">'2010-01-05'</span>)</span><br><span class=\"line\"><span class=\"comment\"># 创建空白DataFrame</span></span><br><span class=\"line\">df = pd.DataFrame(index=dates)</span><br><span class=\"line\"><span class=\"keyword\">for</span> symbol <span class=\"keyword\">in</span> symbols:</span><br><span class=\"line\">    df_temp = EastMoneyDailyReader(symbol).read()</span><br><span class=\"line\">    df_temp = df_temp.rename(columns=&#123;<span class=\"string\">'Close'</span>: symbol&#125;)</span><br><span class=\"line\">    df = df.join(df_temp[symbol])</span><br><span class=\"line\"></span><br><span class=\"line\">print(df)</span><br><span class=\"line\">print(<span class=\"string\">'------------------------'</span>)</span><br><span class=\"line\">print(df.dropna())</span><br><span class=\"line\">print(<span class=\"string\">'------------------------'</span>)</span><br><span class=\"line\">print(df.loc[<span class=\"string\">'2010-01-04'</span>:<span class=\"string\">'2010-01-04'</span>,[<span class=\"string\">'000002'</span>, <span class=\"string\">'601398'</span>]])</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">             399300 300027 601398</span><br><span class=\"line\">2010-01-01      NaN    NaN    NaN</span><br><span class=\"line\">2010-01-02      NaN    NaN    NaN</span><br><span class=\"line\">2010-01-03      NaN    NaN    NaN</span><br><span class=\"line\">2010-01-04  3535.23  55.53   5.35</span><br><span class=\"line\">2010-01-05  3564.04  55.09   5.40</span><br><span class=\"line\">------------------------</span><br><span class=\"line\">             399300 300027 601398</span><br><span class=\"line\">2010-01-04  3535.23  55.53   5.35</span><br><span class=\"line\">2010-01-05  3564.04  55.09   5.40</span><br><span class=\"line\">------------------------</span><br><span class=\"line\">             399300 300027</span><br><span class=\"line\">2010-01-04  3535.23  55.53</span><br></pre></td></tr></table></figure>\n<h4 id=\"Problems-with-Plotting-判断时股价起点不同，很难在同一层面观察\"><a href=\"#Problems-with-Plotting-判断时股价起点不同，很难在同一层面观察\" class=\"headerlink\" title=\"Problems with Plotting (判断时股价起点不同，很难在同一层面观察)\"></a>Problems with Plotting (判断时股价起点不同，很难在同一层面观察)</h4><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"><span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd</span><br><span class=\"line\"><span class=\"keyword\">from</span> finance_datareader_py.eastmoney.daily <span class=\"keyword\">import</span> EastMoneyDailyReader</span><br><span class=\"line\"></span><br><span class=\"line\">symbols = [<span class=\"string\">'600519'</span>, <span class=\"string\">'000002'</span>, <span class=\"string\">'601398'</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建空白DataFrame</span></span><br><span class=\"line\">df = pd.DataFrame()</span><br><span class=\"line\"><span class=\"keyword\">for</span> symbol <span class=\"keyword\">in</span> symbols:</span><br><span class=\"line\">    df_temp = EastMoneyDailyReader(symbol).read()</span><br><span class=\"line\">    df[symbol] = df_temp[<span class=\"string\">'Close'</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">df = df.dropna()</span><br><span class=\"line\">df.loc[<span class=\"string\">'2017-01-01'</span>:<span class=\"string\">'2017-12-31'</span>].plot()</span><br><span class=\"line\">plt.show()</span><br></pre></td></tr></table></figure>\n<p><img src=\"1531383436936.png\" alt=\"1531383436936\"></p>\n<h4 id=\"Normalizing-数据归一化\"><a href=\"#Normalizing-数据归一化\" class=\"headerlink\" title=\"Normalizing (数据归一化)\"></a>Normalizing (数据归一化)</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">def normalize_data(df):</span><br><span class=\"line\">    return df / df.iloc[0]</span><br><span class=\"line\"></span><br><span class=\"line\">normalize_data(df.loc[&apos;2017-01-01&apos;:&apos;2017-12-31&apos;]).plot()</span><br></pre></td></tr></table></figure>\n<p>让Dataframe的每一行数据除以第一行的值，从而使所有数据从1开始。</p>\n<p><img src=\"1531384011994.png\" alt=\"1531384011994\"></p>\n<h4 id=\"What-is-NumPy\"><a href=\"#What-is-NumPy\" class=\"headerlink\" title=\"What is NumPy\"></a>What is NumPy</h4><h4 id=\"Relationship-to-Pandas-numpy与Pandas的关系\"><a href=\"#Relationship-to-Pandas-numpy与Pandas的关系\" class=\"headerlink\" title=\"Relationship to Pandas (numpy与Pandas的关系)\"></a>Relationship to Pandas (numpy与Pandas的关系)</h4><h4 id=\"Compute-global-statistics\"><a href=\"#Compute-global-statistics\" class=\"headerlink\" title=\"Compute global statistics\"></a>Compute global statistics</h4><p><a href=\"https://zh.wikipedia.org/wiki/%E6%A8%99%E6%BA%96%E5%B7%AE\" target=\"_blank\" rel=\"noopener\">标准差</a></p>\n<blockquote>\n<p>例如，两组数的集合{0, 5, 9, 14}和{5, 6, 8, 9}其平均值都是7，但第二个集合具有较小的标准差。 </p>\n</blockquote>\n<h4 id=\"Rolling-statistics\"><a href=\"#Rolling-statistics\" class=\"headerlink\" title=\"Rolling statistics\"></a>Rolling statistics</h4><h4 id=\"Bollinger-Bands\"><a href=\"#Bollinger-Bands\" class=\"headerlink\" title=\"Bollinger Bands\"></a>Bollinger Bands</h4><p><a href=\"https://zh.wikipedia.org/wiki/%E5%B8%83%E6%9E%97%E5%B8%A6\" target=\"_blank\" rel=\"noopener\">布林带</a></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">df = pd.DataFrame()</span><br><span class=\"line\">df[<span class=\"string\">'Close'</span>] = EastMoneyDailyReader(<span class=\"string\">'601398'</span>).read()[<span class=\"string\">'Close'</span>]</span><br><span class=\"line\">df[<span class=\"string\">'rol_30'</span>] = pd.rolling_mean(df[<span class=\"string\">'Close'</span>], window=<span class=\"number\">30</span>)</span><br><span class=\"line\">df.head(<span class=\"number\">100</span>).plot()</span><br><span class=\"line\">plt.show()</span><br></pre></td></tr></table></figure>\n<p><img src=\"1531465284221.png\" alt=\"1531465284221\"></p>\n<h4 id=\"Daily-returns-日收益\"><a href=\"#Daily-returns-日收益\" class=\"headerlink\" title=\"Daily returns (日收益)\"></a>Daily returns (日收益)</h4><p>日收益基本上是围绕0上下浮动。</p>\n<p><code>daily_ret[t]=(price[t]/price[t-1])-1</code></p>\n<p><code>(110/100)-1=1.1-1=0.1=10%</code></p>\n<h4 id=\"Cumulative-returns-累计收益\"><a href=\"#Cumulative-returns-累计收益\" class=\"headerlink\" title=\"Cumulative returns (累计收益)\"></a>Cumulative returns (累计收益)</h4><p>累积收益和数据归一化在计算中的意思基本一致。</p>\n<h4 id=\"A-closer-look-at-daily-returns\"><a href=\"#A-closer-look-at-daily-returns\" class=\"headerlink\" title=\"A closer look at daily returns\"></a>A closer look at daily returns</h4><p>使用直方图展示日收益率的分布情况</p>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E5%B3%B0%E5%BA%A6\" target=\"_blank\" rel=\"noopener\">峰度</a></p>\n<blockquote>\n<p>峰度高就意味着方差增大是由低频度的大于或小于平均值的极端差值引起的。 </p>\n</blockquote>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E8%82%A5%E5%B0%BE%E5%88%86%E5%B8%83\" target=\"_blank\" rel=\"noopener\">肥尾分布</a></p>\n<h4 id=\"Computing-rolling-statistics\"><a href=\"#Computing-rolling-statistics\" class=\"headerlink\" title=\"Computing rolling statistics\"></a>Computing rolling statistics</h4><p>20日移动平均线</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">df = EastMoneyDailyReader(<span class=\"string\">'601398'</span>).read().tail(<span class=\"number\">200</span>)</span><br><span class=\"line\">ax = df[<span class=\"string\">'Close'</span>].plot(title=<span class=\"string\">'601398 rolling mean'</span>)</span><br><span class=\"line\">rm = pd.rolling_mean(df[<span class=\"string\">'Close'</span>], window=<span class=\"number\">20</span>)</span><br><span class=\"line\">rm.plot(label=<span class=\"string\">'Rolling mean'</span>, ax=ax)</span><br><span class=\"line\"></span><br><span class=\"line\">ax.set_xlabel(<span class=\"string\">'Date'</span>)</span><br><span class=\"line\">ax.set_ylabel(<span class=\"string\">'Price'</span>)</span><br><span class=\"line\">ax.legend(loc=<span class=\"string\">'upper left'</span>)</span><br><span class=\"line\">plt.show()</span><br></pre></td></tr></table></figure>\n<p><img src=\"1531632440578.png\" alt=\"1531632440578\"></p>\n<h4 id=\"Using-fillna-数据市场是不完整的，需要补齐\"><a href=\"#Using-fillna-数据市场是不完整的，需要补齐\" class=\"headerlink\" title=\"Using fillna() (数据市场是不完整的，需要补齐)\"></a>Using fillna() (数据市场是不完整的，需要补齐)</h4><h4 id=\"Histogram-of-daily-returns-使用直方图来查看每日收益\"><a href=\"#Histogram-of-daily-returns-使用直方图来查看每日收益\" class=\"headerlink\" title=\"Histogram of daily returns (使用直方图来查看每日收益)\"></a>Histogram of daily returns (使用直方图来查看每日收益)</h4><h4 id=\"How-to-plot-a-histogram-如何绘制直方图\"><a href=\"#How-to-plot-a-histogram-如何绘制直方图\" class=\"headerlink\" title=\"How to plot a histogram (如何绘制直方图)\"></a>How to plot a histogram (如何绘制直方图)</h4><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">compute_daily_returns</span><span class=\"params\">(df)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> df[:<span class=\"number\">-1</span>].values / df[<span class=\"number\">1</span>:] - <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">df = EastMoneyDailyReader(<span class=\"string\">'601398'</span>).read()</span><br><span class=\"line\">daily_returns = compute_daily_returns(df[<span class=\"string\">'Close'</span>])</span><br><span class=\"line\">daily_returns.hist(bins=<span class=\"number\">50</span>)</span><br><span class=\"line\">print(daily_returns.tail(<span class=\"number\">100</span>))</span><br><span class=\"line\">plt.show()</span><br></pre></td></tr></table></figure>\n<p><img src=\"1531634310060.png\" alt=\"1531634310060\"></p>\n<p><a href=\"https://www.ricequant.com/community/topic/126/\" target=\"_blank\" rel=\"noopener\">关于证券收益分布原因的讨论</a></p>\n<h4 id=\"绘制平均值和标准差\"><a href=\"#绘制平均值和标准差\" class=\"headerlink\" title=\"绘制平均值和标准差\"></a>绘制平均值和标准差</h4><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">mean = daily_returns.mean()</span><br><span class=\"line\">print(<span class=\"string\">\"mean=\"</span>, mean)</span><br><span class=\"line\">std = daily_returns.std()</span><br><span class=\"line\">print(<span class=\"string\">'std='</span>, std)</span><br><span class=\"line\">plt.axvline(mean, color=<span class=\"string\">'g'</span>)</span><br><span class=\"line\">plt.axvline(std, color=<span class=\"string\">'r'</span>, linestyle=<span class=\"string\">'dashed'</span>)</span><br><span class=\"line\">plt.axvline(-std, color=<span class=\"string\">'r'</span>, linestyle=<span class=\"string\">'dashed'</span>)</span><br><span class=\"line\">plt.show()</span><br></pre></td></tr></table></figure>\n<p><img src=\"1531635134977.png\" alt=\"1531635134977\"></p>\n<h4 id=\"计算峰度\"><a href=\"#计算峰度\" class=\"headerlink\" title=\"计算峰度\"></a>计算峰度</h4><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">print(daily_returns.kurtosis())</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">7.34265127165</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>在机率论中，*肥尾分布**（英语：Fat-tailed distribution）是一种<a href=\"https://zh.wikipedia.org/wiki/%E6%A9%9F%E7%8E%87%E5%88%86%E5%B8%83\" target=\"_blank\" rel=\"noopener\">机率分布</a>模型。它是一种<a href=\"https://zh.wikipedia.org/wiki/%E9%87%8D%E5%B0%BE%E5%88%86%E5%B8%83\" target=\"_blank\" rel=\"noopener\">重尾分布</a>，但是它的<a href=\"https://zh.wikipedia.org/wiki/%E5%81%8F%E5%BA%A6\" target=\"_blank\" rel=\"noopener\">偏度</a>或<a href=\"https://zh.wikipedia.org/wiki/%E5%B3%B0%E5%BA%A6\" target=\"_blank\" rel=\"noopener\">峰度</a>极端的大。与无所不在的<a href=\"https://zh.wikipedia.org/wiki/%E5%B8%B8%E6%85%8B%E5%88%86%E5%B8%83\" target=\"_blank\" rel=\"noopener\">正态分布</a>作比较，<a href=\"https://zh.wikipedia.org/wiki/%E5%B8%B8%E6%85%8B%E5%88%86%E5%B8%83\" target=\"_blank\" rel=\"noopener\">正态分布</a>属于一种细尾分布，或<a href=\"https://zh.wikipedia.org/wiki/%E6%8C%87%E6%95%B0%E5%88%86%E5%B8%83\" target=\"_blank\" rel=\"noopener\">指数分布</a>。 </p>\n</blockquote>\n<h5 id=\"Plot-two-histograms-together-合并绘制两个直方图\"><a href=\"#Plot-two-histograms-together-合并绘制两个直方图\" class=\"headerlink\" title=\"Plot two histograms together (合并绘制两个直方图)\"></a>Plot two histograms together (合并绘制两个直方图)</h5><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"><span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd</span><br><span class=\"line\"><span class=\"keyword\">from</span> finance_datareader_py.eastmoney.daily <span class=\"keyword\">import</span> EastMoneyDailyReader</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">compute_daily_returns</span><span class=\"params\">(df)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> df[:<span class=\"number\">-1</span>].values / df[<span class=\"number\">1</span>:] - <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">df = pd.DataFrame()</span><br><span class=\"line\">df[<span class=\"string\">'601398'</span>] = EastMoneyDailyReader(<span class=\"string\">'601398'</span>).read()[<span class=\"string\">'Close'</span>]</span><br><span class=\"line\">df[<span class=\"string\">'601939'</span>] = EastMoneyDailyReader(<span class=\"string\">'601939'</span>).read()[<span class=\"string\">'Close'</span>]</span><br><span class=\"line\"><span class=\"comment\"># 计算日收益率</span></span><br><span class=\"line\">daily_returns = compute_daily_returns(df)</span><br><span class=\"line\"><span class=\"comment\"># 绘制直方图</span></span><br><span class=\"line\">daily_returns.hist()</span><br><span class=\"line\"><span class=\"comment\"># 绘图</span></span><br><span class=\"line\">plt.show()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 合并绘制两个直方图</span></span><br><span class=\"line\">daily_returns[<span class=\"string\">'601398'</span>].hist(label=<span class=\"string\">'601398'</span>)</span><br><span class=\"line\">daily_returns[<span class=\"string\">'601939'</span>].hist(label=<span class=\"string\">'601939'</span>)</span><br><span class=\"line\">plt.legend(loc=<span class=\"string\">'upper right'</span>)</span><br><span class=\"line\">plt.show()</span><br></pre></td></tr></table></figure>\n<p><img src=\"1532508260900.png\" alt=\"1532508260900\"></p>\n<p><img src=\"1532508276951.png\" alt=\"1532508276951\"></p>\n<p>股票和市场的日收益分布和高斯分布非常相似。这个性质对 <em>日收益、月收益、年收益</em> 来说同样适用。</p>\n<p>如果它们真的是高斯分布，那么我们就可以说它们是正态分布。</p>\n<p><strong>但是假定收益是正态分布的，却是非常危险的。因为它忽略了峰度或者尾部。</strong> <em>正是因为这样才造成了08年的金融风暴。</em></p>\n<h4 id=\"Scatterplots-散点图\"><a href=\"#Scatterplots-散点图\" class=\"headerlink\" title=\"Scatterplots (散点图)\"></a>Scatterplots (散点图)</h4><p>这是区分各支股票日收益的另一种方法。</p>\n<p>线性但离散的特点。</p>\n<blockquote><p>贝他值（ $\\beta$ 值）：<br>用以衡量基金之市场风险，或称系统性风险。其计算的方式为以过去12个月或24个月之基金月报酬率对同期市场月报酬率做回归，估计斜率系数而得，当 $\\beta$ &gt;1（$\\beta$ &lt; -1），表示基金坡动度较指数为大，当指数上扬 10%（下跌10%），基金会上扬超过 10%（下跌超过10%）；当 $\\beta$ = 1，表示指数涨跌多少，基金就跟着变动多少。</p>\n<footer><strong>Beta系数</strong><cite><a href=\"https://zh.wikipedia.org/wiki/Beta%E7%B3%BB%E6%95%B0\" target=\"_blank\" rel=\"noopener\">zh.wikipedia.org/wiki/Beta%E7%B3%BB%E6%95%B0</a></cite></footer></blockquote>\n<blockquote><p>阿尔法系数（ $\\alpha$）是基金的实际收益和按照β系数计算的期望收益之间的差额。其计算方法如下：超额收益是基金的收益减去无风险投资收益（在中国为1年期银行定期存款收益）；期望收益是贝塔系数 $\\beta$ 和市场收益的乘积，反映基金由于市场整体变动而获得的收益；超额收益和期望收益的差额即 $\\alpha$ 系数。该系数越大越好。</p>\n<footer><strong>阿尔法系数</strong><cite><a href=\"https://zh.wikipedia.org/wiki/%E8%AF%81%E5%88%B8%E6%8A%95%E8%B5%84%E5%9F%BA%E9%87%91#%E9%98%BF%E5%B0%94%E6%B3%95%E7%B3%BB%E6%95%B0\" target=\"_blank\" rel=\"noopener\">zh.wikipedia.org/wiki/%E8%AF%81%E5%88%B8%E6%8A%95%E8%B5%84%E5%9F%BA%E9%87%91#%E9%98%BF%E5%B0%94%E6%B3%95%E7%B3%BB%E6%95%B0</a></cite></footer></blockquote>\n<h5 id=\"Slope-does-not-equal-correlation-斜率-beta-系数与数据的相关性-拟合度无关\"><a href=\"#Slope-does-not-equal-correlation-斜率-beta-系数与数据的相关性-拟合度无关\" class=\"headerlink\" title=\"Slope does not equal correlation (斜率 $\\beta$ 系数与数据的相关性/拟合度无关)\"></a>Slope does not equal correlation (斜率 $\\beta$ 系数与数据的相关性/拟合度无关)</h5><p>可能有很低的斜率，但是数据拟合度非常高。反之亦然。</p>\n<h5 id=\"Scatterplots-in-python-散点图\"><a href=\"#Scatterplots-in-python-散点图\" class=\"headerlink\" title=\"Scatterplots in python (散点图)\"></a>Scatterplots in python (散点图)</h5><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">df = pd.DataFrame()</span><br><span class=\"line\">df[<span class=\"string\">'000300'</span>] = SohuDailyReader(<span class=\"string\">'000300'</span>, prefix=<span class=\"string\">'zs_'</span>).read()[<span class=\"string\">'Close'</span>]</span><br><span class=\"line\">df[<span class=\"string\">'601398'</span>] = SohuDailyReader(<span class=\"string\">'601398'</span>).read()[<span class=\"string\">'Close'</span>]</span><br><span class=\"line\">df[<span class=\"string\">'601939'</span>] = SohuDailyReader(<span class=\"string\">'601939'</span>).read()[<span class=\"string\">'Close'</span>]</span><br><span class=\"line\"><span class=\"comment\"># 计算日收益率</span></span><br><span class=\"line\">daily_returns = compute_daily_returns(df)</span><br><span class=\"line\"><span class=\"comment\"># 绘制 601398 相对于 000300 的散点图</span></span><br><span class=\"line\">daily_returns.plot(kind=<span class=\"string\">'scatter'</span>, x=<span class=\"string\">'000300'</span>, y=<span class=\"string\">'601398'</span>)</span><br><span class=\"line\">plt.show()</span><br><span class=\"line\"><span class=\"comment\"># 绘制 601939 相对于 000300 的散点图</span></span><br><span class=\"line\">daily_returns.plot(kind=<span class=\"string\">'scatter'</span>, x=<span class=\"string\">'000300'</span>, y=<span class=\"string\">'601939'</span>)</span><br><span class=\"line\">plt.show()</span><br></pre></td></tr></table></figure>\n<p><img src=\"1532570705884.png\" alt=\"1532570705884\"></p>\n<p><img src=\"1532570720355.png\" alt=\"1532570720355\"></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># beta系数和alpha系数</span></span><br><span class=\"line\">beta, alpha = np.polyfit(daily_returns[<span class=\"string\">'000300'</span>], daily_returns[<span class=\"string\">'601939'</span>], <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">daily_returns.plot(kind=<span class=\"string\">'scatter'</span>, x=<span class=\"string\">'000300'</span>, y=<span class=\"string\">'601939'</span>)</span><br><span class=\"line\"><span class=\"comment\"># 绘制拟合线</span></span><br><span class=\"line\">plt.plot(daily_returns[<span class=\"string\">'000300'</span>], beta * daily_returns[<span class=\"string\">'000300'</span>] + alpha, <span class=\"string\">'-'</span>,</span><br><span class=\"line\">         color=<span class=\"string\">'r'</span>)</span><br><span class=\"line\">plt.show()</span><br><span class=\"line\">print(<span class=\"string\">'beta='</span> + str(beta))</span><br><span class=\"line\">print(<span class=\"string\">'alpha='</span> + str(alpha))</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">beta=0.590256550806</span><br><span class=\"line\">alpha=-0.000246730309092</span><br></pre></td></tr></table></figure>\n<p><img src=\"1532571574686.png\" alt=\"1532571574686\"></p>\n<h3 id=\"投资组合\"><a href=\"#投资组合\" class=\"headerlink\" title=\"投资组合\"></a>投资组合</h3><h4 id=\"Daily-portfolio-values\"><a href=\"#Daily-portfolio-values\" class=\"headerlink\" title=\"Daily portfolio values\"></a>Daily portfolio values</h4><p><a href=\"https://youtu.be/UweF-2-Tr9Y\" target=\"_blank\" rel=\"noopener\">https://youtu.be/UweF-2-Tr9Y</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">投资组合假设：</span><br><span class=\"line\">start_val = 1000000 # 初始投资总额</span><br><span class=\"line\">start_date = 2011-01-01 # 初始投资日期</span><br><span class=\"line\">end_date = 2011-12-31 # 结束投资日期</span><br><span class=\"line\"># 投资组合：贵州茅台、中国平安、招商银行、格力电器</span><br><span class=\"line\">symbols = [&apos;600519&apos;,&apos;601318&apos;,&apos;600036&apos;,&apos;000651&apos;] </span><br><span class=\"line\"># 比率分配</span><br><span class=\"line\">allocs = [0.4,0.4,0.1,0.1]</span><br></pre></td></tr></table></figure>\n<h4 id=\"如何计算投资组合每日的总价值\"><a href=\"#如何计算投资组合每日的总价值\" class=\"headerlink\" title=\"如何计算投资组合每日的总价值\"></a>如何计算投资组合每日的总价值</h4><p><a href=\"https://youtu.be/UweF-2-Tr9Y\" target=\"_blank\" rel=\"noopener\">https://youtu.be/UweF-2-Tr9Y</a></p>\n<ol>\n<li>从价格 <code>DataFrame</code> 开始。</li>\n<li>价格归一化（<code>normed=prices/prices[0]</code>）。开始日期的数据始终为1.0。</li>\n<li>使用归一化以后的值乘以每支股票分配的资金比例（<code>alloced=normed*allocs</code>）。</li>\n<li>使用初始投资总额乘以3的结果（<code>pos_vals=alloced*start_val</code>）</li>\n<li>每一天的总价值：<code>port_val=pos_vals.sum(axis=1)</code></li>\n</ol>\n<p><img src=\"1532675498707.png\" alt=\"1532675498707\"></p>\n<p>计算后的每日收益的第一天的收益始终为 <em>0</em>，所以应该去除。 <code>daily_returns=daily_returns[1:]</code> </p>\n<p>有了每日收益之后可以计算很多有趣的数据。<strong>评估投资组合时的常用数据</strong>：</p>\n<ul>\n<li><code>cum_ret</code> 累计收益 <code>(port_val[-1]/port_val[0])-1</code></li>\n<li><code>avg_daily_ret</code> 平均收益 <code>daily_rets.mean()</code></li>\n<li><code>std_daily_ret</code> 每日收益标准差 <code>daily_rets.std()</code></li>\n<li><code>sharpe_ratio</code> 夏普比率</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> datetime</span><br><span class=\"line\"><span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd</span><br><span class=\"line\"><span class=\"keyword\">from</span> finance_datareader_py.sohu.daily <span class=\"keyword\">import</span> SohuDailyReader</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">compute_daily_returns</span><span class=\"params\">(df)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> df[:<span class=\"number\">-1</span>].values / df[<span class=\"number\">1</span>:] - <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">SYMBOLS = [<span class=\"string\">'600519'</span>, <span class=\"string\">'601318'</span>, <span class=\"string\">'600036'</span>, <span class=\"string\">'000651'</span>]</span><br><span class=\"line\">ALLOCS = [<span class=\"number\">0.4</span>, <span class=\"number\">0.4</span>, <span class=\"number\">0.1</span>, <span class=\"number\">0.1</span>]</span><br><span class=\"line\">START = datetime.date(<span class=\"number\">2009</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">END = datetime.date(<span class=\"number\">2011</span>, <span class=\"number\">12</span>, <span class=\"number\">31</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_datas</span><span class=\"params\">(symbols, start, end)</span>:</span></span><br><span class=\"line\">    df = pd.DataFrame()</span><br><span class=\"line\">    df[<span class=\"string\">'000300'</span>] = SohuDailyReader(<span class=\"string\">'000300'</span>, prefix=<span class=\"string\">'zs_'</span>, start=start,</span><br><span class=\"line\">                                   end=end).read()[<span class=\"string\">'Close'</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> symbol <span class=\"keyword\">in</span> symbols:</span><br><span class=\"line\">        df1 = SohuDailyReader(symbol, start=start, end=end).read()</span><br><span class=\"line\">        df1 = df1.rename(columns=&#123;<span class=\"string\">'Close'</span>: symbol&#125;)</span><br><span class=\"line\">        df = df.join(df1[symbol])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> df.fillna(method=<span class=\"string\">'bfill'</span>)  <span class=\"comment\"># 因为是倒序排序，所以使用bfill</span></span><br><span class=\"line\"></span><br><span class=\"line\">df = get_datas(SYMBOLS, START, END)</span><br><span class=\"line\">df_ret = compute_daily_returns(df)</span><br><span class=\"line\">print(df)</span><br><span class=\"line\">print(df_ret)</span><br><span class=\"line\">print(<span class=\"string\">'-----------------'</span>)</span><br><span class=\"line\">print(<span class=\"string\">'平均收益:'</span>)</span><br><span class=\"line\">print(df_ret.mean())</span><br><span class=\"line\">print(<span class=\"string\">'-----------------'</span>)</span><br><span class=\"line\">print(<span class=\"string\">'每日收益标准差:'</span>)</span><br><span class=\"line\">print(df_ret.std())</span><br><span class=\"line\">print(<span class=\"string\">'-----------------'</span>)</span><br><span class=\"line\">print(<span class=\"string\">'累计收益:'</span>)</span><br><span class=\"line\">print(df.iloc[<span class=\"number\">0</span>] / df.iloc[<span class=\"number\">-1</span>] - <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 移除指数列，并按照比率分配</span></span><br><span class=\"line\">alloced = df_nor.copy().drop(<span class=\"string\">'000300'</span>, axis=<span class=\"number\">1</span>) * ALLOCS</span><br><span class=\"line\"><span class=\"comment\"># 按照比率分配后的各支股票的每日价值</span></span><br><span class=\"line\">pos_vals = alloced * START_VALS</span><br><span class=\"line\"><span class=\"comment\"># 投资组合的每日价值</span></span><br><span class=\"line\">port_val = pos_vals.sum(axis=<span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">-----------------</span><br><span class=\"line\">平均收益:</span><br><span class=\"line\">000300    0.000443</span><br><span class=\"line\">600519    0.000973</span><br><span class=\"line\">601318    0.000508</span><br><span class=\"line\">600036    0.000162</span><br><span class=\"line\">000651    0.000445</span><br><span class=\"line\">dtype: float64</span><br><span class=\"line\">-----------------</span><br><span class=\"line\">每日收益标准差:</span><br><span class=\"line\">000300    0.016803</span><br><span class=\"line\">600519    0.018983</span><br><span class=\"line\">601318    0.023065</span><br><span class=\"line\">600036    0.021895</span><br><span class=\"line\">000651    0.031399</span><br><span class=\"line\">dtype: float64</span><br><span class=\"line\">-----------------</span><br><span class=\"line\">累计收益:</span><br><span class=\"line\">000300    0.245773</span><br><span class=\"line\">600519    0.783539</span><br><span class=\"line\">601318    0.193761</span><br><span class=\"line\">600036   -0.057188</span><br><span class=\"line\">000651   -0.074906</span><br><span class=\"line\">dtype: float64</span><br></pre></td></tr></table></figure>\n<h4 id=\"Sharpe-ratio-夏普比率\"><a href=\"#Sharpe-ratio-夏普比率\" class=\"headerlink\" title=\"Sharpe ratio (夏普比率)\"></a>Sharpe ratio (夏普比率)</h4><p><a href=\"https://youtu.be/5cqstpRndtI\" target=\"_blank\" rel=\"noopener\">https://youtu.be/5cqstpRndtI</a></p>\n<blockquote><p>　　现代投资理论的研究表明,风险的大小在决定组合的表现上具有基础性的作用。风险调整后的收益率就是一个可以同时对收益与风险加以考虑的综合指标,以期能够排除风险因素对绩效评估的不利影响。夏普比率就是一个可以同时对收益与风险加以综合考虑的三大经典指标之一。</p>\n<p>　　投资中有一个常规的特点，即投资标的的预期报酬越高，投资人所能忍受的波动风险越高；反之，预期报酬越低，波动风险也越低。所以理性的投资人选择投资标的与投资组合的主要目的为：在固定所能承受的风险下，追求最大的报酬；或在固定的预期报酬下，追求最低的风险。</p>\n<p>　　夏普比率计算公式：＝[E(Rp)－Rf]/σp</p>\n<p>　　其中E(Rp)：投资组合预期报酬率</p>\n<p>　　Rf：无风险利率</p>\n<p>　　σp：投资组合的标准差</p>\n<p>　　目的是计算投资组合每承受一单位总风险，会产生多少的超额报酬。比率依据资本市场线(Capital Market Line,CML)的观念而来，是市场上最常见的衡量比率。当投资组合内的资产皆为风险性资产时，适用夏普比率。夏普指数代表投资人每多承担一分风险，可以拿到几分报酬；若为正值，代表基金报酬率高过波动风险；若为负值，代表基金操作风险大过于报酬率。这样一来，每个投资组合都可以计算Sharpe Ratio,即投资回报与多冒风险的比例，这个比例越高，投资组合越佳。</p>\n<p>　　举例而言，假如国债的回报是3%，而您的投资组合预期回报是15%，您的投资组合的标准偏差是6%，那么用15%－3%,可以得出12%（代表您超出无风险投资的回报），再用12%÷6%＝2，代表投资者风险每增长1%，换来的是2%的多余收益。</p>\n<footer><strong>夏普比率</strong><cite><a href=\"http://wiki.mbalib.com/wiki/%E5%A4%8F%E6%99%AE%E6%AF%94%E7%8E%87\" target=\"_blank\" rel=\"noopener\">wiki.mbalib.com/wiki/%E5%A4%8F%E6%99%AE%E6%AF%94%E7%8E%87</a></cite></footer></blockquote>\n<h5 id=\"以下计算夏普比率的公式使用：\"><a href=\"#以下计算夏普比率的公式使用：\" class=\"headerlink\" title=\"以下计算夏普比率的公式使用：\"></a>以下计算夏普比率的公式使用：</h5><p><code>日收益 减去 日化无风险收益率 的均值 / 日收益 减去 日化无风险收益率 的标准差</code></p>\n<p><code>S = mean(daily_rets - daily_rf) / std(daily_rets - daily_rf)</code></p>\n<p>什么是日化无风险收益率？视频中采用了 <em>伦敦银行同业拆放利率、3月期国债利率、0%</em>。</p>\n<p>如何计算日化收益率？假设年收益为10%，每年有252个交易日。那么日收益率：</p>\n<p>daily_rf = $\\sqrt[252]{1.0+0.1}-1$</p>\n<p>将 daily_rf 视为一个常数时（和将常数视作0的效果一样），可以将计算公式改为：</p>\n<p><code>S = mean(daily_rets - daily_rf) / std(daily_rets)</code></p>\n<blockquote>\n<p>夏普比率对于相同资产可以有相当大的变化。<strong>取决于采样的频繁度</strong></p>\n<p>如果每年采样股票价格，并且基于年化统计量计算，会得到一个数字；如果每月采样，会得到不同的数字；如果改成每日采样，又会得到另一个数字。</p>\n<p><strong>最初版本的夏普比率是一个年化的测量值。所以如果需要以非年化的采样来计算，那么需要加上一个调整因子来使其正常工作。</strong></p>\n<p><code>SRannualized = K * SR</code></p>\n<p>调整因子（K）是每年的采样数量值的平方根。</p>\n<p>假设使用的是每日采样，一年共有252个交易日。daily K = $\\sqrt{252}$</p>\n<p>假设使用的是每周采样，一年共有52个交易周。daily K = $\\sqrt{52}$</p>\n<p>假设使用的是每月采样，一年共有12个交易月。daily K = $\\sqrt{12}$</p>\n<p><strong>即便某支股票一年只交易了80天，在以每日采样计算调整因子时，还是应该是用252来进行计算</strong></p>\n</blockquote>\n<h4 id=\"What-is-an-optimizer（优化器）\"><a href=\"#What-is-an-optimizer（优化器）\" class=\"headerlink\" title=\"What is an optimizer（优化器）\"></a>What is an optimizer（优化器）</h4><ul>\n<li>用来寻找函数最小值</li>\n<li>从数据中查找并建立参数化模型（从实验数据中找到一个多项式来拟合实验数据）</li>\n<li>使用优化器来改善股票投资组合中的分配方式</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> scipy.optimize <span class=\"keyword\">as</span> spo</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span><span class=\"params\">(X)</span>:</span></span><br><span class=\"line\">    Y = (X - <span class=\"number\">1.5</span>) ** <span class=\"number\">2</span> + <span class=\"number\">0.5</span></span><br><span class=\"line\">    print(<span class=\"string\">\"X=&#123;0&#125;,Y=&#123;1&#125;\"</span>.format(X, Y))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Y</span><br><span class=\"line\"></span><br><span class=\"line\">Xguess = <span class=\"number\">2.0</span></span><br><span class=\"line\">min_result = spo.minimize(f, Xguess, method=<span class=\"string\">'SLSQP'</span>, options=&#123;<span class=\"string\">'disp'</span>: <span class=\"keyword\">True</span>&#125;)</span><br><span class=\"line\">print(<span class=\"string\">'Minima found at:'</span>)</span><br><span class=\"line\">print(<span class=\"string\">\"X=&#123;0&#125;,Y=&#123;1&#125;\"</span>.format(min_result.x, min_result.fun))</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">X=[ 2.],Y=[ 0.75]</span><br><span class=\"line\">X=[ 2.],Y=[ 0.75]</span><br><span class=\"line\">X=[ 2.00000001],Y=[ 0.75000001]</span><br><span class=\"line\">X=[ 0.99999999],Y=[ 0.75000001]</span><br><span class=\"line\">X=[ 1.5],Y=[ 0.5]</span><br><span class=\"line\">X=[ 1.5],Y=[ 0.5]</span><br><span class=\"line\">X=[ 1.50000001],Y=[ 0.5]</span><br><span class=\"line\">Optimization terminated successfully.    (Exit mode 0)</span><br><span class=\"line\">            Current function value: 0.5</span><br><span class=\"line\">            Iterations: 2</span><br><span class=\"line\">            Function evaluations: 7</span><br><span class=\"line\">            Gradient evaluations: 2</span><br><span class=\"line\">Minima found at:</span><br><span class=\"line\">X=[ 1.5],Y=0.5</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">Xplot = np.linspace(<span class=\"number\">0.5</span>, <span class=\"number\">2.5</span>, <span class=\"number\">21</span>)</span><br><span class=\"line\">Yplot = f(Xplot)</span><br><span class=\"line\">plt.plot(Xplot, Yplot)</span><br><span class=\"line\">plt.plot(min_result.x, min_result.fun, <span class=\"string\">'ro'</span>)</span><br><span class=\"line\">plt.title(<span class=\"string\">'Minima of an objective function'</span>)</span><br><span class=\"line\">plt.show()</span><br></pre></td></tr></table></figure>\n<p><img src=\"1532660052844.png\" alt=\"1532659982849\"></p>\n<h4 id=\"Convex-Problems-凸问题\"><a href=\"#Convex-Problems-凸问题\" class=\"headerlink\" title=\"Convex Problems (凸问题)\"></a>Convex Problems (凸问题)</h4><p><strong>凸集必定有局部最小值，同时这个局部最小值也就是全局最小值。</strong></p>\n<h4 id=\"构建参数化模型\"><a href=\"#构建参数化模型\" class=\"headerlink\" title=\"构建参数化模型\"></a>构建参数化模型</h4><p>什么是参数化模型？<code>f(x) = mx+b</code>这是个关于 x 的函数，它有两个参数 m 和 b。</p>\n<p>优化器就是通过不断的修改参数值并迭代函数，来找到函数的最优解。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_portfoilo</span><span class=\"params\">(symbols, start, end, allocs, start_values)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"获取投资组合与沪深300指数的收益比较</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    :param symbols: 投资组合</span></span><br><span class=\"line\"><span class=\"string\">    :param start: 开始日期</span></span><br><span class=\"line\"><span class=\"string\">    :param end: 结束日期</span></span><br><span class=\"line\"><span class=\"string\">    :param allocs: 投资组合比率</span></span><br><span class=\"line\"><span class=\"string\">    :param start_values: 初始总投资额</span></span><br><span class=\"line\"><span class=\"string\">    :return:</span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\">    df = get_datas(symbols, start, end)</span><br><span class=\"line\">    normed = normalization(df)</span><br><span class=\"line\">    alloced = normed.copy().drop(<span class=\"string\">'000300'</span>, axis=<span class=\"number\">1</span>) * allocs</span><br><span class=\"line\">    pos_vals = alloced * start_values</span><br><span class=\"line\">    port_val = pos_vals.sum(axis=<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> normalization(pd.DataFrame(port_val.copy(),</span><br><span class=\"line\">                                      columns=[<span class=\"string\">'Portfoilo'</span>]).join(df[<span class=\"string\">'000300'</span>]))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 投资组合一年的表现与沪深300指数的比较</span></span><br><span class=\"line\">portpoilo = get_portfoilo(SYMBOLS, START, END, ALLOCS, START_VALS)</span><br><span class=\"line\">portpoilo.show()</span><br><span class=\"line\">plt.grid()</span><br><span class=\"line\">plt.show()</span><br></pre></td></tr></table></figure>\n<p><img src=\"1532677939302.png\" alt=\"1532677809156\"></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 修改投资比率</span></span><br><span class=\"line\">portpoilo = get_portfoilo(SYMBOLS, START, END, [<span class=\"number\">0.5</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0.5</span>], START_VALS)</span><br><span class=\"line\">portpoilo.plot()</span><br><span class=\"line\">plt.grid()</span><br><span class=\"line\">plt.show()</span><br></pre></td></tr></table></figure>\n<p><img src=\"1532678552063.png\" alt=\"1532678552063\"></p>\n<p>优化器的作用就在于确定如何找到最优的投资比率和股票组合。</p>\n<h3 id=\"Types-of-funds（基金类型）\"><a href=\"#Types-of-funds（基金类型）\" class=\"headerlink\" title=\"Types of funds（基金类型）\"></a>Types of funds（基金类型）</h3><ul>\n<li>ETF <a href=\"https://zh.wikipedia.org/wiki/ETF\" target=\"_blank\" rel=\"noopener\">交易所交易基金、交易所买卖基金</a></li>\n<li>Mutual Fund <a href=\"https://zh.wikipedia.org/wiki/%E5%85%B1%E5%90%8C%E5%9F%BA%E9%87%91\" target=\"_blank\" rel=\"noopener\">共同基金</a></li>\n<li>Hedge Fund <a href=\"https://zh.wikipedia.org/wiki/%E5%AF%B9%E5%86%B2%E5%9F%BA%E9%87%91\" target=\"_blank\" rel=\"noopener\">对冲基金</a></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th><strong>Parameter</strong></th>\n<th><strong>Hedge Fund</strong></th>\n<th><strong>Mutual Fund</strong></th>\n<th><strong>ETF</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>Return</strong></td>\n<td><em>Absolute return</em></td>\n<td><em>Relative return</em></td>\n<td><em>Relative return</em></td>\n</tr>\n<tr>\n<td><strong>Management</strong></td>\n<td><em>Actively managed</em></td>\n<td><em>Comparatively less actively managed</em></td>\n<td><em>Passively managed</em></td>\n</tr>\n<tr>\n<td><strong>Fees</strong></td>\n<td><em>Performance based fee</em></td>\n<td><em>Percentage of assets managed fees</em></td>\n<td><em>–</em></td>\n</tr>\n<tr>\n<td><strong>Transaction Price</strong></td>\n<td><em>–</em></td>\n<td><em>NAV</em></td>\n<td><em>Quoted price</em></td>\n</tr>\n<tr>\n<td><strong>Transparency</strong></td>\n<td><em>Information disclosed to investors only</em></td>\n<td><em>Annually published reports and disclosure</em></td>\n<td><em>Daily disclosure of holdings</em></td>\n</tr>\n<tr>\n<td><strong>Regulation</strong></td>\n<td><em>Less regulation</em></td>\n<td><em>Regulated by SEBI</em></td>\n<td><em>Regulated by Securities and Exchange Commission</em></td>\n</tr>\n<tr>\n<td><strong>Liquidity</strong></td>\n<td><em>Low</em></td>\n<td><em>High</em></td>\n<td><em>High</em></td>\n</tr>\n<tr>\n<td><strong>Cost</strong></td>\n<td><em>–</em></td>\n<td><em>High average expense ratio</em></td>\n<td><em>Low average expense ratio</em></td>\n</tr>\n<tr>\n<td><strong>Investor Type</strong></td>\n<td><em>High net worth individuals</em></td>\n<td><em>Retail investors</em></td>\n<td><em>Retail investors</em></td>\n</tr>\n<tr>\n<td><strong>Fractional Shares</strong></td>\n<td><em>No</em></td>\n<td><em>Yes</em></td>\n<td><em>No</em></td>\n</tr>\n<tr>\n<td><strong>Ownership of Fund Manager</strong></td>\n<td><em>Substantial ownership</em></td>\n<td><em>Non substantial ownership</em></td>\n<td><em>–</em></td>\n</tr>\n<tr>\n<td><strong>Owners</strong></td>\n<td><em>Few owners</em></td>\n<td><em>Many owners</em></td>\n<td><em>–</em></td>\n</tr>\n<tr>\n<td><strong>Minimum amount to be invested</strong></td>\n<td><em>High</em></td>\n<td><em>Low</em></td>\n<td><em>Low</em></td>\n</tr>\n<tr>\n<td><strong>Tax</strong></td>\n<td><em>–</em></td>\n<td><em>High percentage of tax levied on capital gains</em></td>\n<td><em>Comparatively lower tax percentages are levied</em></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"如何计算估值\"><a href=\"#如何计算估值\" class=\"headerlink\" title=\"如何计算估值\"></a>如何计算估值</h3><blockquote><p>金钱的未来终值（future value）应大于现值（present value）</p>\n<footer><strong>金钱的时间价值</strong><cite><a href=\"https://zh.wikipedia.org/wiki/%E9%87%91%E9%8C%A2%E7%9A%84%E6%99%82%E9%96%93%E5%83%B9%E5%80%BC\" target=\"_blank\" rel=\"noopener\">zh.wikipedia.org/wiki/%E9%87%91%E9%8C%A2%E7%9A%84%E6%99%82%E9%96%93%E5%83%B9%E5%80%BC</a></cite></footer></blockquote>\n<p><strong>计算:</strong></p>\n<p>假设某人以利率 $i$ （$i=5\\%$与$i=0.05$等同）借出或借入一笔款项，期限为 $t$ 年，则 $t$ 年后的 $C$ 个货币单位现值表达为：$C_{t}=\\frac{C}{(1+i)^{t}}$</p>\n<p>$t$ 年后的 $C$ 个莫比单位现时购买力也可以用上式计算，此时 $i$ 表示 <em>通货膨胀率</em>。</p>\n<p>同一组现金流可能根据利率的不同被分为数个时段，例如，从此时算起的第一年内的利率为 $i_1$ ，第二年的利率为 $i_2$ ，那么两年后的 $C$ 个货币单位的现值表达式为：$PV=\\frac{C}{(1+i_1)(1+i_2)}$</p>\n<ul>\n<li><strong>内在价值</strong></li>\n<li><strong>账面价值</strong>：$总资产-无形资产-负债$</li>\n<li><strong>市值</strong></li>\n</ul>\n<h3 id=\"资本资产定价模型-（CAPM）\"><a href=\"#资本资产定价模型-（CAPM）\" class=\"headerlink\" title=\"资本资产定价模型 （CAPM）\"></a>资本资产定价模型 （CAPM）</h3><blockquote><p>资本资产定价模型（英语：Capital Asset Pricing Model, CAPM）是由美国学者威廉·夏普（William Sharpe）、林特尔（John Lintner）、特里诺（Jack Treynor）和莫辛（Jan Mossin）等人在现代投资组合理论的基础上发展起来的，是现代金融市场价格理论的支柱，广泛应用于投资决策和公司理财领域。资本资产定价模型中，所谓资本资产主要指的是股票资产，而定价则试图解释资本市场如何决定股票收益率，进而决定股票价格。</p>\n<p>根据资本资产定价模型，对于一个给定的资产 $i$，它的期望收益率和市场投资组合的期望收益率之间的关系可以表示为：</p>\n<p>$E(r_i)=r_f+\\beta_im[E(r_m)-r_f]]$</p>\n<p>其中：</p>\n<ul>\n<li>$E(r_i)$是资产 $i$ 的期望收益率（或普通股的资本成本率）</li>\n<li>$r_f$ 是无风险收益率，通常以短期国债的利率来近似替代</li>\n<li>$\\beta_{im}$ 是资产 $i$ 的系统性风险系数，$\\beta_{im}={\\frac{Cov(r_i,r_m)}{Var(r_m)}}$ </li>\n<li>$E(r_{m})$市场投资组合 $m$ 的期望收益率，通常用股票价格指数收益率的平均值或所有股票的平均收益率来代替</li>\n<li>$E(r_{m})-r_{f}$市场风险溢价（英语：Market Risk Premium），即市场投资组合的期望收益率与无风险收益率之差</li>\n</ul>\n<p>CAPM模型是建立在一系列假设的基础上的，其中主要包括：</p>\n<ul>\n<li>所有投资者均追求单期财富的期望效用最大化，并以各备选组合的期望收益和标准差为基础进行组合选择。</li>\n<li>所有投资者均可以无风险利率无限制地借入或贷出资金。</li>\n<li>所有投资者拥有同样预期，即对所有资产收益的均值、方差和协方差等，投资者均有完全相同的主观估计。</li>\n<li>所有资产均可被完全细分，拥有充分的流动性且没有交易成本。</li>\n</ul>\n<p>没有税金。</p>\n<ul>\n<li>所有投资者均为价格接受者。即任何一个投资者的买卖行为都不会对股票价格产生影响。</li>\n<li>所有资产的数量是给定的和固定不变的。</li>\n</ul>\n<p>近年的实证研究表明，CAPM模型在实际中并不能验证历史的投资收益，由此Roll在1977年提出了两种可能：一种是CAPM模型在市场上是无效的，一种是CAPM理论存在模型的设定误差；基于后一种可能，APT理论和不少多因子模型不断诞生——例如FAMA-FRENCH的三因子模型。但是由于CAPM的简单和便于理解，在业界运用非常广泛，特别是在估值分析中确定必要报酬率（英语：Required Return of Equity）。</p>\n<footer><strong>资本资产定价模型</strong><cite><a href=\"https://zh.wikipedia.org/wiki/%E8%B5%84%E6%9C%AC%E8%B5%84%E4%BA%A7%E5%AE%9A%E4%BB%B7%E6%A8%A1%E5%9E%8B\" target=\"_blank\" rel=\"noopener\">zh.wikipedia.org/wiki/%E8%B5%84%E6%9C%AC%E8%B5%84%E4%BA%A7%E5%AE%9A%E4%BB%B7%E6%A8%A1%E5%9E%8B</a></cite></footer></blockquote>\n<p><img src=\"1533869822902.png\" alt=\"1533869822902\"></p>\n<h3 id=\"套利定价理论（APT）\"><a href=\"#套利定价理论（APT）\" class=\"headerlink\" title=\"套利定价理论（APT）\"></a>套利定价理论（APT）</h3><p><a href=\"https://youtu.be/yMMoukwU87I\" target=\"_blank\" rel=\"noopener\">https://youtu.be/yMMoukwU87I</a></p>\n<p><a href=\"http://wiki.mbalib.com/wiki/%E5%A5%97%E5%88%A9%E5%AE%9A%E4%BB%B7%E7%90%86%E8%AE%BA\" target=\"_blank\" rel=\"noopener\">套利定价理论-MBAlib</a></p>\n<h3 id=\"技术分析\"><a href=\"#技术分析\" class=\"headerlink\" title=\"技术分析\"></a>技术分析</h3><h4 id=\"技术分析的特征\"><a href=\"#技术分析的特征\" class=\"headerlink\" title=\"技术分析的特征\"></a>技术分析的特征</h4><ul>\n<li>只关注历史价格和成交量</li>\n<li>在时间序列中计算统计数据称为指标</li>\n<li>指标是启发式的</li>\n</ul>\n<h4 id=\"使技术分析有价值的因素\"><a href=\"#使技术分析有价值的因素\" class=\"headerlink\" title=\"使技术分析有价值的因素\"></a>使技术分析有价值的因素</h4><ul>\n<li>个别指标具有弱预测性，但结合多个指标可以增加价值</li>\n<li>寻找对比（单个股票 VS 市场）（找到比市场收益更好的单个或组合）</li>\n<li>在短时间内比在较长时间内工作得更有效</li>\n</ul>\n<blockquote>\n<p>持有时间越长，价值分析越重要，需要作出判断的时间越长，判断复杂度越高。（更适合人类进行分析）</p>\n<p>反之，持有时间越短，技术分析越重要，需要作出判断的时间越短，判断复杂度越低。（更适合计算机做高频分析）</p>\n</blockquote>\n<p><img src=\"1533883675299.png\" alt=\"1533883675299\"></p>\n<h4 id=\"部分技术分析的指标\"><a href=\"#部分技术分析的指标\" class=\"headerlink\" title=\"部分技术分析的指标\"></a>部分技术分析的指标</h4><ul>\n<li><p>动量（momentum）</p>\n<blockquote><p>$MO_t=(P_t/P_{t-n})*100$<br>其中 $n$ 為天數，$P_t$ 為當日股價，$P_{t-n} $ 為  $n$ 日前的股價</p>\n<ol>\n<li>MO&gt;100时，表示目前股价行情较N日前偏多看待，相对该股票市场行情反应较为热络。</li>\n<li>MO&lt;100时，表示目前股价行情较N日前偏空看待，相对该股票行情市场反应较为冷淡。</li>\n<li>MO由正转负，表示目前股价行情已转为偏空看待，多方投资人需要注意。</li>\n<li>MO由负转正，表示目前股价行情已转为偏多看待，空方投资人需要注意。</li>\n</ol>\n<footer><strong>运动量震荡指标</strong><cite><a href=\"https://zh.wikipedia.org/wiki/%E9%81%8B%E5%8B%95%E9%87%8F%E9%9C%87%E7%9B%AA%E6%8C%87%E6%A8%99\" target=\"_blank\" rel=\"noopener\">zh.wikipedia.org/wiki/%E9%81%8B%E5%8B%95%E9%87%8F%E9%9C%87%E7%9B%AA%E6%8C%87%E6%A8%99</a></cite></footer></blockquote>\n</li>\n<li><p>移动平均线（SMA）</p>\n<blockquote>\n<ol>\n<li><p>寻找价格穿过简单移动平均线的点。</p>\n<p>momentum+SMA cross可能会是买入或卖出的指标。</p>\n</li>\n<li><p>可以将移动平均线看成是一个时间段上的公司价值。股价会在移动平均线上下波动。</p>\n</li>\n</ol>\n</blockquote>\n<p><img src=\"1533886709495.png\" alt=\"1533886709495\"></p>\n<blockquote><ul>\n<li><p><strong>简单移动平均</strong>（英语：simple moving average，SMA）是某变数之前 $n$ 个数值的未作加权算术平均。例如，收市价的10日简单移动平均指之前10日收市价的平均数。若设收市价为 $p_{1}$至 $p_{n}$，则方程式为：</p>\n<p>$SMA={p_{1}+p_{2}+\\cdots +p_{n} \\over n}$<br>当计算连续的数值，一个新的数值加入，同时一个旧数值剔出，所以无需每次都重新逐个数值加起来：</p>\n<p>$SMA_{t1,n}=SMA_{t0,n}-{p_{1} \\over n}+{p_{n+1} \\over n}$<br>在技术分析中，不同的市场对常用天数（$n$值）有不同的需求，例如：某些市场普遍的$n$值为10日、40日、200日；有些则是5日、10日、20日、60日、120日、240日，视乎分析时期长短而定。投资者冀从移动平均线的图表中分辨出支持位或阻力位。</p>\n</li>\n<li><p><strong>指数移动平均</strong>（英语：exponential moving average，EMA或EWMA）是以指数式递减加权的移动平均。各数值的加权影响力随时间而指数式递减，越近期的数据加权影响力越重，但较旧的数据也给予一定的加权值。右图是一例子。</p>\n<p>加权的程度以常数 $α$ 决定，$α$ 数值介乎0至1。$α$ 也可用天数 $N$ 来代表： $\\alpha ={2 \\over {N+1}}$，所以，$N$=19天，代表$α=0.1$。</p>\n<p>设时间 $t$ 的实际数值为$Y_t$，而时间 $t$ 的EMA则为$S_t$；时间 $t-1$ 的EMA则为$S_{t-1}$，计算时间 $t≥2$ 是方程式为：</p>\n<p>$S_{t}=\\alpha <em> Y_{t}+(1-\\alpha )</em> S_{t-1}$<br>设今日（$t1$）价格为 $p$，则今日（$t1$）EMA的方程式为：</p>\n<p>$EMA_{t1}={\\text{EMA}}<em>{t0}+\\alpha \\times (p-{\\text{EMA}}</em>{t0})$<br>将 ${\\text{EMA}}_{t0}$分拆开来如下：</p>\n<p>${\\text{EMA}}={p_{1}+(1-\\alpha )p_{2}+(1-\\alpha )^{2}p_{3}+(1-\\alpha )^{3}p_{4}+\\cdots \\over 1+(1-\\alpha )+(1-\\alpha )^{2}+(1-\\alpha )^{3}+\\cdots }$<br>理论上这是一个无穷级数，但由于 $1-α$ 少于1，各项的数值会越来越细，可以被忽略。分母方面，若有足够多项，则其数值趋向 $1/α$。即，</p>\n<p>${\\text{EMA}}=\\alpha \\times \\left(p_{1}+(1-\\alpha )p_{2}+(1-\\alpha )^{2}p_{3}+(1-\\alpha )^{3}p_{4}+\\cdots \\right)$<br>假设 $k$ 项及以后的项被忽略，即 $\\alpha \\times \\left((1-\\alpha )^{k}+(1-\\alpha )^{k+1}+\\cdots \\right)$，重写后可得$\\alpha \\times (1-\\alpha )^{k}\\times \\left(1+(1-\\alpha )+(1-\\alpha )^{2}\\cdots \\right)$，相当于 $(1-\\alpha )^{k}$。所以，若要包含99.9%的加权，解方程 $k={\\log(0.001) \\over \\log(1-\\alpha )}$即可得出$k$。由于当$N$不断增加， $\\log \\,(1-\\alpha )$将趋向 $-2 \\over N+1$，简化后k大约等于 $3.45\\times (N+1)$。</p>\n</li>\n<li><p><strong>加权移动平均</strong>（英语：weighted moving average，WMA）指计算平均值时将个别数据乘以不同数值，在技术分析中，$n$日WMA的最近期一个数值乘以$n$、次近的乘以$n-1$，如此类推，一直到0：</p>\n<p>$WMA_{M}={np_{M}+(n-1)p_{M-1}+\\cdots +2p_{M-n+2}+p_{M-n+1} \\over n+(n-1)+\\cdots +2+1}$</p>\n<p>由于 $WMA_{M+1}$与 $WMA_{M}$的分子相差 $np_{M+1}-p_{M}-\\cdots -p_{M-n+1}$，假设 $p_{M}+p_{M-1}+\\cdots +p_{M-n+1}$为总和$M$：</p>\n<p>$总和<em>{M+1} =总和</em>{M}+p_{M+1}-p_{M-n+1}$<br>$分子<em>{M+1}=N</em>{M+1}=分子<em>M+np</em>{M+1}-总和<em>M$<br>$WMA</em>{M+1}={N_{M+1} \\over n+(n-1)+\\cdots +2+1}$<br>留意分母为三角形数，方程式为 $n(n+1) \\over 2$</p>\n<p>右图显示出加权是随日子远离而递减，直至递减至零。</p>\n</li>\n</ul>\n<footer><strong>移动平均</strong><cite><a href=\"https://zh.wikipedia.org/wiki/%E7%A7%BB%E5%8B%95%E5%B9%B3%E5%9D%87\" target=\"_blank\" rel=\"noopener\">zh.wikipedia.org/wiki/%E7%A7%BB%E5%8B%95%E5%B9%B3%E5%9D%87</a></cite></footer></blockquote>\n</li>\n<li><p><a href=\"https://zh.wikipedia.org/wiki/%E5%B8%83%E6%9E%97%E5%B8%A6\" target=\"_blank\" rel=\"noopener\">布林带</a> </p>\n<blockquote><p>“布林带”是这样定义的：</p>\n<p>中轨 = $N$ 时间段的简单移动平均线<br>上轨 = 中轨 + $K × N$时间段的标准差<br>下轨 = 中轨 − $K × N$时间段的标准差<br>一般情况下，设定N=20和K=2，这两个数值也是在布林带当中使用最多的。在日线图里，N=20其实就是“月均线”（MA20）。依照正态分布规则，约有95%的数值会分布在距离平均值有正负2个标准差（ $\\pm 2\\sigma$ ）的范围内。</p>\n<footer><strong>移动平均</strong><cite><a href=\"https://zh.wikipedia.org/wiki/%E7%A7%BB%E5%8B%95%E5%B9%B3%E5%9D%87\" target=\"_blank\" rel=\"noopener\">zh.wikipedia.org/wiki/%E7%A7%BB%E5%8B%95%E5%B9%B3%E5%9D%87</a></cite></footer></blockquote>\n<p><img src=\"1533890419564.png\" alt=\"1533890419564\"></p>\n</li>\n</ul>\n<blockquote>\n<p><strong>单纯使用穿越布林带上轨和下轨来作为买入卖出依据虽然看上去很美，但是个人认为并不能作为唯一条件。</strong></p>\n<p>以 2017-01-01 ~ 2017-12-31 日之间的 600016 交易数据判断。</p>\n<p><em>模拟操作为 一次购买机会买入100股，每遇到一次卖出机会卖出持有的所有股份。</em></p>\n<p>在模拟日期间共出现 7 次购买机会，前六次购买后卖出时亏损了360元。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;             Close_Adj   mean_20         top   ...    Rate      C     Sum</span><br><span class=\"line\">&gt; Date                                          ...                       </span><br><span class=\"line\">&gt; 2017-02-20     157.27  157.5570  159.230044   ...    0.53 -100.0  -914.0</span><br><span class=\"line\">&gt; 2017-03-06     154.61  156.3465  158.153251   ...    0.20 -100.0  -896.0</span><br><span class=\"line\">&gt; 2017-03-13     153.14  155.4830  158.303460   ...    0.15 -100.0  -886.0</span><br><span class=\"line\">&gt; 2017-03-23     149.15  153.3205  157.689392   ...    0.34 -100.0  -859.0</span><br><span class=\"line\">&gt; 2017-04-17     143.84  147.8400  152.270060   ...    0.51 -100.0  -823.0</span><br><span class=\"line\">&gt; 2017-04-21     138.97  145.6275  152.778017   ...    0.31 -100.0  -790.0</span><br><span class=\"line\">&gt; 2017-05-26     140.60  138.2060  141.390432   ...    0.71  600.0  4806.0</span><br><span class=\"line\">&gt; 2017-06-29     144.14  141.6690  144.347758   ...    0.26    NaN     NaN</span><br><span class=\"line\">&gt; 2017-07-18     151.00  144.9020  151.131555   ...    0.65    NaN     NaN</span><br><span class=\"line\">&gt; 2017-07-20     151.88  145.9120  153.310778   ...    0.45    NaN     NaN</span><br><span class=\"line\">&gt; 2017-08-15     146.28  150.4675  155.338483   ...    0.32 -100.0  -823.0</span><br><span class=\"line\">&gt; 2017-11-01     148.20  146.5935  148.700933   ...    0.27  100.0   824.0</span><br><span class=\"line\">&gt; 2017-11-09     150.11  147.4940  150.556908   ...    0.29    NaN     NaN</span><br><span class=\"line\">&gt; 2017-11-27     161.03  152.3635  161.544288   ...    0.76    NaN     NaN</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; [14 rows x 16 columns]</span><br><span class=\"line\">&gt; 600016 : -361.0/0</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>从图中可以看出 2017-02-17，2017-03-03 分别给出了从 布林带下方穿越布林带的信号，但是结果却非常不理想。</p>\n<p><img src=\"image-20180811213410404.png\" alt=\"image-20180811213410404\"></p>\n<p>对于上证50指数的所有股票进行 2017-01-01 ~ 2017-12-31 期间的数据模拟，效果依然不是很理想。去年盈利10000+，但是截至 2017-12-31 却持有价值 80000+ 的股票。</p>\n<p><strong>应该参考之前的 “投资组合” 选出合适的能够跑赢指数均值的组合 和其他分析指标共同分析。</strong></p>\n<p>代码：<a href=\"https://github.com/GuQiangJS/studySource/blob/master/codes/python/machine-learning-for-trading/tests/test_plot_bbands.py\" target=\"_blank\" rel=\"noopener\">https://github.com/GuQiangJS/studySource/blob/master/codes/python/machine-learning-for-trading/tests/test_plot_bbands.py</a></p>\n</blockquote>\n<h3 id=\"数据分析\"><a href=\"#数据分析\" class=\"headerlink\" title=\"数据分析\"></a>数据分析</h3><h4 id=\"Survior-bias\"><a href=\"#Survior-bias\" class=\"headerlink\" title=\"Survior bias\"></a>Survior bias</h4><p><a href=\"https://youtu.be/RCB2hkiwqnA\" target=\"_blank\" rel=\"noopener\">https://youtu.be/RCB2hkiwqnA</a></p>\n<blockquote>\n<p> 使用同样的时间间隔分析同一成分股集合时，选取成分股集合的时间点会造成不同的结果。采用分析时间结束时的成分股集合时会得到更加漂亮、诱人、但不真实的结果。<strong>应该选取分析时间开始时的集合</strong>。</p>\n</blockquote>\n<p><img src=\"1534238787357.png\" alt=\"1534238787357\"></p>\n<h4 id=\"效率市场假说\"><a href=\"#效率市场假说\" class=\"headerlink\" title=\"效率市场假说\"></a>效率市场假说</h4><blockquote><ul>\n<li><p>弱式效率（Weak Form Efficiency）</p>\n<p>目前股票价格已充分反映了过去股票价格所提供的各项情报。所以，投资人无法再运用各种方法对过去股票价格进行分析，再利用分析结果来预测未来股票价格，基于随机游走假说，未来消息是随机而来的。意即投资者无法再利用过去资讯来获得高额报酬。所以，弱势效率越高，若以过去价量为基础的技术分析来进行预测效果将会十分不准确。</p>\n<blockquote>\n<p>留下了可以从事基本面分析的口子。</p>\n</blockquote>\n</li>\n<li><p>半强式效率（Semi-Strong Form Efficiency）</p>\n<p>目前股票价格已充分反应了所有公开资讯，所以，投资者无法利用情报分析结果来进行股票价格预测而获取高额报酬。因此，半强式效率越高，依赖公开的财务报表、经济情况及政治情势来进行基本面分析，然后再预测股票价格是徒劳无功。</p>\n<blockquote>\n<p>连基本面分析都不行了。只能通过内幕交易了。</p>\n</blockquote>\n</li>\n<li><p>强式效率（Strong Form Efficiency）</p>\n<p>目前股票价格充分反应了所有已公开和未公开之所有情报。虽然情报未公开，但投资者能利用各种管道来获得资讯，所以，所谓未公开的消息，实际上是已公开的资讯且已反应于股票价格上。此种情形下，投资者也无法因拥有某些股票内幕消息而获取高额报酬。 </p>\n<blockquote>\n<p>连内部交易都没机会了。</p>\n</blockquote>\n</li>\n</ul>\n<footer><strong>效率市场假说</strong><cite><a href=\"https://zh.wikipedia.org/wiki/%E6%95%88%E7%8E%87%E5%B8%82%E5%A0%B4%E5%81%87%E8%AA%AA\" target=\"_blank\" rel=\"noopener\">zh.wikipedia.org/wiki/%E6%95%88%E7%8E%87%E5%B8%82%E5%A0%B4%E5%81%87%E8%AA%AA</a></cite></footer></blockquote>\n<h4 id=\"Grinold’s-fundamental-law\"><a href=\"#Grinold’s-fundamental-law\" class=\"headerlink\" title=\"Grinold’s fundamental law\"></a>Grinold’s fundamental law</h4><p><a href=\"https://youtu.be/W6yUgs1OLx0\" target=\"_blank\" rel=\"noopener\">https://youtu.be/W6yUgs1OLx0</a></p>\n<p>$performance=Skill \\times \\sqrt{breadth}$</p>\n<h4 id=\"通过协方差构建投资组合（获得相同回报，但降低波动性）\"><a href=\"#通过协方差构建投资组合（获得相同回报，但降低波动性）\" class=\"headerlink\" title=\"通过协方差构建投资组合（获得相同回报，但降低波动性）\"></a>通过协方差构建投资组合（获得相同回报，但降低波动性）</h4><p><a href=\"https://zh.wikipedia.org/wiki/%E7%8E%B0%E4%BB%A3%E6%8A%95%E8%B5%84%E7%BB%84%E5%90%88%E7%90%86%E8%AE%BA\" target=\"_blank\" rel=\"noopener\">现代投资组合理论</a></p>\n<h3 id=\"机器学习\"><a href=\"#机器学习\" class=\"headerlink\" title=\"机器学习\"></a>机器学习</h3><h4 id=\"监督回归学习\"><a href=\"#监督回归学习\" class=\"headerlink\" title=\"监督回归学习\"></a>监督回归学习</h4><ul>\n<li>线性回归（参数式）</li>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E6%9C%80%E8%BF%91%E9%84%B0%E5%B1%85%E6%B3%95\" target=\"_blank\" rel=\"noopener\">最近邻居法</a>（实例式）</li>\n<li>决策树</li>\n<li>决策森林</li>\n</ul>\n<h4 id=\"Price-forecasting-demo\"><a href=\"#Price-forecasting-demo\" class=\"headerlink\" title=\"Price forecasting demo\"></a>Price forecasting demo</h4><p><a href=\"https://youtu.be/GVOEnkjmBZU\" target=\"_blank\" rel=\"noopener\">https://youtu.be/GVOEnkjmBZU</a></p>\n<p><img src=\"1535439244770.png\" alt=\"1535439244770\"></p>\n<h4 id=\"强化学习\"><a href=\"#强化学习\" class=\"headerlink\" title=\"强化学习\"></a>强化学习</h4><h3 id=\"过拟合\"><a href=\"#过拟合\" class=\"headerlink\" title=\"过拟合\"></a>过拟合</h3><h4 id=\"集成学习-Ensemble-learning\"><a href=\"#集成学习-Ensemble-learning\" class=\"headerlink\" title=\"集成学习 (Ensemble learning)\"></a>集成学习 (<a href=\"https://en.wikipedia.org/wiki/Ensemble_learning\" target=\"_blank\" rel=\"noopener\">Ensemble learning</a>)</h4><p><img src=\"1536045019373.png\" alt=\"1536045019373\"></p>\n<h4 id=\"Bagging算法-Bootstrap-aggregating\"><a href=\"#Bagging算法-Bootstrap-aggregating\" class=\"headerlink\" title=\"Bagging算法(Bootstrap aggregating)\"></a>Bagging算法(<a href=\"https://zh.wikipedia.org/wiki/Bagging%E7%AE%97%E6%B3%95\" target=\"_blank\" rel=\"noopener\">Bootstrap aggregating</a>)</h4><h4 id=\"AdaBoost\"><a href=\"#AdaBoost\" class=\"headerlink\" title=\"AdaBoost\"></a><a href=\"https://zh.wikipedia.org/wiki/AdaBoost\" target=\"_blank\" rel=\"noopener\">AdaBoost</a></h4><p><a href=\"https://www.youtube.com/watch?v=GM3CDQfQ4sw&amp;list=PLAwxTw4SYaPnIRwl6rad_mYwEk4Gmj7Mx&amp;index=194\" target=\"_blank\" rel=\"noopener\">https://www.youtube.com/watch?v=GM3CDQfQ4sw&amp;list=PLAwxTw4SYaPnIRwl6rad_mYwEk4Gmj7Mx&amp;index=194</a></p>\n<h3 id=\"数据特征缩放\"><a href=\"#数据特征缩放\" class=\"headerlink\" title=\"数据特征缩放\"></a>数据特征缩放</h3><p><strong>标准化：</strong> $normed={values-mean \\over values.std()}$</p>\n<p>标准化后，数据均值为0，数值将在 -1 和 1 之间变化。</p>\n<blockquote><p>最简单的方式是重新缩放特征的范围到[0, 1]或[-1, 1]， 依据原始的资料选择目标范围，通式如下：$ x’={x-min(x) \\over max(x)-min(x)}$</p>\n<p>$x$ 是原始的值，$x’$ 是被标准化后的值。例如，假设我们有学生的体重资料，范围落在[160磅, 200磅]，为了重新缩放这个资料，我们会先将每个学生的体重减掉160，接着除与40(最大体重与最小体重的差值) </p>\n<footer><strong>重新缩放</strong><cite><a href=\"https://zh.wikipedia.org/wiki/%E7%89%B9%E5%BE%B5%E7%B8%AE%E6%94%BE\" target=\"_blank\" rel=\"noopener\">zh.wikipedia.org/wiki/%E7%89%B9%E5%BE%B5%E7%B8%AE%E6%94%BE</a></cite></footer></blockquote>","site":{"data":{}},"excerpt":"","more":"<p>教程Youtube链接:<a href=\"https://www.youtube.com/playlist?list=PLAwxTw4SYaPnIRwl6rad_mYwEk4Gmj7Mx\" target=\"_blank\" rel=\"noopener\">https://www.youtube.com/playlist?list=PLAwxTw4SYaPnIRwl6rad_mYwEk4Gmj7Mx</a></p>\n<h3 id=\"单一股票收益\"><a href=\"#单一股票收益\" class=\"headerlink\" title=\"单一股票收益\"></a>单一股票收益</h3><h4 id=\"The-Data-介绍CSV文件\"><a href=\"#The-Data-介绍CSV文件\" class=\"headerlink\" title=\"The Data (介绍CSV文件)\"></a>The Data (介绍CSV文件)</h4><h4 id=\"Our-Stock-Data-介绍股票每日成交汇总数据格式\"><a href=\"#Our-Stock-Data-介绍股票每日成交汇总数据格式\" class=\"headerlink\" title=\"Our Stock Data (介绍股票每日成交汇总数据格式)\"></a>Our Stock Data (介绍股票每日成交汇总数据格式)</h4><ul>\n<li>Date</li>\n<li>Open</li>\n<li>High</li>\n<li>Low</li>\n<li>Close</li>\n<li>Volume -&gt; 成交量</li>\n<li>Adj Close -&gt; 调整收盘价（除权除息价）</li>\n</ul>\n<h4 id=\"Pandas-Dataframe\"><a href=\"#Pandas-Dataframe\" class=\"headerlink\" title=\"Pandas Dataframe\"></a>Pandas Dataframe</h4><h4 id=\"Actual-CSV\"><a href=\"#Actual-CSV\" class=\"headerlink\" title=\"Actual CSV\"></a>Actual CSV</h4><h4 id=\"Interesting-Stuff\"><a href=\"#Interesting-Stuff\" class=\"headerlink\" title=\"Interesting Stuff\"></a>Interesting Stuff</h4><p>切片：取 <code>Dataframe</code> 中的部分数据</p>\n<p><a href=\"http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.loc.html#pandas.DataFrame.loc\" target=\"_blank\" rel=\"noopener\">pandas.DataFrame.loc</a></p>\n<h4 id=\"Compute-max-closing-price\"><a href=\"#Compute-max-closing-price\" class=\"headerlink\" title=\"Compute max closing price\"></a>Compute max closing price</h4><p><a href=\"http://pandas.pydata.org/pandas-docs/stable/generated/pandas.Series.max.html#pandas-series-max\" target=\"_blank\" rel=\"noopener\">pandas.Series.max</a></p>\n<h4 id=\"Plotting-stock-price-data-绘图\"><a href=\"#Plotting-stock-price-data-绘图\" class=\"headerlink\" title=\"Plotting stock price data (绘图)\"></a>Plotting stock price data (绘图)</h4><h4 id=\"Plot-two-columns-绘制多个数据\"><a href=\"#Plot-two-columns-绘制多个数据\" class=\"headerlink\" title=\"Plot two columns (绘制多个数据)\"></a>Plot two columns (绘制多个数据)</h4><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"><span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd</span><br><span class=\"line\"><span class=\"keyword\">from</span> finance_datareader_py.eastmoney.daily <span class=\"keyword\">import</span> EastMoneyDailyReader</span><br><span class=\"line\"></span><br><span class=\"line\">df1 = EastMoneyDailyReader(<span class=\"string\">'601398'</span>).read()</span><br><span class=\"line\">df2 = EastMoneyDailyReader(<span class=\"string\">'601398'</span>, type=<span class=\"string\">'ba'</span>).read()</span><br><span class=\"line\">df = pd.DataFrame()</span><br><span class=\"line\">df[<span class=\"string\">'Close'</span>] = pd.to_numeric(df1[<span class=\"string\">'Close'</span>])</span><br><span class=\"line\">df[<span class=\"string\">'Adj Close'</span>] = pd.to_numeric(df2[<span class=\"string\">'Close'</span>])</span><br><span class=\"line\">print(df.tail())</span><br><span class=\"line\">df.plot()</span><br><span class=\"line\">plt.show()</span><br></pre></td></tr></table></figure>\n<p><img src=\"1531304006175.png\" alt=\"1531304006175\"></p>\n<h4 id=\"Pandas-dataframe-recap\"><a href=\"#Pandas-dataframe-recap\" class=\"headerlink\" title=\"Pandas dataframe recap\"></a>Pandas dataframe recap</h4><h4 id=\"Problems-to-Solve\"><a href=\"#Problems-to-Solve\" class=\"headerlink\" title=\"Problems to Solve\"></a>Problems to Solve</h4><h5 id=\"Data-ranges-使用日期索引取值\"><a href=\"#Data-ranges-使用日期索引取值\" class=\"headerlink\" title=\"Data ranges(使用日期索引取值)\"></a>Data ranges(使用日期索引取值)</h5><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">from finance_datareader_py.eastmoney.daily import EastMoneyDailyReader</span><br><span class=\"line\">df = EastMoneyDailyReader(&apos;601398&apos;).read()</span><br><span class=\"line\">df.tail()</span><br><span class=\"line\">Out[4]: </span><br><span class=\"line\">            Open Close  High   Low   交易量(手)   成交金额     振幅   换手率</span><br><span class=\"line\">日期                                                             </span><br><span class=\"line\">2018-07-05  5.17  5.23  5.29  5.16  1865183  9.72亿  2.52%  0.07</span><br><span class=\"line\">2018-07-06  5.23  5.29  5.34  5.18  1925444  10.1亿  3.06%  0.07</span><br><span class=\"line\">2018-07-09  5.31  5.53  5.54  5.31  2155458  11.7亿  4.35%  0.08</span><br><span class=\"line\">2018-07-10  5.56  5.52  5.57  5.46  1289900  7.10亿  1.99%  0.05</span><br><span class=\"line\">2018-07-11  5.41  5.48  5.52  5.39  1520449  8.31亿  2.36%  0.06</span><br><span class=\"line\"></span><br><span class=\"line\">df[&apos;2017-01-01&apos;:&apos;2017-12-31&apos;].tail()</span><br><span class=\"line\">Out[6]: </span><br><span class=\"line\">            Open Close  High   Low   交易量(手)   成交金额     振幅   换手率</span><br><span class=\"line\">日期                                                             </span><br><span class=\"line\">2017-12-25  5.93  6.00  6.03  5.93  2396364  14.4亿  1.69%  0.09</span><br><span class=\"line\">2017-12-26  6.00  6.08  6.10  5.98  2165329  13.1亿     2%  0.08</span><br><span class=\"line\">2017-12-27  6.09  6.05  6.15  6.02  2151401  13.1亿  2.14%  0.08</span><br><span class=\"line\">2017-12-28  6.03  6.14  6.14  6.02  2100886  12.8亿  1.98%  0.08</span><br><span class=\"line\">2017-12-29  6.13  6.20  6.22  6.12  2168998  13.4亿  1.63%  0.08</span><br></pre></td></tr></table></figure>\n<p>取沪深300指数（399300）+单个股票数据。</p>\n<p>取沪深300指数的意义在于，只要开市，那么指数就肯定有数据，而不像其他单一股票可能会出现不定期停牌的情况。</p>\n<p>看下面的数据：</p>\n<ol>\n<li>2005年，300027还没有上市，所以数值为 <code>NaN</code>。</li>\n<li>2018-07-07、2018-07-08两天是休息日，不开市。这时不会有数据。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">import pandas as pd</span><br><span class=\"line\">from finance_datareader_py.eastmoney.daily import EastMoneyDailyReader</span><br><span class=\"line\">df1 = EastMoneyDailyReader(&apos;399300&apos;).read()</span><br><span class=\"line\">df2 = EastMoneyDailyReader(&apos;300027&apos;).read()</span><br><span class=\"line\">df = pd.DataFrame()</span><br><span class=\"line\">df[&apos;399300&apos;] = df1[&apos;Close&apos;]</span><br><span class=\"line\">df[&apos;300027&apos;] = df2[&apos;Close&apos;]</span><br><span class=\"line\"></span><br><span class=\"line\">df.head()</span><br><span class=\"line\">Out[4]: </span><br><span class=\"line\">            399300 300027</span><br><span class=\"line\">日期                       </span><br><span class=\"line\">2005-01-04  982.79    NaN</span><br><span class=\"line\">2005-01-05  992.56    NaN</span><br><span class=\"line\">2005-01-06  983.17    NaN</span><br><span class=\"line\">2005-01-07  983.96    NaN</span><br><span class=\"line\">2005-01-10  993.88    NaN</span><br><span class=\"line\"></span><br><span class=\"line\">df.tail()</span><br><span class=\"line\">Out[3]: </span><br><span class=\"line\">             399300 300027</span><br><span class=\"line\">日期                        </span><br><span class=\"line\">2018-07-05  3342.44   6.08</span><br><span class=\"line\">2018-07-06  3365.12   6.09</span><br><span class=\"line\">2018-07-09  3459.18   6.12</span><br><span class=\"line\">2018-07-10  3467.52   6.03</span><br><span class=\"line\">2018-07-11  3407.53   5.96</span><br></pre></td></tr></table></figure>\n<h4 id=\"Create-an-exmpty-data-frame\"><a href=\"#Create-an-exmpty-data-frame\" class=\"headerlink\" title=\"Create an exmpty data frame\"></a>Create an exmpty data frame</h4><h4 id=\"Join-SPY-data-使用Join关联数据，使用dropna丢弃空数据\"><a href=\"#Join-SPY-data-使用Join关联数据，使用dropna丢弃空数据\" class=\"headerlink\" title=\"Join SPY data (使用Join关联数据，使用dropna丢弃空数据)\"></a>Join SPY data (使用Join关联数据，使用dropna丢弃空数据)</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">import pandas as pd</span><br><span class=\"line\">from finance_datareader_py.eastmoney.daily import EastMoneyDailyReader</span><br><span class=\"line\">df1 = EastMoneyDailyReader(&apos;399300&apos;).read()</span><br><span class=\"line\">dates = pd.date_range(&apos;2010-01-01&apos;, &apos;2010-01-05&apos;)</span><br><span class=\"line\"># 创建空白DataFrame</span><br><span class=\"line\">df = pd.DataFrame(index=dates)</span><br><span class=\"line\">df = df.join(df1)</span><br><span class=\"line\"></span><br><span class=\"line\">df[&apos;Close&apos;].head()</span><br><span class=\"line\">Out[3]: </span><br><span class=\"line\">2010-01-01        NaN</span><br><span class=\"line\">2010-01-02        NaN</span><br><span class=\"line\">2010-01-03        NaN</span><br><span class=\"line\">2010-01-04    3535.23</span><br><span class=\"line\">2010-01-05    3564.04</span><br><span class=\"line\">Freq: D, Name: Close, dtype: object</span><br><span class=\"line\"></span><br><span class=\"line\">df[&apos;Close&apos;].head().dropna()</span><br><span class=\"line\">Out[4]: </span><br><span class=\"line\">2010-01-04    3535.23</span><br><span class=\"line\">2010-01-05    3564.04</span><br><span class=\"line\">Freq: D, Name: Close, dtype: object</span><br></pre></td></tr></table></figure>\n<h4 id=\"Read-in-more-stocks-重命名，一个dataframe中不能出现同名的列\"><a href=\"#Read-in-more-stocks-重命名，一个dataframe中不能出现同名的列\" class=\"headerlink\" title=\"Read in more stocks(重命名，一个dataframe中不能出现同名的列)\"></a>Read in more stocks(重命名，一个dataframe中不能出现同名的列)</h4><h4 id=\"Slicing-数据切片\"><a href=\"#Slicing-数据切片\" class=\"headerlink\" title=\"Slicing (数据切片)\"></a>Slicing (数据切片)</h4><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd</span><br><span class=\"line\"><span class=\"keyword\">from</span> finance_datareader_py.eastmoney.daily <span class=\"keyword\">import</span> EastMoneyDailyReader</span><br><span class=\"line\"></span><br><span class=\"line\">symbols = [<span class=\"string\">'399300'</span>, <span class=\"string\">'300027'</span>, <span class=\"string\">'601398'</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">dates = pd.date_range(<span class=\"string\">'2010-01-01'</span>, <span class=\"string\">'2010-01-05'</span>)</span><br><span class=\"line\"><span class=\"comment\"># 创建空白DataFrame</span></span><br><span class=\"line\">df = pd.DataFrame(index=dates)</span><br><span class=\"line\"><span class=\"keyword\">for</span> symbol <span class=\"keyword\">in</span> symbols:</span><br><span class=\"line\">    df_temp = EastMoneyDailyReader(symbol).read()</span><br><span class=\"line\">    df_temp = df_temp.rename(columns=&#123;<span class=\"string\">'Close'</span>: symbol&#125;)</span><br><span class=\"line\">    df = df.join(df_temp[symbol])</span><br><span class=\"line\"></span><br><span class=\"line\">print(df)</span><br><span class=\"line\">print(<span class=\"string\">'------------------------'</span>)</span><br><span class=\"line\">print(df.dropna())</span><br><span class=\"line\">print(<span class=\"string\">'------------------------'</span>)</span><br><span class=\"line\">print(df.loc[<span class=\"string\">'2010-01-04'</span>:<span class=\"string\">'2010-01-04'</span>,[<span class=\"string\">'000002'</span>, <span class=\"string\">'601398'</span>]])</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">             399300 300027 601398</span><br><span class=\"line\">2010-01-01      NaN    NaN    NaN</span><br><span class=\"line\">2010-01-02      NaN    NaN    NaN</span><br><span class=\"line\">2010-01-03      NaN    NaN    NaN</span><br><span class=\"line\">2010-01-04  3535.23  55.53   5.35</span><br><span class=\"line\">2010-01-05  3564.04  55.09   5.40</span><br><span class=\"line\">------------------------</span><br><span class=\"line\">             399300 300027 601398</span><br><span class=\"line\">2010-01-04  3535.23  55.53   5.35</span><br><span class=\"line\">2010-01-05  3564.04  55.09   5.40</span><br><span class=\"line\">------------------------</span><br><span class=\"line\">             399300 300027</span><br><span class=\"line\">2010-01-04  3535.23  55.53</span><br></pre></td></tr></table></figure>\n<h4 id=\"Problems-with-Plotting-判断时股价起点不同，很难在同一层面观察\"><a href=\"#Problems-with-Plotting-判断时股价起点不同，很难在同一层面观察\" class=\"headerlink\" title=\"Problems with Plotting (判断时股价起点不同，很难在同一层面观察)\"></a>Problems with Plotting (判断时股价起点不同，很难在同一层面观察)</h4><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"><span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd</span><br><span class=\"line\"><span class=\"keyword\">from</span> finance_datareader_py.eastmoney.daily <span class=\"keyword\">import</span> EastMoneyDailyReader</span><br><span class=\"line\"></span><br><span class=\"line\">symbols = [<span class=\"string\">'600519'</span>, <span class=\"string\">'000002'</span>, <span class=\"string\">'601398'</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建空白DataFrame</span></span><br><span class=\"line\">df = pd.DataFrame()</span><br><span class=\"line\"><span class=\"keyword\">for</span> symbol <span class=\"keyword\">in</span> symbols:</span><br><span class=\"line\">    df_temp = EastMoneyDailyReader(symbol).read()</span><br><span class=\"line\">    df[symbol] = df_temp[<span class=\"string\">'Close'</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">df = df.dropna()</span><br><span class=\"line\">df.loc[<span class=\"string\">'2017-01-01'</span>:<span class=\"string\">'2017-12-31'</span>].plot()</span><br><span class=\"line\">plt.show()</span><br></pre></td></tr></table></figure>\n<p><img src=\"1531383436936.png\" alt=\"1531383436936\"></p>\n<h4 id=\"Normalizing-数据归一化\"><a href=\"#Normalizing-数据归一化\" class=\"headerlink\" title=\"Normalizing (数据归一化)\"></a>Normalizing (数据归一化)</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">def normalize_data(df):</span><br><span class=\"line\">    return df / df.iloc[0]</span><br><span class=\"line\"></span><br><span class=\"line\">normalize_data(df.loc[&apos;2017-01-01&apos;:&apos;2017-12-31&apos;]).plot()</span><br></pre></td></tr></table></figure>\n<p>让Dataframe的每一行数据除以第一行的值，从而使所有数据从1开始。</p>\n<p><img src=\"1531384011994.png\" alt=\"1531384011994\"></p>\n<h4 id=\"What-is-NumPy\"><a href=\"#What-is-NumPy\" class=\"headerlink\" title=\"What is NumPy\"></a>What is NumPy</h4><h4 id=\"Relationship-to-Pandas-numpy与Pandas的关系\"><a href=\"#Relationship-to-Pandas-numpy与Pandas的关系\" class=\"headerlink\" title=\"Relationship to Pandas (numpy与Pandas的关系)\"></a>Relationship to Pandas (numpy与Pandas的关系)</h4><h4 id=\"Compute-global-statistics\"><a href=\"#Compute-global-statistics\" class=\"headerlink\" title=\"Compute global statistics\"></a>Compute global statistics</h4><p><a href=\"https://zh.wikipedia.org/wiki/%E6%A8%99%E6%BA%96%E5%B7%AE\" target=\"_blank\" rel=\"noopener\">标准差</a></p>\n<blockquote>\n<p>例如，两组数的集合{0, 5, 9, 14}和{5, 6, 8, 9}其平均值都是7，但第二个集合具有较小的标准差。 </p>\n</blockquote>\n<h4 id=\"Rolling-statistics\"><a href=\"#Rolling-statistics\" class=\"headerlink\" title=\"Rolling statistics\"></a>Rolling statistics</h4><h4 id=\"Bollinger-Bands\"><a href=\"#Bollinger-Bands\" class=\"headerlink\" title=\"Bollinger Bands\"></a>Bollinger Bands</h4><p><a href=\"https://zh.wikipedia.org/wiki/%E5%B8%83%E6%9E%97%E5%B8%A6\" target=\"_blank\" rel=\"noopener\">布林带</a></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">df = pd.DataFrame()</span><br><span class=\"line\">df[<span class=\"string\">'Close'</span>] = EastMoneyDailyReader(<span class=\"string\">'601398'</span>).read()[<span class=\"string\">'Close'</span>]</span><br><span class=\"line\">df[<span class=\"string\">'rol_30'</span>] = pd.rolling_mean(df[<span class=\"string\">'Close'</span>], window=<span class=\"number\">30</span>)</span><br><span class=\"line\">df.head(<span class=\"number\">100</span>).plot()</span><br><span class=\"line\">plt.show()</span><br></pre></td></tr></table></figure>\n<p><img src=\"1531465284221.png\" alt=\"1531465284221\"></p>\n<h4 id=\"Daily-returns-日收益\"><a href=\"#Daily-returns-日收益\" class=\"headerlink\" title=\"Daily returns (日收益)\"></a>Daily returns (日收益)</h4><p>日收益基本上是围绕0上下浮动。</p>\n<p><code>daily_ret[t]=(price[t]/price[t-1])-1</code></p>\n<p><code>(110/100)-1=1.1-1=0.1=10%</code></p>\n<h4 id=\"Cumulative-returns-累计收益\"><a href=\"#Cumulative-returns-累计收益\" class=\"headerlink\" title=\"Cumulative returns (累计收益)\"></a>Cumulative returns (累计收益)</h4><p>累积收益和数据归一化在计算中的意思基本一致。</p>\n<h4 id=\"A-closer-look-at-daily-returns\"><a href=\"#A-closer-look-at-daily-returns\" class=\"headerlink\" title=\"A closer look at daily returns\"></a>A closer look at daily returns</h4><p>使用直方图展示日收益率的分布情况</p>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E5%B3%B0%E5%BA%A6\" target=\"_blank\" rel=\"noopener\">峰度</a></p>\n<blockquote>\n<p>峰度高就意味着方差增大是由低频度的大于或小于平均值的极端差值引起的。 </p>\n</blockquote>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E8%82%A5%E5%B0%BE%E5%88%86%E5%B8%83\" target=\"_blank\" rel=\"noopener\">肥尾分布</a></p>\n<h4 id=\"Computing-rolling-statistics\"><a href=\"#Computing-rolling-statistics\" class=\"headerlink\" title=\"Computing rolling statistics\"></a>Computing rolling statistics</h4><p>20日移动平均线</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">df = EastMoneyDailyReader(<span class=\"string\">'601398'</span>).read().tail(<span class=\"number\">200</span>)</span><br><span class=\"line\">ax = df[<span class=\"string\">'Close'</span>].plot(title=<span class=\"string\">'601398 rolling mean'</span>)</span><br><span class=\"line\">rm = pd.rolling_mean(df[<span class=\"string\">'Close'</span>], window=<span class=\"number\">20</span>)</span><br><span class=\"line\">rm.plot(label=<span class=\"string\">'Rolling mean'</span>, ax=ax)</span><br><span class=\"line\"></span><br><span class=\"line\">ax.set_xlabel(<span class=\"string\">'Date'</span>)</span><br><span class=\"line\">ax.set_ylabel(<span class=\"string\">'Price'</span>)</span><br><span class=\"line\">ax.legend(loc=<span class=\"string\">'upper left'</span>)</span><br><span class=\"line\">plt.show()</span><br></pre></td></tr></table></figure>\n<p><img src=\"1531632440578.png\" alt=\"1531632440578\"></p>\n<h4 id=\"Using-fillna-数据市场是不完整的，需要补齐\"><a href=\"#Using-fillna-数据市场是不完整的，需要补齐\" class=\"headerlink\" title=\"Using fillna() (数据市场是不完整的，需要补齐)\"></a>Using fillna() (数据市场是不完整的，需要补齐)</h4><h4 id=\"Histogram-of-daily-returns-使用直方图来查看每日收益\"><a href=\"#Histogram-of-daily-returns-使用直方图来查看每日收益\" class=\"headerlink\" title=\"Histogram of daily returns (使用直方图来查看每日收益)\"></a>Histogram of daily returns (使用直方图来查看每日收益)</h4><h4 id=\"How-to-plot-a-histogram-如何绘制直方图\"><a href=\"#How-to-plot-a-histogram-如何绘制直方图\" class=\"headerlink\" title=\"How to plot a histogram (如何绘制直方图)\"></a>How to plot a histogram (如何绘制直方图)</h4><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">compute_daily_returns</span><span class=\"params\">(df)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> df[:<span class=\"number\">-1</span>].values / df[<span class=\"number\">1</span>:] - <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">df = EastMoneyDailyReader(<span class=\"string\">'601398'</span>).read()</span><br><span class=\"line\">daily_returns = compute_daily_returns(df[<span class=\"string\">'Close'</span>])</span><br><span class=\"line\">daily_returns.hist(bins=<span class=\"number\">50</span>)</span><br><span class=\"line\">print(daily_returns.tail(<span class=\"number\">100</span>))</span><br><span class=\"line\">plt.show()</span><br></pre></td></tr></table></figure>\n<p><img src=\"1531634310060.png\" alt=\"1531634310060\"></p>\n<p><a href=\"https://www.ricequant.com/community/topic/126/\" target=\"_blank\" rel=\"noopener\">关于证券收益分布原因的讨论</a></p>\n<h4 id=\"绘制平均值和标准差\"><a href=\"#绘制平均值和标准差\" class=\"headerlink\" title=\"绘制平均值和标准差\"></a>绘制平均值和标准差</h4><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">mean = daily_returns.mean()</span><br><span class=\"line\">print(<span class=\"string\">\"mean=\"</span>, mean)</span><br><span class=\"line\">std = daily_returns.std()</span><br><span class=\"line\">print(<span class=\"string\">'std='</span>, std)</span><br><span class=\"line\">plt.axvline(mean, color=<span class=\"string\">'g'</span>)</span><br><span class=\"line\">plt.axvline(std, color=<span class=\"string\">'r'</span>, linestyle=<span class=\"string\">'dashed'</span>)</span><br><span class=\"line\">plt.axvline(-std, color=<span class=\"string\">'r'</span>, linestyle=<span class=\"string\">'dashed'</span>)</span><br><span class=\"line\">plt.show()</span><br></pre></td></tr></table></figure>\n<p><img src=\"1531635134977.png\" alt=\"1531635134977\"></p>\n<h4 id=\"计算峰度\"><a href=\"#计算峰度\" class=\"headerlink\" title=\"计算峰度\"></a>计算峰度</h4><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">print(daily_returns.kurtosis())</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">7.34265127165</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>在机率论中，*肥尾分布**（英语：Fat-tailed distribution）是一种<a href=\"https://zh.wikipedia.org/wiki/%E6%A9%9F%E7%8E%87%E5%88%86%E5%B8%83\" target=\"_blank\" rel=\"noopener\">机率分布</a>模型。它是一种<a href=\"https://zh.wikipedia.org/wiki/%E9%87%8D%E5%B0%BE%E5%88%86%E5%B8%83\" target=\"_blank\" rel=\"noopener\">重尾分布</a>，但是它的<a href=\"https://zh.wikipedia.org/wiki/%E5%81%8F%E5%BA%A6\" target=\"_blank\" rel=\"noopener\">偏度</a>或<a href=\"https://zh.wikipedia.org/wiki/%E5%B3%B0%E5%BA%A6\" target=\"_blank\" rel=\"noopener\">峰度</a>极端的大。与无所不在的<a href=\"https://zh.wikipedia.org/wiki/%E5%B8%B8%E6%85%8B%E5%88%86%E5%B8%83\" target=\"_blank\" rel=\"noopener\">正态分布</a>作比较，<a href=\"https://zh.wikipedia.org/wiki/%E5%B8%B8%E6%85%8B%E5%88%86%E5%B8%83\" target=\"_blank\" rel=\"noopener\">正态分布</a>属于一种细尾分布，或<a href=\"https://zh.wikipedia.org/wiki/%E6%8C%87%E6%95%B0%E5%88%86%E5%B8%83\" target=\"_blank\" rel=\"noopener\">指数分布</a>。 </p>\n</blockquote>\n<h5 id=\"Plot-two-histograms-together-合并绘制两个直方图\"><a href=\"#Plot-two-histograms-together-合并绘制两个直方图\" class=\"headerlink\" title=\"Plot two histograms together (合并绘制两个直方图)\"></a>Plot two histograms together (合并绘制两个直方图)</h5><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"><span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd</span><br><span class=\"line\"><span class=\"keyword\">from</span> finance_datareader_py.eastmoney.daily <span class=\"keyword\">import</span> EastMoneyDailyReader</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">compute_daily_returns</span><span class=\"params\">(df)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> df[:<span class=\"number\">-1</span>].values / df[<span class=\"number\">1</span>:] - <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">df = pd.DataFrame()</span><br><span class=\"line\">df[<span class=\"string\">'601398'</span>] = EastMoneyDailyReader(<span class=\"string\">'601398'</span>).read()[<span class=\"string\">'Close'</span>]</span><br><span class=\"line\">df[<span class=\"string\">'601939'</span>] = EastMoneyDailyReader(<span class=\"string\">'601939'</span>).read()[<span class=\"string\">'Close'</span>]</span><br><span class=\"line\"><span class=\"comment\"># 计算日收益率</span></span><br><span class=\"line\">daily_returns = compute_daily_returns(df)</span><br><span class=\"line\"><span class=\"comment\"># 绘制直方图</span></span><br><span class=\"line\">daily_returns.hist()</span><br><span class=\"line\"><span class=\"comment\"># 绘图</span></span><br><span class=\"line\">plt.show()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 合并绘制两个直方图</span></span><br><span class=\"line\">daily_returns[<span class=\"string\">'601398'</span>].hist(label=<span class=\"string\">'601398'</span>)</span><br><span class=\"line\">daily_returns[<span class=\"string\">'601939'</span>].hist(label=<span class=\"string\">'601939'</span>)</span><br><span class=\"line\">plt.legend(loc=<span class=\"string\">'upper right'</span>)</span><br><span class=\"line\">plt.show()</span><br></pre></td></tr></table></figure>\n<p><img src=\"1532508260900.png\" alt=\"1532508260900\"></p>\n<p><img src=\"1532508276951.png\" alt=\"1532508276951\"></p>\n<p>股票和市场的日收益分布和高斯分布非常相似。这个性质对 <em>日收益、月收益、年收益</em> 来说同样适用。</p>\n<p>如果它们真的是高斯分布，那么我们就可以说它们是正态分布。</p>\n<p><strong>但是假定收益是正态分布的，却是非常危险的。因为它忽略了峰度或者尾部。</strong> <em>正是因为这样才造成了08年的金融风暴。</em></p>\n<h4 id=\"Scatterplots-散点图\"><a href=\"#Scatterplots-散点图\" class=\"headerlink\" title=\"Scatterplots (散点图)\"></a>Scatterplots (散点图)</h4><p>这是区分各支股票日收益的另一种方法。</p>\n<p>线性但离散的特点。</p>\n<blockquote><p>贝他值（ $\\beta$ 值）：<br>用以衡量基金之市场风险，或称系统性风险。其计算的方式为以过去12个月或24个月之基金月报酬率对同期市场月报酬率做回归，估计斜率系数而得，当 $\\beta$ &gt;1（$\\beta$ &lt; -1），表示基金坡动度较指数为大，当指数上扬 10%（下跌10%），基金会上扬超过 10%（下跌超过10%）；当 $\\beta$ = 1，表示指数涨跌多少，基金就跟着变动多少。</p>\n<footer><strong>Beta系数</strong><cite><a href=\"https://zh.wikipedia.org/wiki/Beta%E7%B3%BB%E6%95%B0\" target=\"_blank\" rel=\"noopener\">zh.wikipedia.org/wiki/Beta%E7%B3%BB%E6%95%B0</a></cite></footer></blockquote>\n<blockquote><p>阿尔法系数（ $\\alpha$）是基金的实际收益和按照β系数计算的期望收益之间的差额。其计算方法如下：超额收益是基金的收益减去无风险投资收益（在中国为1年期银行定期存款收益）；期望收益是贝塔系数 $\\beta$ 和市场收益的乘积，反映基金由于市场整体变动而获得的收益；超额收益和期望收益的差额即 $\\alpha$ 系数。该系数越大越好。</p>\n<footer><strong>阿尔法系数</strong><cite><a href=\"https://zh.wikipedia.org/wiki/%E8%AF%81%E5%88%B8%E6%8A%95%E8%B5%84%E5%9F%BA%E9%87%91#%E9%98%BF%E5%B0%94%E6%B3%95%E7%B3%BB%E6%95%B0\" target=\"_blank\" rel=\"noopener\">zh.wikipedia.org/wiki/%E8%AF%81%E5%88%B8%E6%8A%95%E8%B5%84%E5%9F%BA%E9%87%91#%E9%98%BF%E5%B0%94%E6%B3%95%E7%B3%BB%E6%95%B0</a></cite></footer></blockquote>\n<h5 id=\"Slope-does-not-equal-correlation-斜率-beta-系数与数据的相关性-拟合度无关\"><a href=\"#Slope-does-not-equal-correlation-斜率-beta-系数与数据的相关性-拟合度无关\" class=\"headerlink\" title=\"Slope does not equal correlation (斜率 $\\beta$ 系数与数据的相关性/拟合度无关)\"></a>Slope does not equal correlation (斜率 $\\beta$ 系数与数据的相关性/拟合度无关)</h5><p>可能有很低的斜率，但是数据拟合度非常高。反之亦然。</p>\n<h5 id=\"Scatterplots-in-python-散点图\"><a href=\"#Scatterplots-in-python-散点图\" class=\"headerlink\" title=\"Scatterplots in python (散点图)\"></a>Scatterplots in python (散点图)</h5><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">df = pd.DataFrame()</span><br><span class=\"line\">df[<span class=\"string\">'000300'</span>] = SohuDailyReader(<span class=\"string\">'000300'</span>, prefix=<span class=\"string\">'zs_'</span>).read()[<span class=\"string\">'Close'</span>]</span><br><span class=\"line\">df[<span class=\"string\">'601398'</span>] = SohuDailyReader(<span class=\"string\">'601398'</span>).read()[<span class=\"string\">'Close'</span>]</span><br><span class=\"line\">df[<span class=\"string\">'601939'</span>] = SohuDailyReader(<span class=\"string\">'601939'</span>).read()[<span class=\"string\">'Close'</span>]</span><br><span class=\"line\"><span class=\"comment\"># 计算日收益率</span></span><br><span class=\"line\">daily_returns = compute_daily_returns(df)</span><br><span class=\"line\"><span class=\"comment\"># 绘制 601398 相对于 000300 的散点图</span></span><br><span class=\"line\">daily_returns.plot(kind=<span class=\"string\">'scatter'</span>, x=<span class=\"string\">'000300'</span>, y=<span class=\"string\">'601398'</span>)</span><br><span class=\"line\">plt.show()</span><br><span class=\"line\"><span class=\"comment\"># 绘制 601939 相对于 000300 的散点图</span></span><br><span class=\"line\">daily_returns.plot(kind=<span class=\"string\">'scatter'</span>, x=<span class=\"string\">'000300'</span>, y=<span class=\"string\">'601939'</span>)</span><br><span class=\"line\">plt.show()</span><br></pre></td></tr></table></figure>\n<p><img src=\"1532570705884.png\" alt=\"1532570705884\"></p>\n<p><img src=\"1532570720355.png\" alt=\"1532570720355\"></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># beta系数和alpha系数</span></span><br><span class=\"line\">beta, alpha = np.polyfit(daily_returns[<span class=\"string\">'000300'</span>], daily_returns[<span class=\"string\">'601939'</span>], <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">daily_returns.plot(kind=<span class=\"string\">'scatter'</span>, x=<span class=\"string\">'000300'</span>, y=<span class=\"string\">'601939'</span>)</span><br><span class=\"line\"><span class=\"comment\"># 绘制拟合线</span></span><br><span class=\"line\">plt.plot(daily_returns[<span class=\"string\">'000300'</span>], beta * daily_returns[<span class=\"string\">'000300'</span>] + alpha, <span class=\"string\">'-'</span>,</span><br><span class=\"line\">         color=<span class=\"string\">'r'</span>)</span><br><span class=\"line\">plt.show()</span><br><span class=\"line\">print(<span class=\"string\">'beta='</span> + str(beta))</span><br><span class=\"line\">print(<span class=\"string\">'alpha='</span> + str(alpha))</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">beta=0.590256550806</span><br><span class=\"line\">alpha=-0.000246730309092</span><br></pre></td></tr></table></figure>\n<p><img src=\"1532571574686.png\" alt=\"1532571574686\"></p>\n<h3 id=\"投资组合\"><a href=\"#投资组合\" class=\"headerlink\" title=\"投资组合\"></a>投资组合</h3><h4 id=\"Daily-portfolio-values\"><a href=\"#Daily-portfolio-values\" class=\"headerlink\" title=\"Daily portfolio values\"></a>Daily portfolio values</h4><p><a href=\"https://youtu.be/UweF-2-Tr9Y\" target=\"_blank\" rel=\"noopener\">https://youtu.be/UweF-2-Tr9Y</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">投资组合假设：</span><br><span class=\"line\">start_val = 1000000 # 初始投资总额</span><br><span class=\"line\">start_date = 2011-01-01 # 初始投资日期</span><br><span class=\"line\">end_date = 2011-12-31 # 结束投资日期</span><br><span class=\"line\"># 投资组合：贵州茅台、中国平安、招商银行、格力电器</span><br><span class=\"line\">symbols = [&apos;600519&apos;,&apos;601318&apos;,&apos;600036&apos;,&apos;000651&apos;] </span><br><span class=\"line\"># 比率分配</span><br><span class=\"line\">allocs = [0.4,0.4,0.1,0.1]</span><br></pre></td></tr></table></figure>\n<h4 id=\"如何计算投资组合每日的总价值\"><a href=\"#如何计算投资组合每日的总价值\" class=\"headerlink\" title=\"如何计算投资组合每日的总价值\"></a>如何计算投资组合每日的总价值</h4><p><a href=\"https://youtu.be/UweF-2-Tr9Y\" target=\"_blank\" rel=\"noopener\">https://youtu.be/UweF-2-Tr9Y</a></p>\n<ol>\n<li>从价格 <code>DataFrame</code> 开始。</li>\n<li>价格归一化（<code>normed=prices/prices[0]</code>）。开始日期的数据始终为1.0。</li>\n<li>使用归一化以后的值乘以每支股票分配的资金比例（<code>alloced=normed*allocs</code>）。</li>\n<li>使用初始投资总额乘以3的结果（<code>pos_vals=alloced*start_val</code>）</li>\n<li>每一天的总价值：<code>port_val=pos_vals.sum(axis=1)</code></li>\n</ol>\n<p><img src=\"1532675498707.png\" alt=\"1532675498707\"></p>\n<p>计算后的每日收益的第一天的收益始终为 <em>0</em>，所以应该去除。 <code>daily_returns=daily_returns[1:]</code> </p>\n<p>有了每日收益之后可以计算很多有趣的数据。<strong>评估投资组合时的常用数据</strong>：</p>\n<ul>\n<li><code>cum_ret</code> 累计收益 <code>(port_val[-1]/port_val[0])-1</code></li>\n<li><code>avg_daily_ret</code> 平均收益 <code>daily_rets.mean()</code></li>\n<li><code>std_daily_ret</code> 每日收益标准差 <code>daily_rets.std()</code></li>\n<li><code>sharpe_ratio</code> 夏普比率</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> datetime</span><br><span class=\"line\"><span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd</span><br><span class=\"line\"><span class=\"keyword\">from</span> finance_datareader_py.sohu.daily <span class=\"keyword\">import</span> SohuDailyReader</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">compute_daily_returns</span><span class=\"params\">(df)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> df[:<span class=\"number\">-1</span>].values / df[<span class=\"number\">1</span>:] - <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">SYMBOLS = [<span class=\"string\">'600519'</span>, <span class=\"string\">'601318'</span>, <span class=\"string\">'600036'</span>, <span class=\"string\">'000651'</span>]</span><br><span class=\"line\">ALLOCS = [<span class=\"number\">0.4</span>, <span class=\"number\">0.4</span>, <span class=\"number\">0.1</span>, <span class=\"number\">0.1</span>]</span><br><span class=\"line\">START = datetime.date(<span class=\"number\">2009</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">END = datetime.date(<span class=\"number\">2011</span>, <span class=\"number\">12</span>, <span class=\"number\">31</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_datas</span><span class=\"params\">(symbols, start, end)</span>:</span></span><br><span class=\"line\">    df = pd.DataFrame()</span><br><span class=\"line\">    df[<span class=\"string\">'000300'</span>] = SohuDailyReader(<span class=\"string\">'000300'</span>, prefix=<span class=\"string\">'zs_'</span>, start=start,</span><br><span class=\"line\">                                   end=end).read()[<span class=\"string\">'Close'</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> symbol <span class=\"keyword\">in</span> symbols:</span><br><span class=\"line\">        df1 = SohuDailyReader(symbol, start=start, end=end).read()</span><br><span class=\"line\">        df1 = df1.rename(columns=&#123;<span class=\"string\">'Close'</span>: symbol&#125;)</span><br><span class=\"line\">        df = df.join(df1[symbol])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> df.fillna(method=<span class=\"string\">'bfill'</span>)  <span class=\"comment\"># 因为是倒序排序，所以使用bfill</span></span><br><span class=\"line\"></span><br><span class=\"line\">df = get_datas(SYMBOLS, START, END)</span><br><span class=\"line\">df_ret = compute_daily_returns(df)</span><br><span class=\"line\">print(df)</span><br><span class=\"line\">print(df_ret)</span><br><span class=\"line\">print(<span class=\"string\">'-----------------'</span>)</span><br><span class=\"line\">print(<span class=\"string\">'平均收益:'</span>)</span><br><span class=\"line\">print(df_ret.mean())</span><br><span class=\"line\">print(<span class=\"string\">'-----------------'</span>)</span><br><span class=\"line\">print(<span class=\"string\">'每日收益标准差:'</span>)</span><br><span class=\"line\">print(df_ret.std())</span><br><span class=\"line\">print(<span class=\"string\">'-----------------'</span>)</span><br><span class=\"line\">print(<span class=\"string\">'累计收益:'</span>)</span><br><span class=\"line\">print(df.iloc[<span class=\"number\">0</span>] / df.iloc[<span class=\"number\">-1</span>] - <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 移除指数列，并按照比率分配</span></span><br><span class=\"line\">alloced = df_nor.copy().drop(<span class=\"string\">'000300'</span>, axis=<span class=\"number\">1</span>) * ALLOCS</span><br><span class=\"line\"><span class=\"comment\"># 按照比率分配后的各支股票的每日价值</span></span><br><span class=\"line\">pos_vals = alloced * START_VALS</span><br><span class=\"line\"><span class=\"comment\"># 投资组合的每日价值</span></span><br><span class=\"line\">port_val = pos_vals.sum(axis=<span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">-----------------</span><br><span class=\"line\">平均收益:</span><br><span class=\"line\">000300    0.000443</span><br><span class=\"line\">600519    0.000973</span><br><span class=\"line\">601318    0.000508</span><br><span class=\"line\">600036    0.000162</span><br><span class=\"line\">000651    0.000445</span><br><span class=\"line\">dtype: float64</span><br><span class=\"line\">-----------------</span><br><span class=\"line\">每日收益标准差:</span><br><span class=\"line\">000300    0.016803</span><br><span class=\"line\">600519    0.018983</span><br><span class=\"line\">601318    0.023065</span><br><span class=\"line\">600036    0.021895</span><br><span class=\"line\">000651    0.031399</span><br><span class=\"line\">dtype: float64</span><br><span class=\"line\">-----------------</span><br><span class=\"line\">累计收益:</span><br><span class=\"line\">000300    0.245773</span><br><span class=\"line\">600519    0.783539</span><br><span class=\"line\">601318    0.193761</span><br><span class=\"line\">600036   -0.057188</span><br><span class=\"line\">000651   -0.074906</span><br><span class=\"line\">dtype: float64</span><br></pre></td></tr></table></figure>\n<h4 id=\"Sharpe-ratio-夏普比率\"><a href=\"#Sharpe-ratio-夏普比率\" class=\"headerlink\" title=\"Sharpe ratio (夏普比率)\"></a>Sharpe ratio (夏普比率)</h4><p><a href=\"https://youtu.be/5cqstpRndtI\" target=\"_blank\" rel=\"noopener\">https://youtu.be/5cqstpRndtI</a></p>\n<blockquote><p>　　现代投资理论的研究表明,风险的大小在决定组合的表现上具有基础性的作用。风险调整后的收益率就是一个可以同时对收益与风险加以考虑的综合指标,以期能够排除风险因素对绩效评估的不利影响。夏普比率就是一个可以同时对收益与风险加以综合考虑的三大经典指标之一。</p>\n<p>　　投资中有一个常规的特点，即投资标的的预期报酬越高，投资人所能忍受的波动风险越高；反之，预期报酬越低，波动风险也越低。所以理性的投资人选择投资标的与投资组合的主要目的为：在固定所能承受的风险下，追求最大的报酬；或在固定的预期报酬下，追求最低的风险。</p>\n<p>　　夏普比率计算公式：＝[E(Rp)－Rf]/σp</p>\n<p>　　其中E(Rp)：投资组合预期报酬率</p>\n<p>　　Rf：无风险利率</p>\n<p>　　σp：投资组合的标准差</p>\n<p>　　目的是计算投资组合每承受一单位总风险，会产生多少的超额报酬。比率依据资本市场线(Capital Market Line,CML)的观念而来，是市场上最常见的衡量比率。当投资组合内的资产皆为风险性资产时，适用夏普比率。夏普指数代表投资人每多承担一分风险，可以拿到几分报酬；若为正值，代表基金报酬率高过波动风险；若为负值，代表基金操作风险大过于报酬率。这样一来，每个投资组合都可以计算Sharpe Ratio,即投资回报与多冒风险的比例，这个比例越高，投资组合越佳。</p>\n<p>　　举例而言，假如国债的回报是3%，而您的投资组合预期回报是15%，您的投资组合的标准偏差是6%，那么用15%－3%,可以得出12%（代表您超出无风险投资的回报），再用12%÷6%＝2，代表投资者风险每增长1%，换来的是2%的多余收益。</p>\n<footer><strong>夏普比率</strong><cite><a href=\"http://wiki.mbalib.com/wiki/%E5%A4%8F%E6%99%AE%E6%AF%94%E7%8E%87\" target=\"_blank\" rel=\"noopener\">wiki.mbalib.com/wiki/%E5%A4%8F%E6%99%AE%E6%AF%94%E7%8E%87</a></cite></footer></blockquote>\n<h5 id=\"以下计算夏普比率的公式使用：\"><a href=\"#以下计算夏普比率的公式使用：\" class=\"headerlink\" title=\"以下计算夏普比率的公式使用：\"></a>以下计算夏普比率的公式使用：</h5><p><code>日收益 减去 日化无风险收益率 的均值 / 日收益 减去 日化无风险收益率 的标准差</code></p>\n<p><code>S = mean(daily_rets - daily_rf) / std(daily_rets - daily_rf)</code></p>\n<p>什么是日化无风险收益率？视频中采用了 <em>伦敦银行同业拆放利率、3月期国债利率、0%</em>。</p>\n<p>如何计算日化收益率？假设年收益为10%，每年有252个交易日。那么日收益率：</p>\n<p>daily_rf = $\\sqrt[252]{1.0+0.1}-1$</p>\n<p>将 daily_rf 视为一个常数时（和将常数视作0的效果一样），可以将计算公式改为：</p>\n<p><code>S = mean(daily_rets - daily_rf) / std(daily_rets)</code></p>\n<blockquote>\n<p>夏普比率对于相同资产可以有相当大的变化。<strong>取决于采样的频繁度</strong></p>\n<p>如果每年采样股票价格，并且基于年化统计量计算，会得到一个数字；如果每月采样，会得到不同的数字；如果改成每日采样，又会得到另一个数字。</p>\n<p><strong>最初版本的夏普比率是一个年化的测量值。所以如果需要以非年化的采样来计算，那么需要加上一个调整因子来使其正常工作。</strong></p>\n<p><code>SRannualized = K * SR</code></p>\n<p>调整因子（K）是每年的采样数量值的平方根。</p>\n<p>假设使用的是每日采样，一年共有252个交易日。daily K = $\\sqrt{252}$</p>\n<p>假设使用的是每周采样，一年共有52个交易周。daily K = $\\sqrt{52}$</p>\n<p>假设使用的是每月采样，一年共有12个交易月。daily K = $\\sqrt{12}$</p>\n<p><strong>即便某支股票一年只交易了80天，在以每日采样计算调整因子时，还是应该是用252来进行计算</strong></p>\n</blockquote>\n<h4 id=\"What-is-an-optimizer（优化器）\"><a href=\"#What-is-an-optimizer（优化器）\" class=\"headerlink\" title=\"What is an optimizer（优化器）\"></a>What is an optimizer（优化器）</h4><ul>\n<li>用来寻找函数最小值</li>\n<li>从数据中查找并建立参数化模型（从实验数据中找到一个多项式来拟合实验数据）</li>\n<li>使用优化器来改善股票投资组合中的分配方式</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> scipy.optimize <span class=\"keyword\">as</span> spo</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span><span class=\"params\">(X)</span>:</span></span><br><span class=\"line\">    Y = (X - <span class=\"number\">1.5</span>) ** <span class=\"number\">2</span> + <span class=\"number\">0.5</span></span><br><span class=\"line\">    print(<span class=\"string\">\"X=&#123;0&#125;,Y=&#123;1&#125;\"</span>.format(X, Y))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Y</span><br><span class=\"line\"></span><br><span class=\"line\">Xguess = <span class=\"number\">2.0</span></span><br><span class=\"line\">min_result = spo.minimize(f, Xguess, method=<span class=\"string\">'SLSQP'</span>, options=&#123;<span class=\"string\">'disp'</span>: <span class=\"keyword\">True</span>&#125;)</span><br><span class=\"line\">print(<span class=\"string\">'Minima found at:'</span>)</span><br><span class=\"line\">print(<span class=\"string\">\"X=&#123;0&#125;,Y=&#123;1&#125;\"</span>.format(min_result.x, min_result.fun))</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">X=[ 2.],Y=[ 0.75]</span><br><span class=\"line\">X=[ 2.],Y=[ 0.75]</span><br><span class=\"line\">X=[ 2.00000001],Y=[ 0.75000001]</span><br><span class=\"line\">X=[ 0.99999999],Y=[ 0.75000001]</span><br><span class=\"line\">X=[ 1.5],Y=[ 0.5]</span><br><span class=\"line\">X=[ 1.5],Y=[ 0.5]</span><br><span class=\"line\">X=[ 1.50000001],Y=[ 0.5]</span><br><span class=\"line\">Optimization terminated successfully.    (Exit mode 0)</span><br><span class=\"line\">            Current function value: 0.5</span><br><span class=\"line\">            Iterations: 2</span><br><span class=\"line\">            Function evaluations: 7</span><br><span class=\"line\">            Gradient evaluations: 2</span><br><span class=\"line\">Minima found at:</span><br><span class=\"line\">X=[ 1.5],Y=0.5</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">Xplot = np.linspace(<span class=\"number\">0.5</span>, <span class=\"number\">2.5</span>, <span class=\"number\">21</span>)</span><br><span class=\"line\">Yplot = f(Xplot)</span><br><span class=\"line\">plt.plot(Xplot, Yplot)</span><br><span class=\"line\">plt.plot(min_result.x, min_result.fun, <span class=\"string\">'ro'</span>)</span><br><span class=\"line\">plt.title(<span class=\"string\">'Minima of an objective function'</span>)</span><br><span class=\"line\">plt.show()</span><br></pre></td></tr></table></figure>\n<p><img src=\"1532660052844.png\" alt=\"1532659982849\"></p>\n<h4 id=\"Convex-Problems-凸问题\"><a href=\"#Convex-Problems-凸问题\" class=\"headerlink\" title=\"Convex Problems (凸问题)\"></a>Convex Problems (凸问题)</h4><p><strong>凸集必定有局部最小值，同时这个局部最小值也就是全局最小值。</strong></p>\n<h4 id=\"构建参数化模型\"><a href=\"#构建参数化模型\" class=\"headerlink\" title=\"构建参数化模型\"></a>构建参数化模型</h4><p>什么是参数化模型？<code>f(x) = mx+b</code>这是个关于 x 的函数，它有两个参数 m 和 b。</p>\n<p>优化器就是通过不断的修改参数值并迭代函数，来找到函数的最优解。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_portfoilo</span><span class=\"params\">(symbols, start, end, allocs, start_values)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"获取投资组合与沪深300指数的收益比较</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    :param symbols: 投资组合</span></span><br><span class=\"line\"><span class=\"string\">    :param start: 开始日期</span></span><br><span class=\"line\"><span class=\"string\">    :param end: 结束日期</span></span><br><span class=\"line\"><span class=\"string\">    :param allocs: 投资组合比率</span></span><br><span class=\"line\"><span class=\"string\">    :param start_values: 初始总投资额</span></span><br><span class=\"line\"><span class=\"string\">    :return:</span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\">    df = get_datas(symbols, start, end)</span><br><span class=\"line\">    normed = normalization(df)</span><br><span class=\"line\">    alloced = normed.copy().drop(<span class=\"string\">'000300'</span>, axis=<span class=\"number\">1</span>) * allocs</span><br><span class=\"line\">    pos_vals = alloced * start_values</span><br><span class=\"line\">    port_val = pos_vals.sum(axis=<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> normalization(pd.DataFrame(port_val.copy(),</span><br><span class=\"line\">                                      columns=[<span class=\"string\">'Portfoilo'</span>]).join(df[<span class=\"string\">'000300'</span>]))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 投资组合一年的表现与沪深300指数的比较</span></span><br><span class=\"line\">portpoilo = get_portfoilo(SYMBOLS, START, END, ALLOCS, START_VALS)</span><br><span class=\"line\">portpoilo.show()</span><br><span class=\"line\">plt.grid()</span><br><span class=\"line\">plt.show()</span><br></pre></td></tr></table></figure>\n<p><img src=\"1532677939302.png\" alt=\"1532677809156\"></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 修改投资比率</span></span><br><span class=\"line\">portpoilo = get_portfoilo(SYMBOLS, START, END, [<span class=\"number\">0.5</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0.5</span>], START_VALS)</span><br><span class=\"line\">portpoilo.plot()</span><br><span class=\"line\">plt.grid()</span><br><span class=\"line\">plt.show()</span><br></pre></td></tr></table></figure>\n<p><img src=\"1532678552063.png\" alt=\"1532678552063\"></p>\n<p>优化器的作用就在于确定如何找到最优的投资比率和股票组合。</p>\n<h3 id=\"Types-of-funds（基金类型）\"><a href=\"#Types-of-funds（基金类型）\" class=\"headerlink\" title=\"Types of funds（基金类型）\"></a>Types of funds（基金类型）</h3><ul>\n<li>ETF <a href=\"https://zh.wikipedia.org/wiki/ETF\" target=\"_blank\" rel=\"noopener\">交易所交易基金、交易所买卖基金</a></li>\n<li>Mutual Fund <a href=\"https://zh.wikipedia.org/wiki/%E5%85%B1%E5%90%8C%E5%9F%BA%E9%87%91\" target=\"_blank\" rel=\"noopener\">共同基金</a></li>\n<li>Hedge Fund <a href=\"https://zh.wikipedia.org/wiki/%E5%AF%B9%E5%86%B2%E5%9F%BA%E9%87%91\" target=\"_blank\" rel=\"noopener\">对冲基金</a></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th><strong>Parameter</strong></th>\n<th><strong>Hedge Fund</strong></th>\n<th><strong>Mutual Fund</strong></th>\n<th><strong>ETF</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>Return</strong></td>\n<td><em>Absolute return</em></td>\n<td><em>Relative return</em></td>\n<td><em>Relative return</em></td>\n</tr>\n<tr>\n<td><strong>Management</strong></td>\n<td><em>Actively managed</em></td>\n<td><em>Comparatively less actively managed</em></td>\n<td><em>Passively managed</em></td>\n</tr>\n<tr>\n<td><strong>Fees</strong></td>\n<td><em>Performance based fee</em></td>\n<td><em>Percentage of assets managed fees</em></td>\n<td><em>–</em></td>\n</tr>\n<tr>\n<td><strong>Transaction Price</strong></td>\n<td><em>–</em></td>\n<td><em>NAV</em></td>\n<td><em>Quoted price</em></td>\n</tr>\n<tr>\n<td><strong>Transparency</strong></td>\n<td><em>Information disclosed to investors only</em></td>\n<td><em>Annually published reports and disclosure</em></td>\n<td><em>Daily disclosure of holdings</em></td>\n</tr>\n<tr>\n<td><strong>Regulation</strong></td>\n<td><em>Less regulation</em></td>\n<td><em>Regulated by SEBI</em></td>\n<td><em>Regulated by Securities and Exchange Commission</em></td>\n</tr>\n<tr>\n<td><strong>Liquidity</strong></td>\n<td><em>Low</em></td>\n<td><em>High</em></td>\n<td><em>High</em></td>\n</tr>\n<tr>\n<td><strong>Cost</strong></td>\n<td><em>–</em></td>\n<td><em>High average expense ratio</em></td>\n<td><em>Low average expense ratio</em></td>\n</tr>\n<tr>\n<td><strong>Investor Type</strong></td>\n<td><em>High net worth individuals</em></td>\n<td><em>Retail investors</em></td>\n<td><em>Retail investors</em></td>\n</tr>\n<tr>\n<td><strong>Fractional Shares</strong></td>\n<td><em>No</em></td>\n<td><em>Yes</em></td>\n<td><em>No</em></td>\n</tr>\n<tr>\n<td><strong>Ownership of Fund Manager</strong></td>\n<td><em>Substantial ownership</em></td>\n<td><em>Non substantial ownership</em></td>\n<td><em>–</em></td>\n</tr>\n<tr>\n<td><strong>Owners</strong></td>\n<td><em>Few owners</em></td>\n<td><em>Many owners</em></td>\n<td><em>–</em></td>\n</tr>\n<tr>\n<td><strong>Minimum amount to be invested</strong></td>\n<td><em>High</em></td>\n<td><em>Low</em></td>\n<td><em>Low</em></td>\n</tr>\n<tr>\n<td><strong>Tax</strong></td>\n<td><em>–</em></td>\n<td><em>High percentage of tax levied on capital gains</em></td>\n<td><em>Comparatively lower tax percentages are levied</em></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"如何计算估值\"><a href=\"#如何计算估值\" class=\"headerlink\" title=\"如何计算估值\"></a>如何计算估值</h3><blockquote><p>金钱的未来终值（future value）应大于现值（present value）</p>\n<footer><strong>金钱的时间价值</strong><cite><a href=\"https://zh.wikipedia.org/wiki/%E9%87%91%E9%8C%A2%E7%9A%84%E6%99%82%E9%96%93%E5%83%B9%E5%80%BC\" target=\"_blank\" rel=\"noopener\">zh.wikipedia.org/wiki/%E9%87%91%E9%8C%A2%E7%9A%84%E6%99%82%E9%96%93%E5%83%B9%E5%80%BC</a></cite></footer></blockquote>\n<p><strong>计算:</strong></p>\n<p>假设某人以利率 $i$ （$i=5\\%$与$i=0.05$等同）借出或借入一笔款项，期限为 $t$ 年，则 $t$ 年后的 $C$ 个货币单位现值表达为：$C_{t}=\\frac{C}{(1+i)^{t}}$</p>\n<p>$t$ 年后的 $C$ 个莫比单位现时购买力也可以用上式计算，此时 $i$ 表示 <em>通货膨胀率</em>。</p>\n<p>同一组现金流可能根据利率的不同被分为数个时段，例如，从此时算起的第一年内的利率为 $i_1$ ，第二年的利率为 $i_2$ ，那么两年后的 $C$ 个货币单位的现值表达式为：$PV=\\frac{C}{(1+i_1)(1+i_2)}$</p>\n<ul>\n<li><strong>内在价值</strong></li>\n<li><strong>账面价值</strong>：$总资产-无形资产-负债$</li>\n<li><strong>市值</strong></li>\n</ul>\n<h3 id=\"资本资产定价模型-（CAPM）\"><a href=\"#资本资产定价模型-（CAPM）\" class=\"headerlink\" title=\"资本资产定价模型 （CAPM）\"></a>资本资产定价模型 （CAPM）</h3><blockquote><p>资本资产定价模型（英语：Capital Asset Pricing Model, CAPM）是由美国学者威廉·夏普（William Sharpe）、林特尔（John Lintner）、特里诺（Jack Treynor）和莫辛（Jan Mossin）等人在现代投资组合理论的基础上发展起来的，是现代金融市场价格理论的支柱，广泛应用于投资决策和公司理财领域。资本资产定价模型中，所谓资本资产主要指的是股票资产，而定价则试图解释资本市场如何决定股票收益率，进而决定股票价格。</p>\n<p>根据资本资产定价模型，对于一个给定的资产 $i$，它的期望收益率和市场投资组合的期望收益率之间的关系可以表示为：</p>\n<p>$E(r_i)=r_f+\\beta_im[E(r_m)-r_f]]$</p>\n<p>其中：</p>\n<ul>\n<li>$E(r_i)$是资产 $i$ 的期望收益率（或普通股的资本成本率）</li>\n<li>$r_f$ 是无风险收益率，通常以短期国债的利率来近似替代</li>\n<li>$\\beta_{im}$ 是资产 $i$ 的系统性风险系数，$\\beta_{im}={\\frac{Cov(r_i,r_m)}{Var(r_m)}}$ </li>\n<li>$E(r_{m})$市场投资组合 $m$ 的期望收益率，通常用股票价格指数收益率的平均值或所有股票的平均收益率来代替</li>\n<li>$E(r_{m})-r_{f}$市场风险溢价（英语：Market Risk Premium），即市场投资组合的期望收益率与无风险收益率之差</li>\n</ul>\n<p>CAPM模型是建立在一系列假设的基础上的，其中主要包括：</p>\n<ul>\n<li>所有投资者均追求单期财富的期望效用最大化，并以各备选组合的期望收益和标准差为基础进行组合选择。</li>\n<li>所有投资者均可以无风险利率无限制地借入或贷出资金。</li>\n<li>所有投资者拥有同样预期，即对所有资产收益的均值、方差和协方差等，投资者均有完全相同的主观估计。</li>\n<li>所有资产均可被完全细分，拥有充分的流动性且没有交易成本。</li>\n</ul>\n<p>没有税金。</p>\n<ul>\n<li>所有投资者均为价格接受者。即任何一个投资者的买卖行为都不会对股票价格产生影响。</li>\n<li>所有资产的数量是给定的和固定不变的。</li>\n</ul>\n<p>近年的实证研究表明，CAPM模型在实际中并不能验证历史的投资收益，由此Roll在1977年提出了两种可能：一种是CAPM模型在市场上是无效的，一种是CAPM理论存在模型的设定误差；基于后一种可能，APT理论和不少多因子模型不断诞生——例如FAMA-FRENCH的三因子模型。但是由于CAPM的简单和便于理解，在业界运用非常广泛，特别是在估值分析中确定必要报酬率（英语：Required Return of Equity）。</p>\n<footer><strong>资本资产定价模型</strong><cite><a href=\"https://zh.wikipedia.org/wiki/%E8%B5%84%E6%9C%AC%E8%B5%84%E4%BA%A7%E5%AE%9A%E4%BB%B7%E6%A8%A1%E5%9E%8B\" target=\"_blank\" rel=\"noopener\">zh.wikipedia.org/wiki/%E8%B5%84%E6%9C%AC%E8%B5%84%E4%BA%A7%E5%AE%9A%E4%BB%B7%E6%A8%A1%E5%9E%8B</a></cite></footer></blockquote>\n<p><img src=\"1533869822902.png\" alt=\"1533869822902\"></p>\n<h3 id=\"套利定价理论（APT）\"><a href=\"#套利定价理论（APT）\" class=\"headerlink\" title=\"套利定价理论（APT）\"></a>套利定价理论（APT）</h3><p><a href=\"https://youtu.be/yMMoukwU87I\" target=\"_blank\" rel=\"noopener\">https://youtu.be/yMMoukwU87I</a></p>\n<p><a href=\"http://wiki.mbalib.com/wiki/%E5%A5%97%E5%88%A9%E5%AE%9A%E4%BB%B7%E7%90%86%E8%AE%BA\" target=\"_blank\" rel=\"noopener\">套利定价理论-MBAlib</a></p>\n<h3 id=\"技术分析\"><a href=\"#技术分析\" class=\"headerlink\" title=\"技术分析\"></a>技术分析</h3><h4 id=\"技术分析的特征\"><a href=\"#技术分析的特征\" class=\"headerlink\" title=\"技术分析的特征\"></a>技术分析的特征</h4><ul>\n<li>只关注历史价格和成交量</li>\n<li>在时间序列中计算统计数据称为指标</li>\n<li>指标是启发式的</li>\n</ul>\n<h4 id=\"使技术分析有价值的因素\"><a href=\"#使技术分析有价值的因素\" class=\"headerlink\" title=\"使技术分析有价值的因素\"></a>使技术分析有价值的因素</h4><ul>\n<li>个别指标具有弱预测性，但结合多个指标可以增加价值</li>\n<li>寻找对比（单个股票 VS 市场）（找到比市场收益更好的单个或组合）</li>\n<li>在短时间内比在较长时间内工作得更有效</li>\n</ul>\n<blockquote>\n<p>持有时间越长，价值分析越重要，需要作出判断的时间越长，判断复杂度越高。（更适合人类进行分析）</p>\n<p>反之，持有时间越短，技术分析越重要，需要作出判断的时间越短，判断复杂度越低。（更适合计算机做高频分析）</p>\n</blockquote>\n<p><img src=\"1533883675299.png\" alt=\"1533883675299\"></p>\n<h4 id=\"部分技术分析的指标\"><a href=\"#部分技术分析的指标\" class=\"headerlink\" title=\"部分技术分析的指标\"></a>部分技术分析的指标</h4><ul>\n<li><p>动量（momentum）</p>\n<blockquote><p>$MO_t=(P_t/P_{t-n})*100$<br>其中 $n$ 為天數，$P_t$ 為當日股價，$P_{t-n} $ 為  $n$ 日前的股價</p>\n<ol>\n<li>MO&gt;100时，表示目前股价行情较N日前偏多看待，相对该股票市场行情反应较为热络。</li>\n<li>MO&lt;100时，表示目前股价行情较N日前偏空看待，相对该股票行情市场反应较为冷淡。</li>\n<li>MO由正转负，表示目前股价行情已转为偏空看待，多方投资人需要注意。</li>\n<li>MO由负转正，表示目前股价行情已转为偏多看待，空方投资人需要注意。</li>\n</ol>\n<footer><strong>运动量震荡指标</strong><cite><a href=\"https://zh.wikipedia.org/wiki/%E9%81%8B%E5%8B%95%E9%87%8F%E9%9C%87%E7%9B%AA%E6%8C%87%E6%A8%99\" target=\"_blank\" rel=\"noopener\">zh.wikipedia.org/wiki/%E9%81%8B%E5%8B%95%E9%87%8F%E9%9C%87%E7%9B%AA%E6%8C%87%E6%A8%99</a></cite></footer></blockquote>\n</li>\n<li><p>移动平均线（SMA）</p>\n<blockquote>\n<ol>\n<li><p>寻找价格穿过简单移动平均线的点。</p>\n<p>momentum+SMA cross可能会是买入或卖出的指标。</p>\n</li>\n<li><p>可以将移动平均线看成是一个时间段上的公司价值。股价会在移动平均线上下波动。</p>\n</li>\n</ol>\n</blockquote>\n<p><img src=\"1533886709495.png\" alt=\"1533886709495\"></p>\n<blockquote><ul>\n<li><p><strong>简单移动平均</strong>（英语：simple moving average，SMA）是某变数之前 $n$ 个数值的未作加权算术平均。例如，收市价的10日简单移动平均指之前10日收市价的平均数。若设收市价为 $p_{1}$至 $p_{n}$，则方程式为：</p>\n<p>$SMA={p_{1}+p_{2}+\\cdots +p_{n} \\over n}$<br>当计算连续的数值，一个新的数值加入，同时一个旧数值剔出，所以无需每次都重新逐个数值加起来：</p>\n<p>$SMA_{t1,n}=SMA_{t0,n}-{p_{1} \\over n}+{p_{n+1} \\over n}$<br>在技术分析中，不同的市场对常用天数（$n$值）有不同的需求，例如：某些市场普遍的$n$值为10日、40日、200日；有些则是5日、10日、20日、60日、120日、240日，视乎分析时期长短而定。投资者冀从移动平均线的图表中分辨出支持位或阻力位。</p>\n</li>\n<li><p><strong>指数移动平均</strong>（英语：exponential moving average，EMA或EWMA）是以指数式递减加权的移动平均。各数值的加权影响力随时间而指数式递减，越近期的数据加权影响力越重，但较旧的数据也给予一定的加权值。右图是一例子。</p>\n<p>加权的程度以常数 $α$ 决定，$α$ 数值介乎0至1。$α$ 也可用天数 $N$ 来代表： $\\alpha ={2 \\over {N+1}}$，所以，$N$=19天，代表$α=0.1$。</p>\n<p>设时间 $t$ 的实际数值为$Y_t$，而时间 $t$ 的EMA则为$S_t$；时间 $t-1$ 的EMA则为$S_{t-1}$，计算时间 $t≥2$ 是方程式为：</p>\n<p>$S_{t}=\\alpha <em> Y_{t}+(1-\\alpha )</em> S_{t-1}$<br>设今日（$t1$）价格为 $p$，则今日（$t1$）EMA的方程式为：</p>\n<p>$EMA_{t1}={\\text{EMA}}<em>{t0}+\\alpha \\times (p-{\\text{EMA}}</em>{t0})$<br>将 ${\\text{EMA}}_{t0}$分拆开来如下：</p>\n<p>${\\text{EMA}}={p_{1}+(1-\\alpha )p_{2}+(1-\\alpha )^{2}p_{3}+(1-\\alpha )^{3}p_{4}+\\cdots \\over 1+(1-\\alpha )+(1-\\alpha )^{2}+(1-\\alpha )^{3}+\\cdots }$<br>理论上这是一个无穷级数，但由于 $1-α$ 少于1，各项的数值会越来越细，可以被忽略。分母方面，若有足够多项，则其数值趋向 $1/α$。即，</p>\n<p>${\\text{EMA}}=\\alpha \\times \\left(p_{1}+(1-\\alpha )p_{2}+(1-\\alpha )^{2}p_{3}+(1-\\alpha )^{3}p_{4}+\\cdots \\right)$<br>假设 $k$ 项及以后的项被忽略，即 $\\alpha \\times \\left((1-\\alpha )^{k}+(1-\\alpha )^{k+1}+\\cdots \\right)$，重写后可得$\\alpha \\times (1-\\alpha )^{k}\\times \\left(1+(1-\\alpha )+(1-\\alpha )^{2}\\cdots \\right)$，相当于 $(1-\\alpha )^{k}$。所以，若要包含99.9%的加权，解方程 $k={\\log(0.001) \\over \\log(1-\\alpha )}$即可得出$k$。由于当$N$不断增加， $\\log \\,(1-\\alpha )$将趋向 $-2 \\over N+1$，简化后k大约等于 $3.45\\times (N+1)$。</p>\n</li>\n<li><p><strong>加权移动平均</strong>（英语：weighted moving average，WMA）指计算平均值时将个别数据乘以不同数值，在技术分析中，$n$日WMA的最近期一个数值乘以$n$、次近的乘以$n-1$，如此类推，一直到0：</p>\n<p>$WMA_{M}={np_{M}+(n-1)p_{M-1}+\\cdots +2p_{M-n+2}+p_{M-n+1} \\over n+(n-1)+\\cdots +2+1}$</p>\n<p>由于 $WMA_{M+1}$与 $WMA_{M}$的分子相差 $np_{M+1}-p_{M}-\\cdots -p_{M-n+1}$，假设 $p_{M}+p_{M-1}+\\cdots +p_{M-n+1}$为总和$M$：</p>\n<p>$总和<em>{M+1} =总和</em>{M}+p_{M+1}-p_{M-n+1}$<br>$分子<em>{M+1}=N</em>{M+1}=分子<em>M+np</em>{M+1}-总和<em>M$<br>$WMA</em>{M+1}={N_{M+1} \\over n+(n-1)+\\cdots +2+1}$<br>留意分母为三角形数，方程式为 $n(n+1) \\over 2$</p>\n<p>右图显示出加权是随日子远离而递减，直至递减至零。</p>\n</li>\n</ul>\n<footer><strong>移动平均</strong><cite><a href=\"https://zh.wikipedia.org/wiki/%E7%A7%BB%E5%8B%95%E5%B9%B3%E5%9D%87\" target=\"_blank\" rel=\"noopener\">zh.wikipedia.org/wiki/%E7%A7%BB%E5%8B%95%E5%B9%B3%E5%9D%87</a></cite></footer></blockquote>\n</li>\n<li><p><a href=\"https://zh.wikipedia.org/wiki/%E5%B8%83%E6%9E%97%E5%B8%A6\" target=\"_blank\" rel=\"noopener\">布林带</a> </p>\n<blockquote><p>“布林带”是这样定义的：</p>\n<p>中轨 = $N$ 时间段的简单移动平均线<br>上轨 = 中轨 + $K × N$时间段的标准差<br>下轨 = 中轨 − $K × N$时间段的标准差<br>一般情况下，设定N=20和K=2，这两个数值也是在布林带当中使用最多的。在日线图里，N=20其实就是“月均线”（MA20）。依照正态分布规则，约有95%的数值会分布在距离平均值有正负2个标准差（ $\\pm 2\\sigma$ ）的范围内。</p>\n<footer><strong>移动平均</strong><cite><a href=\"https://zh.wikipedia.org/wiki/%E7%A7%BB%E5%8B%95%E5%B9%B3%E5%9D%87\" target=\"_blank\" rel=\"noopener\">zh.wikipedia.org/wiki/%E7%A7%BB%E5%8B%95%E5%B9%B3%E5%9D%87</a></cite></footer></blockquote>\n<p><img src=\"1533890419564.png\" alt=\"1533890419564\"></p>\n</li>\n</ul>\n<blockquote>\n<p><strong>单纯使用穿越布林带上轨和下轨来作为买入卖出依据虽然看上去很美，但是个人认为并不能作为唯一条件。</strong></p>\n<p>以 2017-01-01 ~ 2017-12-31 日之间的 600016 交易数据判断。</p>\n<p><em>模拟操作为 一次购买机会买入100股，每遇到一次卖出机会卖出持有的所有股份。</em></p>\n<p>在模拟日期间共出现 7 次购买机会，前六次购买后卖出时亏损了360元。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;             Close_Adj   mean_20         top   ...    Rate      C     Sum</span><br><span class=\"line\">&gt; Date                                          ...                       </span><br><span class=\"line\">&gt; 2017-02-20     157.27  157.5570  159.230044   ...    0.53 -100.0  -914.0</span><br><span class=\"line\">&gt; 2017-03-06     154.61  156.3465  158.153251   ...    0.20 -100.0  -896.0</span><br><span class=\"line\">&gt; 2017-03-13     153.14  155.4830  158.303460   ...    0.15 -100.0  -886.0</span><br><span class=\"line\">&gt; 2017-03-23     149.15  153.3205  157.689392   ...    0.34 -100.0  -859.0</span><br><span class=\"line\">&gt; 2017-04-17     143.84  147.8400  152.270060   ...    0.51 -100.0  -823.0</span><br><span class=\"line\">&gt; 2017-04-21     138.97  145.6275  152.778017   ...    0.31 -100.0  -790.0</span><br><span class=\"line\">&gt; 2017-05-26     140.60  138.2060  141.390432   ...    0.71  600.0  4806.0</span><br><span class=\"line\">&gt; 2017-06-29     144.14  141.6690  144.347758   ...    0.26    NaN     NaN</span><br><span class=\"line\">&gt; 2017-07-18     151.00  144.9020  151.131555   ...    0.65    NaN     NaN</span><br><span class=\"line\">&gt; 2017-07-20     151.88  145.9120  153.310778   ...    0.45    NaN     NaN</span><br><span class=\"line\">&gt; 2017-08-15     146.28  150.4675  155.338483   ...    0.32 -100.0  -823.0</span><br><span class=\"line\">&gt; 2017-11-01     148.20  146.5935  148.700933   ...    0.27  100.0   824.0</span><br><span class=\"line\">&gt; 2017-11-09     150.11  147.4940  150.556908   ...    0.29    NaN     NaN</span><br><span class=\"line\">&gt; 2017-11-27     161.03  152.3635  161.544288   ...    0.76    NaN     NaN</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; [14 rows x 16 columns]</span><br><span class=\"line\">&gt; 600016 : -361.0/0</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>从图中可以看出 2017-02-17，2017-03-03 分别给出了从 布林带下方穿越布林带的信号，但是结果却非常不理想。</p>\n<p><img src=\"image-20180811213410404.png\" alt=\"image-20180811213410404\"></p>\n<p>对于上证50指数的所有股票进行 2017-01-01 ~ 2017-12-31 期间的数据模拟，效果依然不是很理想。去年盈利10000+，但是截至 2017-12-31 却持有价值 80000+ 的股票。</p>\n<p><strong>应该参考之前的 “投资组合” 选出合适的能够跑赢指数均值的组合 和其他分析指标共同分析。</strong></p>\n<p>代码：<a href=\"https://github.com/GuQiangJS/studySource/blob/master/codes/python/machine-learning-for-trading/tests/test_plot_bbands.py\" target=\"_blank\" rel=\"noopener\">https://github.com/GuQiangJS/studySource/blob/master/codes/python/machine-learning-for-trading/tests/test_plot_bbands.py</a></p>\n</blockquote>\n<h3 id=\"数据分析\"><a href=\"#数据分析\" class=\"headerlink\" title=\"数据分析\"></a>数据分析</h3><h4 id=\"Survior-bias\"><a href=\"#Survior-bias\" class=\"headerlink\" title=\"Survior bias\"></a>Survior bias</h4><p><a href=\"https://youtu.be/RCB2hkiwqnA\" target=\"_blank\" rel=\"noopener\">https://youtu.be/RCB2hkiwqnA</a></p>\n<blockquote>\n<p> 使用同样的时间间隔分析同一成分股集合时，选取成分股集合的时间点会造成不同的结果。采用分析时间结束时的成分股集合时会得到更加漂亮、诱人、但不真实的结果。<strong>应该选取分析时间开始时的集合</strong>。</p>\n</blockquote>\n<p><img src=\"1534238787357.png\" alt=\"1534238787357\"></p>\n<h4 id=\"效率市场假说\"><a href=\"#效率市场假说\" class=\"headerlink\" title=\"效率市场假说\"></a>效率市场假说</h4><blockquote><ul>\n<li><p>弱式效率（Weak Form Efficiency）</p>\n<p>目前股票价格已充分反映了过去股票价格所提供的各项情报。所以，投资人无法再运用各种方法对过去股票价格进行分析，再利用分析结果来预测未来股票价格，基于随机游走假说，未来消息是随机而来的。意即投资者无法再利用过去资讯来获得高额报酬。所以，弱势效率越高，若以过去价量为基础的技术分析来进行预测效果将会十分不准确。</p>\n<blockquote>\n<p>留下了可以从事基本面分析的口子。</p>\n</blockquote>\n</li>\n<li><p>半强式效率（Semi-Strong Form Efficiency）</p>\n<p>目前股票价格已充分反应了所有公开资讯，所以，投资者无法利用情报分析结果来进行股票价格预测而获取高额报酬。因此，半强式效率越高，依赖公开的财务报表、经济情况及政治情势来进行基本面分析，然后再预测股票价格是徒劳无功。</p>\n<blockquote>\n<p>连基本面分析都不行了。只能通过内幕交易了。</p>\n</blockquote>\n</li>\n<li><p>强式效率（Strong Form Efficiency）</p>\n<p>目前股票价格充分反应了所有已公开和未公开之所有情报。虽然情报未公开，但投资者能利用各种管道来获得资讯，所以，所谓未公开的消息，实际上是已公开的资讯且已反应于股票价格上。此种情形下，投资者也无法因拥有某些股票内幕消息而获取高额报酬。 </p>\n<blockquote>\n<p>连内部交易都没机会了。</p>\n</blockquote>\n</li>\n</ul>\n<footer><strong>效率市场假说</strong><cite><a href=\"https://zh.wikipedia.org/wiki/%E6%95%88%E7%8E%87%E5%B8%82%E5%A0%B4%E5%81%87%E8%AA%AA\" target=\"_blank\" rel=\"noopener\">zh.wikipedia.org/wiki/%E6%95%88%E7%8E%87%E5%B8%82%E5%A0%B4%E5%81%87%E8%AA%AA</a></cite></footer></blockquote>\n<h4 id=\"Grinold’s-fundamental-law\"><a href=\"#Grinold’s-fundamental-law\" class=\"headerlink\" title=\"Grinold’s fundamental law\"></a>Grinold’s fundamental law</h4><p><a href=\"https://youtu.be/W6yUgs1OLx0\" target=\"_blank\" rel=\"noopener\">https://youtu.be/W6yUgs1OLx0</a></p>\n<p>$performance=Skill \\times \\sqrt{breadth}$</p>\n<h4 id=\"通过协方差构建投资组合（获得相同回报，但降低波动性）\"><a href=\"#通过协方差构建投资组合（获得相同回报，但降低波动性）\" class=\"headerlink\" title=\"通过协方差构建投资组合（获得相同回报，但降低波动性）\"></a>通过协方差构建投资组合（获得相同回报，但降低波动性）</h4><p><a href=\"https://zh.wikipedia.org/wiki/%E7%8E%B0%E4%BB%A3%E6%8A%95%E8%B5%84%E7%BB%84%E5%90%88%E7%90%86%E8%AE%BA\" target=\"_blank\" rel=\"noopener\">现代投资组合理论</a></p>\n<h3 id=\"机器学习\"><a href=\"#机器学习\" class=\"headerlink\" title=\"机器学习\"></a>机器学习</h3><h4 id=\"监督回归学习\"><a href=\"#监督回归学习\" class=\"headerlink\" title=\"监督回归学习\"></a>监督回归学习</h4><ul>\n<li>线性回归（参数式）</li>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E6%9C%80%E8%BF%91%E9%84%B0%E5%B1%85%E6%B3%95\" target=\"_blank\" rel=\"noopener\">最近邻居法</a>（实例式）</li>\n<li>决策树</li>\n<li>决策森林</li>\n</ul>\n<h4 id=\"Price-forecasting-demo\"><a href=\"#Price-forecasting-demo\" class=\"headerlink\" title=\"Price forecasting demo\"></a>Price forecasting demo</h4><p><a href=\"https://youtu.be/GVOEnkjmBZU\" target=\"_blank\" rel=\"noopener\">https://youtu.be/GVOEnkjmBZU</a></p>\n<p><img src=\"1535439244770.png\" alt=\"1535439244770\"></p>\n<h4 id=\"强化学习\"><a href=\"#强化学习\" class=\"headerlink\" title=\"强化学习\"></a>强化学习</h4><h3 id=\"过拟合\"><a href=\"#过拟合\" class=\"headerlink\" title=\"过拟合\"></a>过拟合</h3><h4 id=\"集成学习-Ensemble-learning\"><a href=\"#集成学习-Ensemble-learning\" class=\"headerlink\" title=\"集成学习 (Ensemble learning)\"></a>集成学习 (<a href=\"https://en.wikipedia.org/wiki/Ensemble_learning\" target=\"_blank\" rel=\"noopener\">Ensemble learning</a>)</h4><p><img src=\"1536045019373.png\" alt=\"1536045019373\"></p>\n<h4 id=\"Bagging算法-Bootstrap-aggregating\"><a href=\"#Bagging算法-Bootstrap-aggregating\" class=\"headerlink\" title=\"Bagging算法(Bootstrap aggregating)\"></a>Bagging算法(<a href=\"https://zh.wikipedia.org/wiki/Bagging%E7%AE%97%E6%B3%95\" target=\"_blank\" rel=\"noopener\">Bootstrap aggregating</a>)</h4><h4 id=\"AdaBoost\"><a href=\"#AdaBoost\" class=\"headerlink\" title=\"AdaBoost\"></a><a href=\"https://zh.wikipedia.org/wiki/AdaBoost\" target=\"_blank\" rel=\"noopener\">AdaBoost</a></h4><p><a href=\"https://www.youtube.com/watch?v=GM3CDQfQ4sw&amp;list=PLAwxTw4SYaPnIRwl6rad_mYwEk4Gmj7Mx&amp;index=194\" target=\"_blank\" rel=\"noopener\">https://www.youtube.com/watch?v=GM3CDQfQ4sw&amp;list=PLAwxTw4SYaPnIRwl6rad_mYwEk4Gmj7Mx&amp;index=194</a></p>\n<h3 id=\"数据特征缩放\"><a href=\"#数据特征缩放\" class=\"headerlink\" title=\"数据特征缩放\"></a>数据特征缩放</h3><p><strong>标准化：</strong> $normed={values-mean \\over values.std()}$</p>\n<p>标准化后，数据均值为0，数值将在 -1 和 1 之间变化。</p>\n<blockquote><p>最简单的方式是重新缩放特征的范围到[0, 1]或[-1, 1]， 依据原始的资料选择目标范围，通式如下：$ x’={x-min(x) \\over max(x)-min(x)}$</p>\n<p>$x$ 是原始的值，$x’$ 是被标准化后的值。例如，假设我们有学生的体重资料，范围落在[160磅, 200磅]，为了重新缩放这个资料，我们会先将每个学生的体重减掉160，接着除与40(最大体重与最小体重的差值) </p>\n<footer><strong>重新缩放</strong><cite><a href=\"https://zh.wikipedia.org/wiki/%E7%89%B9%E5%BE%B5%E7%B8%AE%E6%94%BE\" target=\"_blank\" rel=\"noopener\">zh.wikipedia.org/wiki/%E7%89%B9%E5%BE%B5%E7%B8%AE%E6%94%BE</a></cite></footer></blockquote>"},{"title":"敏捷软件开发原则","updated":"2018-05-02T16:00:00.000Z","date":"2018-04-24T10:14:27.000Z","ISBN":9787115294685,"出版社":"人民邮电出版社","出版时间":"2012-10-31T16:00:00.000Z","版次":2,"description":"<!--more-->","photos":["/2018/04/24/minjiekaifa/minjiekaifa.png"],"_content":"\n### 测试驱动开发\n\n简单的3条测试规则：\n\n1. 除非已经编写了一个不能通过的单元测试，否则不编写任何产品代码；\n2. 只要编写能够正好导致测试不通过或者编译失败的单元测试就够了，无需更多；\n3. 只要编写能够正好使失败的单元测试通过的产品代码就够了，无需更多。\n\n#### 测试\n\n**单元测试**是用来验证系统中单个机制的白盒测试（white-box test）。\n\n单元测试可以作为一种非常有价值的文档。如果想知道如何调用一个函数或者创建一个对象，会有一个测试展示给你看。测试就像一套范例，它帮助其他程序员了解如何使用代码。这份文档是可编译的、可运行的、它保持最新。它不会撒谎。\n\n**验收测试**是用来验证系统满足客户需求的黑盒测试（black-box test）。\n\n验收测试是关于一项特性的最终文档。一旦客户编写完成了验证一项特性的验收测试，程序员可以阅读那些验收测试来真正地理解这项特性。所以，正如单元测试作为可编译、可执行的有关系统内部结构的文档那样，验收测试是有关系统特性的可以编译、可执行的文档。简而言之，验收测试是真正的需求文档。\n\n### SRP：单一职责原则\n\n假设有两个不同的应用程序使用Rectangle类。\n\n一个应用程序是有关计算几何学方面的，利用Rectangle类计算几何形状，但不会再屏幕上绘制矩形。\n\n另外一个应用程序实质上是有关图形绘制方面的，它可能也会进行一些计算几何方面的工作，但是它肯定会在屏幕上绘制矩形。\n\n![](498627-20160828231647539-1014399922.png)\n\n此时，Rectangle类具有两个职责。第一个职责提供了一个矩形几何形状的数学模型；第二个职责是把矩形在一个图形用户界面上绘制出来。\n\n对于SRP的违反导致了一些严重的问题。首先，我们必须在计算几何应用程序中包含进GUI代码。在.Net中，就必须要把GUI组建和计算几何应用一起构建、部署。\n\n其次，如果GraphicalApplication的改变由于一些原因导致了Rectangle的改变，那么这个改变会迫使我们重新构建、测试以及部署ComputationalGeometryApplication。如果忘记这样做，ComputationalGeometryApplication可能会以不可预测的方式失败。\n\n![](498627-20160828231739089-846443922.png)\n\n一个较好的设计是把这两个职责分离到两个完全不同的类中。这个设计把Rectangle类中进行计算的部分移动到了GeometricRectangle类中。现在矩形绘制方式的改变不会对ComputationalGeometryApplication类造成影响。","source":"_posts/minjiekaifa.md","raw":"---\ntitle: 敏捷软件开发原则\nupdated: 2018-05-03\ndate: 2018-04-24 18:14:27\nISBN: 9787115294685\n出版社: 人民邮电出版社\n出版时间: 2012-11-01\n版次: 2\n\ndescription: <!--more-->\n\nphotos:\n\n- /2018/04/24/minjiekaifa/minjiekaifa.png\n\ntags: \n\n - 读书\n - 开发\n - 原则\n---\n\n### 测试驱动开发\n\n简单的3条测试规则：\n\n1. 除非已经编写了一个不能通过的单元测试，否则不编写任何产品代码；\n2. 只要编写能够正好导致测试不通过或者编译失败的单元测试就够了，无需更多；\n3. 只要编写能够正好使失败的单元测试通过的产品代码就够了，无需更多。\n\n#### 测试\n\n**单元测试**是用来验证系统中单个机制的白盒测试（white-box test）。\n\n单元测试可以作为一种非常有价值的文档。如果想知道如何调用一个函数或者创建一个对象，会有一个测试展示给你看。测试就像一套范例，它帮助其他程序员了解如何使用代码。这份文档是可编译的、可运行的、它保持最新。它不会撒谎。\n\n**验收测试**是用来验证系统满足客户需求的黑盒测试（black-box test）。\n\n验收测试是关于一项特性的最终文档。一旦客户编写完成了验证一项特性的验收测试，程序员可以阅读那些验收测试来真正地理解这项特性。所以，正如单元测试作为可编译、可执行的有关系统内部结构的文档那样，验收测试是有关系统特性的可以编译、可执行的文档。简而言之，验收测试是真正的需求文档。\n\n### SRP：单一职责原则\n\n假设有两个不同的应用程序使用Rectangle类。\n\n一个应用程序是有关计算几何学方面的，利用Rectangle类计算几何形状，但不会再屏幕上绘制矩形。\n\n另外一个应用程序实质上是有关图形绘制方面的，它可能也会进行一些计算几何方面的工作，但是它肯定会在屏幕上绘制矩形。\n\n![](498627-20160828231647539-1014399922.png)\n\n此时，Rectangle类具有两个职责。第一个职责提供了一个矩形几何形状的数学模型；第二个职责是把矩形在一个图形用户界面上绘制出来。\n\n对于SRP的违反导致了一些严重的问题。首先，我们必须在计算几何应用程序中包含进GUI代码。在.Net中，就必须要把GUI组建和计算几何应用一起构建、部署。\n\n其次，如果GraphicalApplication的改变由于一些原因导致了Rectangle的改变，那么这个改变会迫使我们重新构建、测试以及部署ComputationalGeometryApplication。如果忘记这样做，ComputationalGeometryApplication可能会以不可预测的方式失败。\n\n![](498627-20160828231739089-846443922.png)\n\n一个较好的设计是把这两个职责分离到两个完全不同的类中。这个设计把Rectangle类中进行计算的部分移动到了GeometricRectangle类中。现在矩形绘制方式的改变不会对ComputationalGeometryApplication类造成影响。","slug":"minjiekaifa","published":1,"comments":1,"layout":"post","link":"","_id":"cjof51pjh0002rguexv73xx9s","content":"<h3 id=\"测试驱动开发\"><a href=\"#测试驱动开发\" class=\"headerlink\" title=\"测试驱动开发\"></a>测试驱动开发</h3><p>简单的3条测试规则：</p>\n<ol>\n<li>除非已经编写了一个不能通过的单元测试，否则不编写任何产品代码；</li>\n<li>只要编写能够正好导致测试不通过或者编译失败的单元测试就够了，无需更多；</li>\n<li>只要编写能够正好使失败的单元测试通过的产品代码就够了，无需更多。</li>\n</ol>\n<h4 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h4><p><strong>单元测试</strong>是用来验证系统中单个机制的白盒测试（white-box test）。</p>\n<p>单元测试可以作为一种非常有价值的文档。如果想知道如何调用一个函数或者创建一个对象，会有一个测试展示给你看。测试就像一套范例，它帮助其他程序员了解如何使用代码。这份文档是可编译的、可运行的、它保持最新。它不会撒谎。</p>\n<p><strong>验收测试</strong>是用来验证系统满足客户需求的黑盒测试（black-box test）。</p>\n<p>验收测试是关于一项特性的最终文档。一旦客户编写完成了验证一项特性的验收测试，程序员可以阅读那些验收测试来真正地理解这项特性。所以，正如单元测试作为可编译、可执行的有关系统内部结构的文档那样，验收测试是有关系统特性的可以编译、可执行的文档。简而言之，验收测试是真正的需求文档。</p>\n<h3 id=\"SRP：单一职责原则\"><a href=\"#SRP：单一职责原则\" class=\"headerlink\" title=\"SRP：单一职责原则\"></a>SRP：单一职责原则</h3><p>假设有两个不同的应用程序使用Rectangle类。</p>\n<p>一个应用程序是有关计算几何学方面的，利用Rectangle类计算几何形状，但不会再屏幕上绘制矩形。</p>\n<p>另外一个应用程序实质上是有关图形绘制方面的，它可能也会进行一些计算几何方面的工作，但是它肯定会在屏幕上绘制矩形。</p>\n<p><img src=\"498627-20160828231647539-1014399922.png\" alt=\"\"></p>\n<p>此时，Rectangle类具有两个职责。第一个职责提供了一个矩形几何形状的数学模型；第二个职责是把矩形在一个图形用户界面上绘制出来。</p>\n<p>对于SRP的违反导致了一些严重的问题。首先，我们必须在计算几何应用程序中包含进GUI代码。在.Net中，就必须要把GUI组建和计算几何应用一起构建、部署。</p>\n<p>其次，如果GraphicalApplication的改变由于一些原因导致了Rectangle的改变，那么这个改变会迫使我们重新构建、测试以及部署ComputationalGeometryApplication。如果忘记这样做，ComputationalGeometryApplication可能会以不可预测的方式失败。</p>\n<p><img src=\"498627-20160828231739089-846443922.png\" alt=\"\"></p>\n<p>一个较好的设计是把这两个职责分离到两个完全不同的类中。这个设计把Rectangle类中进行计算的部分移动到了GeometricRectangle类中。现在矩形绘制方式的改变不会对ComputationalGeometryApplication类造成影响。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"测试驱动开发\"><a href=\"#测试驱动开发\" class=\"headerlink\" title=\"测试驱动开发\"></a>测试驱动开发</h3><p>简单的3条测试规则：</p>\n<ol>\n<li>除非已经编写了一个不能通过的单元测试，否则不编写任何产品代码；</li>\n<li>只要编写能够正好导致测试不通过或者编译失败的单元测试就够了，无需更多；</li>\n<li>只要编写能够正好使失败的单元测试通过的产品代码就够了，无需更多。</li>\n</ol>\n<h4 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h4><p><strong>单元测试</strong>是用来验证系统中单个机制的白盒测试（white-box test）。</p>\n<p>单元测试可以作为一种非常有价值的文档。如果想知道如何调用一个函数或者创建一个对象，会有一个测试展示给你看。测试就像一套范例，它帮助其他程序员了解如何使用代码。这份文档是可编译的、可运行的、它保持最新。它不会撒谎。</p>\n<p><strong>验收测试</strong>是用来验证系统满足客户需求的黑盒测试（black-box test）。</p>\n<p>验收测试是关于一项特性的最终文档。一旦客户编写完成了验证一项特性的验收测试，程序员可以阅读那些验收测试来真正地理解这项特性。所以，正如单元测试作为可编译、可执行的有关系统内部结构的文档那样，验收测试是有关系统特性的可以编译、可执行的文档。简而言之，验收测试是真正的需求文档。</p>\n<h3 id=\"SRP：单一职责原则\"><a href=\"#SRP：单一职责原则\" class=\"headerlink\" title=\"SRP：单一职责原则\"></a>SRP：单一职责原则</h3><p>假设有两个不同的应用程序使用Rectangle类。</p>\n<p>一个应用程序是有关计算几何学方面的，利用Rectangle类计算几何形状，但不会再屏幕上绘制矩形。</p>\n<p>另外一个应用程序实质上是有关图形绘制方面的，它可能也会进行一些计算几何方面的工作，但是它肯定会在屏幕上绘制矩形。</p>\n<p><img src=\"498627-20160828231647539-1014399922.png\" alt=\"\"></p>\n<p>此时，Rectangle类具有两个职责。第一个职责提供了一个矩形几何形状的数学模型；第二个职责是把矩形在一个图形用户界面上绘制出来。</p>\n<p>对于SRP的违反导致了一些严重的问题。首先，我们必须在计算几何应用程序中包含进GUI代码。在.Net中，就必须要把GUI组建和计算几何应用一起构建、部署。</p>\n<p>其次，如果GraphicalApplication的改变由于一些原因导致了Rectangle的改变，那么这个改变会迫使我们重新构建、测试以及部署ComputationalGeometryApplication。如果忘记这样做，ComputationalGeometryApplication可能会以不可预测的方式失败。</p>\n<p><img src=\"498627-20160828231739089-846443922.png\" alt=\"\"></p>\n<p>一个较好的设计是把这两个职责分离到两个完全不同的类中。这个设计把Rectangle类中进行计算的部分移动到了GeometricRectangle类中。现在矩形绘制方式的改变不会对ComputationalGeometryApplication类造成影响。</p>\n"},{"title":"Python 金融大数据分析","date":"2018-06-29T01:12:26.000Z","updated":"2018-07-31T16:00:00.000Z","出版社":"人民邮电出版社","ISBN":9787115404459,"出版时间":"2015-11-30T16:00:00.000Z","typora-root-url":"python_for_finance","description":"<!—more—->","_content":"\n## 第一章 为什么将Python用于金融\n\n## 第二章 基础架构和工具\n\n### 2.1 Python部署\n\n#### 2.1.1 [Anaconda](https://anaconda.org/)\n\n[初学python者自学anaconda的正确姿势是什么？？](https://www.zhihu.com/question/58033789)\n\n#### 2.1.2 Python Quant Platform\n\n## 第三章 入门示例\n\n* 隐含波动率 [隐含波动率- MBA智库百科](http://wiki.mbalib.com/wiki/%E9%9A%90%E5%90%AB%E6%B3%A2%E5%8A%A8%E7%8E%87)\n\n  以某些到期H 的期权1&价倒惟出这些期权的隐含波动率，并绘出阁表一一这是期权交易者和风险管理者每天都要面对的任务。\n\n* 蒙特卡洛模拟 [蒙特卡罗方法- MBA智库百科](http://wiki.mbalib.com/wiki/%E8%92%99%E7%89%B9%E5%8D%A1%E7%BD%97%E6%96%B9%E6%B3%95)\n\n  通过蒙特卡洛技术，模拟股票指数在一段时间中的变化，对选中的结果进行可视化.并计算欧式期权价值。蒙特卡洛模拟是期权数字化定价的基石，也是涉及风险价值计算或者信用值调整的风险管理℃作的基础。\n\n* 技术分析 [技术分析-维基百科](https://zh.wikipedia.org/wiki/%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90)\n\n  实施历史时间序列数据的分析，对根据趋势信号的投资策略进行事后验证;专业投资者和有抱负的业余投资者常常进行这类投资分析。\n\n### 第四章 数据类型和结构\n\n* [https://www.python.org/doc/](https://www.python.org/doc/)\n* [https://www.scipy.org/docs.html](https://www.scipy.org/docs.html)\n\n###第五章 数据可视化\n\n* [https://matplotlib.org/contents.html](https://matplotlib.org/contents.html)\n\n### 第六章 金融时间序列\n\n#### 6.2 金融数据\n\nhttps://github.com/GuQiangJS/finance-datareader-py\n\n```python\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom finance_datareader_py.netease.daily import NetEaseDailyReader\n\ndf = NetEaseDailyReader('000002').read()\ndf = df.tail(n=100)\ndf = df.replace(0, np.nan)\ndf = df.fillna(method='ffill')\ndf.plot(y='Close')\nplt.show()\n```\n\n![1533087934260](1533087934260.png)\n\n根据每日收盘价返回对数收益率。\n\n```python\nfrom finance_datareader_py.netease.daily import NetEaseDailyReader\n\ndf = NetEaseDailyReader('000002').read()\ndf = df.replace(0, np.NaN)\ndf['Return'] = df['Close'] / df['Close'].shift(1)\nprint(df[['Close', 'Return']].tail())\n```\n\n```\n            Close    Return\n                           \n2018-07-04  23.00  0.982067\n2018-07-05  23.05  1.002174\n2018-07-06  23.21  1.006941\n2018-07-09  24.01  1.034468\n2018-07-10  24.15  1.005831\n```\n\n> **波动率聚集**：波动率不是长期恒定的；既有高波动率时期（正负收益都很高），也有低波动率时期\n>\n> **杠杆效应**：一般来说，波动性的股票市场收益是负相关的；当市场下跌的时候波动性升高，反之亦然。\n\n```python\n# 收盘价与回报率的对应图表\ndf[['Close', 'Return']].plot(subplots=True, figsize=(8, 5))\nplt.show()\n```\n\n![1533088423103](1533088423103.png)\n\n[移动平均](https://zh.wikipedia.org/wiki/%E7%A7%BB%E5%8B%95%E5%B9%B3%E5%9D%87)\n\n```python\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nfrom finance_datareader_py.netease.daily import NetEaseDailyReader\n\ndf = NetEaseDailyReader('601398').read()\ndf['Return'] = np.log(df['Close'] / df['Close'].shift(1))\nprint(df[['Close', 'Return']].tail())\ndf['42d'] = pd.rolling_mean(df['Close'], window=42)\ndf['252d'] = pd.rolling_mean(df['Close'], window=252)\nprint(df[['Close', '42d', '252d']].tail())\ndf[['Close', '42d', '252d']].tail(n=1000).plot(figsize=(8, 5))\nplt.show()\n```\n\n![1533088473653](1533088473653.png)\n\n#### 6.3 回归分析\n\n[最小二乘法](https://zh.wikipedia.org/wiki/%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95)\n\n### 第七章 输入输出操作\n\n#### 7.3 PyTables的快速I/O\n\n[PyTables ](https://www.pytables.org/index.html)是 Python 与 HDF5 数据库/文件标准的结合(https://www.hdfgroup.org/)\n\n> PyTables可以把大数据直接写入本地硬盘而并不使用任何数据库管理软件和SQL \n\n##### 7.3.4 内存外计算\n\n[numexpr](https://github.com/pydata/numexpr)\n\n#### 延伸阅读\n\n* 用 pickle 进行的 Pytbon 对象序列化参见如下文梢: http://docs.python.orgl2/library/pickle.html 。\n\n* SciPy 网站上提供 NumPy 1/0 能力的概述: http://docs.scipy.orgldoc/numpy/referencc/rolltines.io.htm1 。\n* pandas 的I/0 参见在线文档的相应章节: http://pandas.pydata.orglpandas-docs/stab1e/io.html 。\n* PyTables 首页提供教程和详细文梢: http://www.pytables.org\n\n### 第八章 高性能Python\n\n#### 延伸阅读\n\n* numexpr 的细节参见http://github.com/pydata/nwnexpr\n* IPytbon.parallel 在这里介绍: http://ipython.org!ipython-doc/stable/parallel\n* multiprocessing 模块的文稍: https://docs.python.org/2/library/multiprocessing.html\n\n* Numba 的信息、可以在http://github.com/numbalnumba 找到\n* http://cython.org是Cython 编译器项目的首页\n* NumbaPro 的文树可以参见http://docs.continuum.io/nwnbapro\n\n### 第九章 数学工具\n\n#### 9.1 逼近法\n\n[逼近理论](https://zh.wikipedia.org/wiki/%E9%80%BC%E8%BF%91%E7%90%86%E8%AE%BA) \n\n```python\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ndef f(x):\n    return np.sin(x) + 0.5 * x\n\nx = np.linspace(-2 * np.pi, 2 * np.pi, 50)\nplt.plot(x, f(x), 'b')\nplt.grid(True)\nplt.xlabel('x')\nplt.ylabel('f(x)')\nplt.show()\n```\n\n![1531297702083](1533088496598.png)\n\n","source":"_posts/python_for_finance.md","raw":"---\ntitle: Python 金融大数据分析\ndate: 2018-06-29 09:12:26\nupdated: 2018-08-01\ntags:\n - 编程\n - Python\n - 金融\n - 股票\ncategories:\n - 编程\n - Python\n - 金融\n - 股票\n出版社: 人民邮电出版社\nISBN: 9787115404459\n出版时间: 2015-12-01\ntypora-root-url: python_for_finance\ndescription: <!—more—->\n---\n\n## 第一章 为什么将Python用于金融\n\n## 第二章 基础架构和工具\n\n### 2.1 Python部署\n\n#### 2.1.1 [Anaconda](https://anaconda.org/)\n\n[初学python者自学anaconda的正确姿势是什么？？](https://www.zhihu.com/question/58033789)\n\n#### 2.1.2 Python Quant Platform\n\n## 第三章 入门示例\n\n* 隐含波动率 [隐含波动率- MBA智库百科](http://wiki.mbalib.com/wiki/%E9%9A%90%E5%90%AB%E6%B3%A2%E5%8A%A8%E7%8E%87)\n\n  以某些到期H 的期权1&价倒惟出这些期权的隐含波动率，并绘出阁表一一这是期权交易者和风险管理者每天都要面对的任务。\n\n* 蒙特卡洛模拟 [蒙特卡罗方法- MBA智库百科](http://wiki.mbalib.com/wiki/%E8%92%99%E7%89%B9%E5%8D%A1%E7%BD%97%E6%96%B9%E6%B3%95)\n\n  通过蒙特卡洛技术，模拟股票指数在一段时间中的变化，对选中的结果进行可视化.并计算欧式期权价值。蒙特卡洛模拟是期权数字化定价的基石，也是涉及风险价值计算或者信用值调整的风险管理℃作的基础。\n\n* 技术分析 [技术分析-维基百科](https://zh.wikipedia.org/wiki/%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90)\n\n  实施历史时间序列数据的分析，对根据趋势信号的投资策略进行事后验证;专业投资者和有抱负的业余投资者常常进行这类投资分析。\n\n### 第四章 数据类型和结构\n\n* [https://www.python.org/doc/](https://www.python.org/doc/)\n* [https://www.scipy.org/docs.html](https://www.scipy.org/docs.html)\n\n###第五章 数据可视化\n\n* [https://matplotlib.org/contents.html](https://matplotlib.org/contents.html)\n\n### 第六章 金融时间序列\n\n#### 6.2 金融数据\n\nhttps://github.com/GuQiangJS/finance-datareader-py\n\n```python\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom finance_datareader_py.netease.daily import NetEaseDailyReader\n\ndf = NetEaseDailyReader('000002').read()\ndf = df.tail(n=100)\ndf = df.replace(0, np.nan)\ndf = df.fillna(method='ffill')\ndf.plot(y='Close')\nplt.show()\n```\n\n![1533087934260](1533087934260.png)\n\n根据每日收盘价返回对数收益率。\n\n```python\nfrom finance_datareader_py.netease.daily import NetEaseDailyReader\n\ndf = NetEaseDailyReader('000002').read()\ndf = df.replace(0, np.NaN)\ndf['Return'] = df['Close'] / df['Close'].shift(1)\nprint(df[['Close', 'Return']].tail())\n```\n\n```\n            Close    Return\n                           \n2018-07-04  23.00  0.982067\n2018-07-05  23.05  1.002174\n2018-07-06  23.21  1.006941\n2018-07-09  24.01  1.034468\n2018-07-10  24.15  1.005831\n```\n\n> **波动率聚集**：波动率不是长期恒定的；既有高波动率时期（正负收益都很高），也有低波动率时期\n>\n> **杠杆效应**：一般来说，波动性的股票市场收益是负相关的；当市场下跌的时候波动性升高，反之亦然。\n\n```python\n# 收盘价与回报率的对应图表\ndf[['Close', 'Return']].plot(subplots=True, figsize=(8, 5))\nplt.show()\n```\n\n![1533088423103](1533088423103.png)\n\n[移动平均](https://zh.wikipedia.org/wiki/%E7%A7%BB%E5%8B%95%E5%B9%B3%E5%9D%87)\n\n```python\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nfrom finance_datareader_py.netease.daily import NetEaseDailyReader\n\ndf = NetEaseDailyReader('601398').read()\ndf['Return'] = np.log(df['Close'] / df['Close'].shift(1))\nprint(df[['Close', 'Return']].tail())\ndf['42d'] = pd.rolling_mean(df['Close'], window=42)\ndf['252d'] = pd.rolling_mean(df['Close'], window=252)\nprint(df[['Close', '42d', '252d']].tail())\ndf[['Close', '42d', '252d']].tail(n=1000).plot(figsize=(8, 5))\nplt.show()\n```\n\n![1533088473653](1533088473653.png)\n\n#### 6.3 回归分析\n\n[最小二乘法](https://zh.wikipedia.org/wiki/%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95)\n\n### 第七章 输入输出操作\n\n#### 7.3 PyTables的快速I/O\n\n[PyTables ](https://www.pytables.org/index.html)是 Python 与 HDF5 数据库/文件标准的结合(https://www.hdfgroup.org/)\n\n> PyTables可以把大数据直接写入本地硬盘而并不使用任何数据库管理软件和SQL \n\n##### 7.3.4 内存外计算\n\n[numexpr](https://github.com/pydata/numexpr)\n\n#### 延伸阅读\n\n* 用 pickle 进行的 Pytbon 对象序列化参见如下文梢: http://docs.python.orgl2/library/pickle.html 。\n\n* SciPy 网站上提供 NumPy 1/0 能力的概述: http://docs.scipy.orgldoc/numpy/referencc/rolltines.io.htm1 。\n* pandas 的I/0 参见在线文档的相应章节: http://pandas.pydata.orglpandas-docs/stab1e/io.html 。\n* PyTables 首页提供教程和详细文梢: http://www.pytables.org\n\n### 第八章 高性能Python\n\n#### 延伸阅读\n\n* numexpr 的细节参见http://github.com/pydata/nwnexpr\n* IPytbon.parallel 在这里介绍: http://ipython.org!ipython-doc/stable/parallel\n* multiprocessing 模块的文稍: https://docs.python.org/2/library/multiprocessing.html\n\n* Numba 的信息、可以在http://github.com/numbalnumba 找到\n* http://cython.org是Cython 编译器项目的首页\n* NumbaPro 的文树可以参见http://docs.continuum.io/nwnbapro\n\n### 第九章 数学工具\n\n#### 9.1 逼近法\n\n[逼近理论](https://zh.wikipedia.org/wiki/%E9%80%BC%E8%BF%91%E7%90%86%E8%AE%BA) \n\n```python\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ndef f(x):\n    return np.sin(x) + 0.5 * x\n\nx = np.linspace(-2 * np.pi, 2 * np.pi, 50)\nplt.plot(x, f(x), 'b')\nplt.grid(True)\nplt.xlabel('x')\nplt.ylabel('f(x)')\nplt.show()\n```\n\n![1531297702083](1533088496598.png)\n\n","slug":"python_for_finance","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cjof51pjr0006rguerpqip4yn","content":"<h2 id=\"第一章-为什么将Python用于金融\"><a href=\"#第一章-为什么将Python用于金融\" class=\"headerlink\" title=\"第一章 为什么将Python用于金融\"></a>第一章 为什么将Python用于金融</h2><h2 id=\"第二章-基础架构和工具\"><a href=\"#第二章-基础架构和工具\" class=\"headerlink\" title=\"第二章 基础架构和工具\"></a>第二章 基础架构和工具</h2><h3 id=\"2-1-Python部署\"><a href=\"#2-1-Python部署\" class=\"headerlink\" title=\"2.1 Python部署\"></a>2.1 Python部署</h3><h4 id=\"2-1-1-Anaconda\"><a href=\"#2-1-1-Anaconda\" class=\"headerlink\" title=\"2.1.1 Anaconda\"></a>2.1.1 <a href=\"https://anaconda.org/\" target=\"_blank\" rel=\"noopener\">Anaconda</a></h4><p><a href=\"https://www.zhihu.com/question/58033789\" target=\"_blank\" rel=\"noopener\">初学python者自学anaconda的正确姿势是什么？？</a></p>\n<h4 id=\"2-1-2-Python-Quant-Platform\"><a href=\"#2-1-2-Python-Quant-Platform\" class=\"headerlink\" title=\"2.1.2 Python Quant Platform\"></a>2.1.2 Python Quant Platform</h4><h2 id=\"第三章-入门示例\"><a href=\"#第三章-入门示例\" class=\"headerlink\" title=\"第三章 入门示例\"></a>第三章 入门示例</h2><ul>\n<li><p>隐含波动率 <a href=\"http://wiki.mbalib.com/wiki/%E9%9A%90%E5%90%AB%E6%B3%A2%E5%8A%A8%E7%8E%87\" target=\"_blank\" rel=\"noopener\">隐含波动率- MBA智库百科</a></p>\n<p>以某些到期H 的期权1&amp;价倒惟出这些期权的隐含波动率，并绘出阁表一一这是期权交易者和风险管理者每天都要面对的任务。</p>\n</li>\n<li><p>蒙特卡洛模拟 <a href=\"http://wiki.mbalib.com/wiki/%E8%92%99%E7%89%B9%E5%8D%A1%E7%BD%97%E6%96%B9%E6%B3%95\" target=\"_blank\" rel=\"noopener\">蒙特卡罗方法- MBA智库百科</a></p>\n<p>通过蒙特卡洛技术，模拟股票指数在一段时间中的变化，对选中的结果进行可视化.并计算欧式期权价值。蒙特卡洛模拟是期权数字化定价的基石，也是涉及风险价值计算或者信用值调整的风险管理℃作的基础。</p>\n</li>\n<li><p>技术分析 <a href=\"https://zh.wikipedia.org/wiki/%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90\" target=\"_blank\" rel=\"noopener\">技术分析-维基百科</a></p>\n<p>实施历史时间序列数据的分析，对根据趋势信号的投资策略进行事后验证;专业投资者和有抱负的业余投资者常常进行这类投资分析。</p>\n</li>\n</ul>\n<h3 id=\"第四章-数据类型和结构\"><a href=\"#第四章-数据类型和结构\" class=\"headerlink\" title=\"第四章 数据类型和结构\"></a>第四章 数据类型和结构</h3><ul>\n<li><a href=\"https://www.python.org/doc/\" target=\"_blank\" rel=\"noopener\">https://www.python.org/doc/</a></li>\n<li><a href=\"https://www.scipy.org/docs.html\" target=\"_blank\" rel=\"noopener\">https://www.scipy.org/docs.html</a></li>\n</ul>\n<p>###第五章 数据可视化</p>\n<ul>\n<li><a href=\"https://matplotlib.org/contents.html\" target=\"_blank\" rel=\"noopener\">https://matplotlib.org/contents.html</a></li>\n</ul>\n<h3 id=\"第六章-金融时间序列\"><a href=\"#第六章-金融时间序列\" class=\"headerlink\" title=\"第六章 金融时间序列\"></a>第六章 金融时间序列</h3><h4 id=\"6-2-金融数据\"><a href=\"#6-2-金融数据\" class=\"headerlink\" title=\"6.2 金融数据\"></a>6.2 金融数据</h4><p><a href=\"https://github.com/GuQiangJS/finance-datareader-py\" target=\"_blank\" rel=\"noopener\">https://github.com/GuQiangJS/finance-datareader-py</a></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">from</span> finance_datareader_py.netease.daily <span class=\"keyword\">import</span> NetEaseDailyReader</span><br><span class=\"line\"></span><br><span class=\"line\">df = NetEaseDailyReader(<span class=\"string\">'000002'</span>).read()</span><br><span class=\"line\">df = df.tail(n=<span class=\"number\">100</span>)</span><br><span class=\"line\">df = df.replace(<span class=\"number\">0</span>, np.nan)</span><br><span class=\"line\">df = df.fillna(method=<span class=\"string\">'ffill'</span>)</span><br><span class=\"line\">df.plot(y=<span class=\"string\">'Close'</span>)</span><br><span class=\"line\">plt.show()</span><br></pre></td></tr></table></figure>\n<p><img src=\"1533087934260.png\" alt=\"1533087934260\"></p>\n<p>根据每日收盘价返回对数收益率。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> finance_datareader_py.netease.daily <span class=\"keyword\">import</span> NetEaseDailyReader</span><br><span class=\"line\"></span><br><span class=\"line\">df = NetEaseDailyReader(<span class=\"string\">'000002'</span>).read()</span><br><span class=\"line\">df = df.replace(<span class=\"number\">0</span>, np.NaN)</span><br><span class=\"line\">df[<span class=\"string\">'Return'</span>] = df[<span class=\"string\">'Close'</span>] / df[<span class=\"string\">'Close'</span>].shift(<span class=\"number\">1</span>)</span><br><span class=\"line\">print(df[[<span class=\"string\">'Close'</span>, <span class=\"string\">'Return'</span>]].tail())</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">            Close    Return</span><br><span class=\"line\">                           </span><br><span class=\"line\">2018-07-04  23.00  0.982067</span><br><span class=\"line\">2018-07-05  23.05  1.002174</span><br><span class=\"line\">2018-07-06  23.21  1.006941</span><br><span class=\"line\">2018-07-09  24.01  1.034468</span><br><span class=\"line\">2018-07-10  24.15  1.005831</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>波动率聚集</strong>：波动率不是长期恒定的；既有高波动率时期（正负收益都很高），也有低波动率时期</p>\n<p><strong>杠杆效应</strong>：一般来说，波动性的股票市场收益是负相关的；当市场下跌的时候波动性升高，反之亦然。</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 收盘价与回报率的对应图表</span></span><br><span class=\"line\">df[[<span class=\"string\">'Close'</span>, <span class=\"string\">'Return'</span>]].plot(subplots=<span class=\"keyword\">True</span>, figsize=(<span class=\"number\">8</span>, <span class=\"number\">5</span>))</span><br><span class=\"line\">plt.show()</span><br></pre></td></tr></table></figure>\n<p><img src=\"1533088423103.png\" alt=\"1533088423103\"></p>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E7%A7%BB%E5%8B%95%E5%B9%B3%E5%9D%87\" target=\"_blank\" rel=\"noopener\">移动平均</a></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd</span><br><span class=\"line\"><span class=\"keyword\">from</span> finance_datareader_py.netease.daily <span class=\"keyword\">import</span> NetEaseDailyReader</span><br><span class=\"line\"></span><br><span class=\"line\">df = NetEaseDailyReader(<span class=\"string\">'601398'</span>).read()</span><br><span class=\"line\">df[<span class=\"string\">'Return'</span>] = np.log(df[<span class=\"string\">'Close'</span>] / df[<span class=\"string\">'Close'</span>].shift(<span class=\"number\">1</span>))</span><br><span class=\"line\">print(df[[<span class=\"string\">'Close'</span>, <span class=\"string\">'Return'</span>]].tail())</span><br><span class=\"line\">df[<span class=\"string\">'42d'</span>] = pd.rolling_mean(df[<span class=\"string\">'Close'</span>], window=<span class=\"number\">42</span>)</span><br><span class=\"line\">df[<span class=\"string\">'252d'</span>] = pd.rolling_mean(df[<span class=\"string\">'Close'</span>], window=<span class=\"number\">252</span>)</span><br><span class=\"line\">print(df[[<span class=\"string\">'Close'</span>, <span class=\"string\">'42d'</span>, <span class=\"string\">'252d'</span>]].tail())</span><br><span class=\"line\">df[[<span class=\"string\">'Close'</span>, <span class=\"string\">'42d'</span>, <span class=\"string\">'252d'</span>]].tail(n=<span class=\"number\">1000</span>).plot(figsize=(<span class=\"number\">8</span>, <span class=\"number\">5</span>))</span><br><span class=\"line\">plt.show()</span><br></pre></td></tr></table></figure>\n<p><img src=\"1533088473653.png\" alt=\"1533088473653\"></p>\n<h4 id=\"6-3-回归分析\"><a href=\"#6-3-回归分析\" class=\"headerlink\" title=\"6.3 回归分析\"></a>6.3 回归分析</h4><p><a href=\"https://zh.wikipedia.org/wiki/%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95\" target=\"_blank\" rel=\"noopener\">最小二乘法</a></p>\n<h3 id=\"第七章-输入输出操作\"><a href=\"#第七章-输入输出操作\" class=\"headerlink\" title=\"第七章 输入输出操作\"></a>第七章 输入输出操作</h3><h4 id=\"7-3-PyTables的快速I-O\"><a href=\"#7-3-PyTables的快速I-O\" class=\"headerlink\" title=\"7.3 PyTables的快速I/O\"></a>7.3 PyTables的快速I/O</h4><p><a href=\"https://www.pytables.org/index.html\" target=\"_blank\" rel=\"noopener\">PyTables </a>是 Python 与 HDF5 数据库/文件标准的结合(<a href=\"https://www.hdfgroup.org/\" target=\"_blank\" rel=\"noopener\">https://www.hdfgroup.org/</a>)</p>\n<blockquote>\n<p>PyTables可以把大数据直接写入本地硬盘而并不使用任何数据库管理软件和SQL </p>\n</blockquote>\n<h5 id=\"7-3-4-内存外计算\"><a href=\"#7-3-4-内存外计算\" class=\"headerlink\" title=\"7.3.4 内存外计算\"></a>7.3.4 内存外计算</h5><p><a href=\"https://github.com/pydata/numexpr\" target=\"_blank\" rel=\"noopener\">numexpr</a></p>\n<h4 id=\"延伸阅读\"><a href=\"#延伸阅读\" class=\"headerlink\" title=\"延伸阅读\"></a>延伸阅读</h4><ul>\n<li><p>用 pickle 进行的 Pytbon 对象序列化参见如下文梢: <a href=\"http://docs.python.orgl2/library/pickle.html\" target=\"_blank\" rel=\"noopener\">http://docs.python.orgl2/library/pickle.html</a> 。</p>\n</li>\n<li><p>SciPy 网站上提供 NumPy 1/0 能力的概述: <a href=\"http://docs.scipy.orgldoc/numpy/referencc/rolltines.io.htm1\" target=\"_blank\" rel=\"noopener\">http://docs.scipy.orgldoc/numpy/referencc/rolltines.io.htm1</a> 。</p>\n</li>\n<li>pandas 的I/0 参见在线文档的相应章节: <a href=\"http://pandas.pydata.orglpandas-docs/stab1e/io.html\" target=\"_blank\" rel=\"noopener\">http://pandas.pydata.orglpandas-docs/stab1e/io.html</a> 。</li>\n<li>PyTables 首页提供教程和详细文梢: <a href=\"http://www.pytables.org\" target=\"_blank\" rel=\"noopener\">http://www.pytables.org</a></li>\n</ul>\n<h3 id=\"第八章-高性能Python\"><a href=\"#第八章-高性能Python\" class=\"headerlink\" title=\"第八章 高性能Python\"></a>第八章 高性能Python</h3><h4 id=\"延伸阅读-1\"><a href=\"#延伸阅读-1\" class=\"headerlink\" title=\"延伸阅读\"></a>延伸阅读</h4><ul>\n<li>numexpr 的细节参见<a href=\"http://github.com/pydata/nwnexpr\" target=\"_blank\" rel=\"noopener\">http://github.com/pydata/nwnexpr</a></li>\n<li>IPytbon.parallel 在这里介绍: <a href=\"http://ipython.org!ipython-doc/stable/parallel\" target=\"_blank\" rel=\"noopener\">http://ipython.org!ipython-doc/stable/parallel</a></li>\n<li><p>multiprocessing 模块的文稍: <a href=\"https://docs.python.org/2/library/multiprocessing.html\" target=\"_blank\" rel=\"noopener\">https://docs.python.org/2/library/multiprocessing.html</a></p>\n</li>\n<li><p>Numba 的信息、可以在<a href=\"http://github.com/numbalnumba\" target=\"_blank\" rel=\"noopener\">http://github.com/numbalnumba</a> 找到</p>\n</li>\n<li><a href=\"http://cython.org是Cython\" target=\"_blank\" rel=\"noopener\">http://cython.org是Cython</a> 编译器项目的首页</li>\n<li>NumbaPro 的文树可以参见<a href=\"http://docs.continuum.io/nwnbapro\" target=\"_blank\" rel=\"noopener\">http://docs.continuum.io/nwnbapro</a></li>\n</ul>\n<h3 id=\"第九章-数学工具\"><a href=\"#第九章-数学工具\" class=\"headerlink\" title=\"第九章 数学工具\"></a>第九章 数学工具</h3><h4 id=\"9-1-逼近法\"><a href=\"#9-1-逼近法\" class=\"headerlink\" title=\"9.1 逼近法\"></a>9.1 逼近法</h4><p><a href=\"https://zh.wikipedia.org/wiki/%E9%80%BC%E8%BF%91%E7%90%86%E8%AE%BA\" target=\"_blank\" rel=\"noopener\">逼近理论</a> </p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span><span class=\"params\">(x)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> np.sin(x) + <span class=\"number\">0.5</span> * x</span><br><span class=\"line\"></span><br><span class=\"line\">x = np.linspace(<span class=\"number\">-2</span> * np.pi, <span class=\"number\">2</span> * np.pi, <span class=\"number\">50</span>)</span><br><span class=\"line\">plt.plot(x, f(x), <span class=\"string\">'b'</span>)</span><br><span class=\"line\">plt.grid(<span class=\"keyword\">True</span>)</span><br><span class=\"line\">plt.xlabel(<span class=\"string\">'x'</span>)</span><br><span class=\"line\">plt.ylabel(<span class=\"string\">'f(x)'</span>)</span><br><span class=\"line\">plt.show()</span><br></pre></td></tr></table></figure>\n<p><img src=\"1533088496598.png\" alt=\"1531297702083\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"第一章-为什么将Python用于金融\"><a href=\"#第一章-为什么将Python用于金融\" class=\"headerlink\" title=\"第一章 为什么将Python用于金融\"></a>第一章 为什么将Python用于金融</h2><h2 id=\"第二章-基础架构和工具\"><a href=\"#第二章-基础架构和工具\" class=\"headerlink\" title=\"第二章 基础架构和工具\"></a>第二章 基础架构和工具</h2><h3 id=\"2-1-Python部署\"><a href=\"#2-1-Python部署\" class=\"headerlink\" title=\"2.1 Python部署\"></a>2.1 Python部署</h3><h4 id=\"2-1-1-Anaconda\"><a href=\"#2-1-1-Anaconda\" class=\"headerlink\" title=\"2.1.1 Anaconda\"></a>2.1.1 <a href=\"https://anaconda.org/\" target=\"_blank\" rel=\"noopener\">Anaconda</a></h4><p><a href=\"https://www.zhihu.com/question/58033789\" target=\"_blank\" rel=\"noopener\">初学python者自学anaconda的正确姿势是什么？？</a></p>\n<h4 id=\"2-1-2-Python-Quant-Platform\"><a href=\"#2-1-2-Python-Quant-Platform\" class=\"headerlink\" title=\"2.1.2 Python Quant Platform\"></a>2.1.2 Python Quant Platform</h4><h2 id=\"第三章-入门示例\"><a href=\"#第三章-入门示例\" class=\"headerlink\" title=\"第三章 入门示例\"></a>第三章 入门示例</h2><ul>\n<li><p>隐含波动率 <a href=\"http://wiki.mbalib.com/wiki/%E9%9A%90%E5%90%AB%E6%B3%A2%E5%8A%A8%E7%8E%87\" target=\"_blank\" rel=\"noopener\">隐含波动率- MBA智库百科</a></p>\n<p>以某些到期H 的期权1&amp;价倒惟出这些期权的隐含波动率，并绘出阁表一一这是期权交易者和风险管理者每天都要面对的任务。</p>\n</li>\n<li><p>蒙特卡洛模拟 <a href=\"http://wiki.mbalib.com/wiki/%E8%92%99%E7%89%B9%E5%8D%A1%E7%BD%97%E6%96%B9%E6%B3%95\" target=\"_blank\" rel=\"noopener\">蒙特卡罗方法- MBA智库百科</a></p>\n<p>通过蒙特卡洛技术，模拟股票指数在一段时间中的变化，对选中的结果进行可视化.并计算欧式期权价值。蒙特卡洛模拟是期权数字化定价的基石，也是涉及风险价值计算或者信用值调整的风险管理℃作的基础。</p>\n</li>\n<li><p>技术分析 <a href=\"https://zh.wikipedia.org/wiki/%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90\" target=\"_blank\" rel=\"noopener\">技术分析-维基百科</a></p>\n<p>实施历史时间序列数据的分析，对根据趋势信号的投资策略进行事后验证;专业投资者和有抱负的业余投资者常常进行这类投资分析。</p>\n</li>\n</ul>\n<h3 id=\"第四章-数据类型和结构\"><a href=\"#第四章-数据类型和结构\" class=\"headerlink\" title=\"第四章 数据类型和结构\"></a>第四章 数据类型和结构</h3><ul>\n<li><a href=\"https://www.python.org/doc/\" target=\"_blank\" rel=\"noopener\">https://www.python.org/doc/</a></li>\n<li><a href=\"https://www.scipy.org/docs.html\" target=\"_blank\" rel=\"noopener\">https://www.scipy.org/docs.html</a></li>\n</ul>\n<p>###第五章 数据可视化</p>\n<ul>\n<li><a href=\"https://matplotlib.org/contents.html\" target=\"_blank\" rel=\"noopener\">https://matplotlib.org/contents.html</a></li>\n</ul>\n<h3 id=\"第六章-金融时间序列\"><a href=\"#第六章-金融时间序列\" class=\"headerlink\" title=\"第六章 金融时间序列\"></a>第六章 金融时间序列</h3><h4 id=\"6-2-金融数据\"><a href=\"#6-2-金融数据\" class=\"headerlink\" title=\"6.2 金融数据\"></a>6.2 金融数据</h4><p><a href=\"https://github.com/GuQiangJS/finance-datareader-py\" target=\"_blank\" rel=\"noopener\">https://github.com/GuQiangJS/finance-datareader-py</a></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">from</span> finance_datareader_py.netease.daily <span class=\"keyword\">import</span> NetEaseDailyReader</span><br><span class=\"line\"></span><br><span class=\"line\">df = NetEaseDailyReader(<span class=\"string\">'000002'</span>).read()</span><br><span class=\"line\">df = df.tail(n=<span class=\"number\">100</span>)</span><br><span class=\"line\">df = df.replace(<span class=\"number\">0</span>, np.nan)</span><br><span class=\"line\">df = df.fillna(method=<span class=\"string\">'ffill'</span>)</span><br><span class=\"line\">df.plot(y=<span class=\"string\">'Close'</span>)</span><br><span class=\"line\">plt.show()</span><br></pre></td></tr></table></figure>\n<p><img src=\"1533087934260.png\" alt=\"1533087934260\"></p>\n<p>根据每日收盘价返回对数收益率。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> finance_datareader_py.netease.daily <span class=\"keyword\">import</span> NetEaseDailyReader</span><br><span class=\"line\"></span><br><span class=\"line\">df = NetEaseDailyReader(<span class=\"string\">'000002'</span>).read()</span><br><span class=\"line\">df = df.replace(<span class=\"number\">0</span>, np.NaN)</span><br><span class=\"line\">df[<span class=\"string\">'Return'</span>] = df[<span class=\"string\">'Close'</span>] / df[<span class=\"string\">'Close'</span>].shift(<span class=\"number\">1</span>)</span><br><span class=\"line\">print(df[[<span class=\"string\">'Close'</span>, <span class=\"string\">'Return'</span>]].tail())</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">            Close    Return</span><br><span class=\"line\">                           </span><br><span class=\"line\">2018-07-04  23.00  0.982067</span><br><span class=\"line\">2018-07-05  23.05  1.002174</span><br><span class=\"line\">2018-07-06  23.21  1.006941</span><br><span class=\"line\">2018-07-09  24.01  1.034468</span><br><span class=\"line\">2018-07-10  24.15  1.005831</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>波动率聚集</strong>：波动率不是长期恒定的；既有高波动率时期（正负收益都很高），也有低波动率时期</p>\n<p><strong>杠杆效应</strong>：一般来说，波动性的股票市场收益是负相关的；当市场下跌的时候波动性升高，反之亦然。</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 收盘价与回报率的对应图表</span></span><br><span class=\"line\">df[[<span class=\"string\">'Close'</span>, <span class=\"string\">'Return'</span>]].plot(subplots=<span class=\"keyword\">True</span>, figsize=(<span class=\"number\">8</span>, <span class=\"number\">5</span>))</span><br><span class=\"line\">plt.show()</span><br></pre></td></tr></table></figure>\n<p><img src=\"1533088423103.png\" alt=\"1533088423103\"></p>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E7%A7%BB%E5%8B%95%E5%B9%B3%E5%9D%87\" target=\"_blank\" rel=\"noopener\">移动平均</a></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd</span><br><span class=\"line\"><span class=\"keyword\">from</span> finance_datareader_py.netease.daily <span class=\"keyword\">import</span> NetEaseDailyReader</span><br><span class=\"line\"></span><br><span class=\"line\">df = NetEaseDailyReader(<span class=\"string\">'601398'</span>).read()</span><br><span class=\"line\">df[<span class=\"string\">'Return'</span>] = np.log(df[<span class=\"string\">'Close'</span>] / df[<span class=\"string\">'Close'</span>].shift(<span class=\"number\">1</span>))</span><br><span class=\"line\">print(df[[<span class=\"string\">'Close'</span>, <span class=\"string\">'Return'</span>]].tail())</span><br><span class=\"line\">df[<span class=\"string\">'42d'</span>] = pd.rolling_mean(df[<span class=\"string\">'Close'</span>], window=<span class=\"number\">42</span>)</span><br><span class=\"line\">df[<span class=\"string\">'252d'</span>] = pd.rolling_mean(df[<span class=\"string\">'Close'</span>], window=<span class=\"number\">252</span>)</span><br><span class=\"line\">print(df[[<span class=\"string\">'Close'</span>, <span class=\"string\">'42d'</span>, <span class=\"string\">'252d'</span>]].tail())</span><br><span class=\"line\">df[[<span class=\"string\">'Close'</span>, <span class=\"string\">'42d'</span>, <span class=\"string\">'252d'</span>]].tail(n=<span class=\"number\">1000</span>).plot(figsize=(<span class=\"number\">8</span>, <span class=\"number\">5</span>))</span><br><span class=\"line\">plt.show()</span><br></pre></td></tr></table></figure>\n<p><img src=\"1533088473653.png\" alt=\"1533088473653\"></p>\n<h4 id=\"6-3-回归分析\"><a href=\"#6-3-回归分析\" class=\"headerlink\" title=\"6.3 回归分析\"></a>6.3 回归分析</h4><p><a href=\"https://zh.wikipedia.org/wiki/%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95\" target=\"_blank\" rel=\"noopener\">最小二乘法</a></p>\n<h3 id=\"第七章-输入输出操作\"><a href=\"#第七章-输入输出操作\" class=\"headerlink\" title=\"第七章 输入输出操作\"></a>第七章 输入输出操作</h3><h4 id=\"7-3-PyTables的快速I-O\"><a href=\"#7-3-PyTables的快速I-O\" class=\"headerlink\" title=\"7.3 PyTables的快速I/O\"></a>7.3 PyTables的快速I/O</h4><p><a href=\"https://www.pytables.org/index.html\" target=\"_blank\" rel=\"noopener\">PyTables </a>是 Python 与 HDF5 数据库/文件标准的结合(<a href=\"https://www.hdfgroup.org/\" target=\"_blank\" rel=\"noopener\">https://www.hdfgroup.org/</a>)</p>\n<blockquote>\n<p>PyTables可以把大数据直接写入本地硬盘而并不使用任何数据库管理软件和SQL </p>\n</blockquote>\n<h5 id=\"7-3-4-内存外计算\"><a href=\"#7-3-4-内存外计算\" class=\"headerlink\" title=\"7.3.4 内存外计算\"></a>7.3.4 内存外计算</h5><p><a href=\"https://github.com/pydata/numexpr\" target=\"_blank\" rel=\"noopener\">numexpr</a></p>\n<h4 id=\"延伸阅读\"><a href=\"#延伸阅读\" class=\"headerlink\" title=\"延伸阅读\"></a>延伸阅读</h4><ul>\n<li><p>用 pickle 进行的 Pytbon 对象序列化参见如下文梢: <a href=\"http://docs.python.orgl2/library/pickle.html\" target=\"_blank\" rel=\"noopener\">http://docs.python.orgl2/library/pickle.html</a> 。</p>\n</li>\n<li><p>SciPy 网站上提供 NumPy 1/0 能力的概述: <a href=\"http://docs.scipy.orgldoc/numpy/referencc/rolltines.io.htm1\" target=\"_blank\" rel=\"noopener\">http://docs.scipy.orgldoc/numpy/referencc/rolltines.io.htm1</a> 。</p>\n</li>\n<li>pandas 的I/0 参见在线文档的相应章节: <a href=\"http://pandas.pydata.orglpandas-docs/stab1e/io.html\" target=\"_blank\" rel=\"noopener\">http://pandas.pydata.orglpandas-docs/stab1e/io.html</a> 。</li>\n<li>PyTables 首页提供教程和详细文梢: <a href=\"http://www.pytables.org\" target=\"_blank\" rel=\"noopener\">http://www.pytables.org</a></li>\n</ul>\n<h3 id=\"第八章-高性能Python\"><a href=\"#第八章-高性能Python\" class=\"headerlink\" title=\"第八章 高性能Python\"></a>第八章 高性能Python</h3><h4 id=\"延伸阅读-1\"><a href=\"#延伸阅读-1\" class=\"headerlink\" title=\"延伸阅读\"></a>延伸阅读</h4><ul>\n<li>numexpr 的细节参见<a href=\"http://github.com/pydata/nwnexpr\" target=\"_blank\" rel=\"noopener\">http://github.com/pydata/nwnexpr</a></li>\n<li>IPytbon.parallel 在这里介绍: <a href=\"http://ipython.org!ipython-doc/stable/parallel\" target=\"_blank\" rel=\"noopener\">http://ipython.org!ipython-doc/stable/parallel</a></li>\n<li><p>multiprocessing 模块的文稍: <a href=\"https://docs.python.org/2/library/multiprocessing.html\" target=\"_blank\" rel=\"noopener\">https://docs.python.org/2/library/multiprocessing.html</a></p>\n</li>\n<li><p>Numba 的信息、可以在<a href=\"http://github.com/numbalnumba\" target=\"_blank\" rel=\"noopener\">http://github.com/numbalnumba</a> 找到</p>\n</li>\n<li><a href=\"http://cython.org是Cython\" target=\"_blank\" rel=\"noopener\">http://cython.org是Cython</a> 编译器项目的首页</li>\n<li>NumbaPro 的文树可以参见<a href=\"http://docs.continuum.io/nwnbapro\" target=\"_blank\" rel=\"noopener\">http://docs.continuum.io/nwnbapro</a></li>\n</ul>\n<h3 id=\"第九章-数学工具\"><a href=\"#第九章-数学工具\" class=\"headerlink\" title=\"第九章 数学工具\"></a>第九章 数学工具</h3><h4 id=\"9-1-逼近法\"><a href=\"#9-1-逼近法\" class=\"headerlink\" title=\"9.1 逼近法\"></a>9.1 逼近法</h4><p><a href=\"https://zh.wikipedia.org/wiki/%E9%80%BC%E8%BF%91%E7%90%86%E8%AE%BA\" target=\"_blank\" rel=\"noopener\">逼近理论</a> </p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span><span class=\"params\">(x)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> np.sin(x) + <span class=\"number\">0.5</span> * x</span><br><span class=\"line\"></span><br><span class=\"line\">x = np.linspace(<span class=\"number\">-2</span> * np.pi, <span class=\"number\">2</span> * np.pi, <span class=\"number\">50</span>)</span><br><span class=\"line\">plt.plot(x, f(x), <span class=\"string\">'b'</span>)</span><br><span class=\"line\">plt.grid(<span class=\"keyword\">True</span>)</span><br><span class=\"line\">plt.xlabel(<span class=\"string\">'x'</span>)</span><br><span class=\"line\">plt.ylabel(<span class=\"string\">'f(x)'</span>)</span><br><span class=\"line\">plt.show()</span><br></pre></td></tr></table></figure>\n<p><img src=\"1533088496598.png\" alt=\"1531297702083\"></p>\n"},{"title":"Python 核心编程","date":"2018-05-05T14:06:54.000Z","updated":"2018-05-10T16:00:00.000Z","photos":["/2018/05/05/pythoncore/pythoncore.png"],"出版社":"人民邮电出版社","ISBN":9787115414779,"出版时间":"2016-04-30T16:00:00.000Z","description":"<!—more—->","_content":"\n### 正则表达式\n\n#### [`re`](https://docs.python.org/3.5/library/re.html?highlight=re#module-re) — Regular expression operations\n\n>  [`re.compile`](https://docs.python.org/3.6/library/re.html?highlight=re#re.compile) 为正则表达式提供了预编译功能。如果程序在执行过程中需要多次调用到正则表达式对象，那么采用预编译可以提升执行性能。\n\nIf you want to locate a match anywhere in *string*, use [`search()`](https://docs.python.org/3.6/library/re.html?highlight=re#re.regex.search) instead (see also [search() vs. match()](https://docs.python.org/3.6/library/re.html?highlight=re#search-vs-match)).\n\n### 网络编程\n\n#### [socket](https://docs.python.org/3.6/library/socket.html?highlight=socket#module-socket) - 低级网络接口\n\n1. 基于文件的 Socket：[`socket.AF_UNIX`](https://docs.python.org/3.6/library/socket.html?highlight=socket#socket.AF_UNIX)\n2. 基于网络的 Socket：[`socket.AF_INET`](https://docs.python.org/3.6/library/socket.html?highlight=socket#socket.AF_INET)\n\n\n1. 有链接的Socket(**TCP**)：[`socket.SOCK_STREAM`](https://docs.python.org/3.6/library/socket.html?highlight=socket#socket.SOCK_STREAM)\n2. 无链接的Socket(**UDP**)：[`socket.SOCK_DGRAM`](https://docs.python.org/3.6/library/socket.html?highlight=socket#socket.SOCK_DGRAM)\n\n`tcpSock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)`\n\n[`socket.sendall(*bytes*[, *flags*])`](https://docs.python.org/3/library/socket.html?highlight=getservbyname#socket.socket.sendall) 与 [`socket.send(*bytes*[, *flags*])`](https://docs.python.org/3/library/socket.html?highlight=getservbyname#socket.socket.send) 不同，此方法继续从字节发送数据，直到发送所有数据或发生错误。\n\n[`socket.send(*bytes*[, *flags*])`](https://docs.python.org/3/library/socket.html?highlight=getservbyname#socket.socket.send) 返回发送的字节数。由应用程序负责检查所有数据是否已发送;\n\nTCP服务端和客户端示例**\n\n{% codeblock 服务端 tsTserv3.py lang:python %}\nfrom socket import *\nfrom time import ctime\n\nHOST = ''\nPORT = 21567\nBUFSIZ = 1024\nADDR = (HOST, PORT)\n\ntcpSerSock = socket(AF_INET, SOCK_STREAM)\ntcpSerSock.bind(ADDR)\ntcpSerSock.listen(5)\n\nwhile True:\n    print('waiting for connection...')\n    tcpCliSock, addr = tcpSerSock.accept()\n    print('...connected from:', addr)\n\n    while True:\n        data = tcpCliSock.recv(BUFSIZ)\n        if not data:\n            break\n        #tcpCliSock.send('[%s] %s' % (bytes(ctime(), 'utf-8'), data))\n        tcpCliSock.send(bytes('[%s] %s' % (ctime(), data.decode('utf-8')), 'utf-8'))\n    \n    tcpCliSock.close()\ntcpSerSock.close()\n{% endcodeblock %}\n\n{% codeblock 客户端 tsTclnt3.py lang:python %}\nfrom socket import *\n\nHOST = '127.0.0.1'\nPORT = 21567\nBUFSIZ = 1024\nADDR = (HOST, PORT)\n\ntcpCliSock = socket(AF_INET, SOCK_STREAM)\ntcpCliSock.connect(ADDR)\n\nwhile True:\n    data = input('> ')\n    if not data:\n        break\n    tcpCliSock.send(bytes(data, 'utf-8'))\n    data = tcpCliSock.recv(BUFSIZ)\n    if not data:\n        break\n    print(data.decode('utf-8'))\n\ntcpCliSock.close()\n{% endcodeblock %}\n\n**执行 TCP 服务端和客户端**\n\n服务端输出如下：\n\n```\nwaiting for connection...\n...connected from: ('127.0.0.1', 57223)\n```\n\n客户端输入及输出如下：\n\n```\n> hi\n[Mon May  7 20:05:26 2018] hi\n> spanish\n[Mon May  7 20:05:33 2018] spanish\n> \n```\n\n#### [`socketserver`](https://docs.python.org/3.6/library/socketserver.html?highlight=socketserver#module-socketserver) - 网络服务框架\n\n**[Examples](https://docs.python.org/3.6/library/socketserver.html?highlight=socketserver#examples)**\n\n#### [`asyncore`](https://docs.python.org/3.6/library/asyncore.html?highlight=asyncore#module-asyncore) / [`asynchat`](https://docs.python.org/3.6/library/asynchat.html#module-asynchat) - 异步 socket 处理器\n\n#### [`select`](https://docs.python.org/3.6/library/select.html?highlight=select#module-select) / [`selectors`](https://docs.python.org/3.6/library/selectors.html#module-selectors)\n\n> Note that on Windows, it only works for sockets;\n>\n> The [`selectors`](https://docs.python.org/3.6/library/selectors.html#module-selectors) module allows high-level and efficient I/O multiplexing, built upon the[`select`](https://docs.python.org/3.6/library/select.html?highlight=select#module-select) module primitives. Users are encouraged to use the [`selectors`](https://docs.python.org/3.6/library/selectors.html#module-selectors) module instead\n\n#### 练习\n\n1. 实现`Python`库参考文档中关于`socket`模块中TCP客户端/服务端程序示例。令其可以识别以下命令。\n   1. `date` 服务器将返回其当前日期/时间戳，即 `time.ctime()`\n   2. `os` 获取操作系统信息（`os.name`）\n   3. `ls` 列出当前目录文件清单（`os.listdir()`列出目录，`os.curdir`是当前目录）\n2. `Daytime`服务。使用`socket.getservbyname()`来确定使用UDP协议的`daytime`服务的端口号。\n\n### 因特网客户端编程\n\n#### [`http`](https://docs.python.org/3.5/library/http.html#module-http) — HTTP 包\n\n> Python3.0起，原 `httplib` 模块被并入 `http` 包中。\n\n- [`http.client`](https://docs.python.org/3.5/library/http.client.html#module-http.client) 低级 HTTP 协议客户端; 高级 HTTP 协议客户端使用 [`urllib.request`](https://docs.python.org/3.5/library/urllib.request.html#module-urllib.request)\n- [`http.server`](https://docs.python.org/3.5/library/http.server.html#module-http.server) 基于 [`socketserver`](https://docs.python.org/3.5/library/socketserver.html#module-socketserver) 的基础 HTTP 服务端类\n- [`http.cookies`](https://docs.python.org/3.5/library/http.cookies.html#module-http.cookies) 使用cookie实施状态管理的实用程序\n- [`http.cookiejar`](https://docs.python.org/3.5/library/http.cookiejar.html#module-http.cookiejar) 提供cookie的持久性\n\n#### [`ftplib`](https://docs.python.org/3.6/library/ftplib.html?highlight=ftplib#module-ftplib) - FTP 协议客户端\n\n```\n>>> from ftplib import FTP\n>>> ftp = FTP('ftp.debian.org')     # connect to host, default port\n>>> ftp.login()                     # user anonymous, passwd anonymous@\n'230 Login successful.'\n>>> ftp.cwd('debian')               # change into \"debian\" directory\n>>> ftp.retrlines('LIST')           # list directory contents\n-rw-rw-r--    1 1176     1176         1063 Jun 15 10:18 README\n...\ndrwxr-sr-x    5 1176     1176         4096 Dec 19  2000 pool\ndrwxr-sr-x    4 1176     1176         4096 Nov 17  2008 project\ndrwxr-xr-x    3 1176     1176         4096 Oct 10  2012 tools\n'226 Directory send OK.'\n>>> ftp.retrbinary('RETR README', open('README', 'wb').write)\n'226 Transfer complete.'\n>>> ftp.quit()\n```\n{% blockquote 主动和被动模式 https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE#%E4%B8%BB%E5%8A%A8%E5%92%8C%E8%A2%AB%E5%8A%A8%E6%A8%A1%E5%BC%8F 文件传输协议 %}\n\n主动模式要求客户端和服务器端同时打开并且监听一个端口以创建连接。在这种情况下，客户端由于安装了防火墙会产生一些问题。所以，创立了被动模式。被动模式只要求服务器端产生一个监听相应端口的进程，这样就可以绕过客户端安装了防火墙的问题。\n\n{% endblockquote %}\n\n> 从 Python2.1开始，默认为**被动模式**。\n\n#### [`nntplib`](https://docs.python.org/3.6/library/nntplib.html?highlight=nntp#module-nntplib) - [网络新闻传输协议](https://zh.wikipedia.org/wiki/%E7%B6%B2%E8%B7%AF%E6%96%B0%E8%81%9E%E5%82%B3%E8%BC%B8%E5%8D%94%E5%AE%9A)\n\n#### [`smtplib`](https://docs.python.org/3.6/library/smtplib.html?highlight=smtplib#module-smtplib) - SMTP 协议客户端\n\n```\n>>> from smtplib import SMTP\n>>> with SMTP(\"domain.org\") as smtp:\n...     smtp.noop()\n...\n(250, b'Ok')\n>>>\n```\n\n**[`SMTP Objects`](https://docs.python.org/3.6/library/smtplib.html?highlight=smtplib#smtp-objects)** [Example](https://docs.python.org/3.6/library/smtplib.html?highlight=smtplib#smtp-example)\n\n```python\nimport smtplib\n\ndef prompt(prompt):\n    return input(prompt).strip()\n\nfromaddr = prompt(\"From: \")\ntoaddrs  = prompt(\"To: \").split()\nprint(\"Enter message, end with ^D (Unix) or ^Z (Windows):\")\n\n# Add the From: and To: headers at the start!\nmsg = (\"From: %s\\r\\nTo: %s\\r\\n\\r\\n\"\n       % (fromaddr, \", \".join(toaddrs)))\nwhile True:\n    try:\n        line = input()\n    except EOFError:\n        break\n    if not line:\n        break\n    msg = msg + line\n\nprint(\"Message length is\", len(msg))\n\nserver = smtplib.SMTP('localhost')\nserver.set_debuglevel(1)\nserver.sendmail(fromaddr, toaddrs, msg)\nserver.quit()\n```\n\n#### [郵局協议（Post Office Protocol，简称 POP）](https://zh.wikipedia.org/wiki/%E9%83%B5%E5%B1%80%E5%8D%94%E5%AE%9A)\n\n{% blockquote 邮局协议 https://zh.wikipedia.org/wiki/%E9%83%B5%E5%B1%80%E5%8D%94%E5%AE%9A %}\n\nPOP支持离线邮件处理。其具体过程是：邮件发送到服务器上，电子邮件客户端调用邮件客户机程序以连接服务器，并下载所有未阅读的电子邮件。这种离线访问模式是一种存储转发服务，将邮件从邮件服务器端送到个人终端机器上，一般是PC机或MAC。一旦邮件发送到PC机或MAC上，邮件服务器上的邮件将会被删除。但目前的POP3邮件服务器大都可以“只下载邮件，服务器端并不删除”，也就是改进的POP3协议。\n\n{% endblockquote %}\n\n##### [`poplib`](https://docs.python.org/3.6/library/poplib.html?highlight=poplib#module-poplib) - POP3 协议客户端\n\n[`POP3 Objects`](https://docs.python.org/3.6/library/poplib.html?highlight=poplib#pop3-objects)\n\n```python\nimport getpass, poplib\n\nM = poplib.POP3('localhost')\nM.user(getpass.getuser())\nM.pass_(getpass.getpass())\nnumMessages = len(M.list()[1])\nfor i in range(numMessages):\n    for j in M.retr(i+1)[1]:\n        print(j)\n```\n\n#### [因特网信息访问协议（缩写为 IMAP，以前称作 交互邮件访问协议）](https://zh.wikipedia.org/wiki/%E5%9B%A0%E7%89%B9%E7%BD%91%E4%BF%A1%E6%81%AF%E8%AE%BF%E9%97%AE%E5%8D%8F%E8%AE%AE)\n\n{% blockquote 因特网信息访问协议 https://zh.wikipedia.org/wiki/%E5%9B%A0%E7%89%B9%E7%BD%91%E4%BF%A1%E6%81%AF%E8%AE%BF%E9%97%AE%E5%8D%8F%E8%AE%AE %}\n\n因特网信息访问协议（缩写为IMAP，以前称作交互邮件访问协议）是一个应用层协议，用来从本地邮件客户端（如Microsoft Outlook、Outlook Express、Foxmail、Mozilla Thunderbird）访问远程服务器上的邮件。\n\nIMAP和POP3（Post Office Protocol - Version 3，邮局协议第三版）是邮件访问最为普遍的Internet标准协议。事实上所有现代的邮件客户端和服务器都对两者给予支持。IMAP现在的版本是“IMAP第四版第一次修订版”（IMAP4rev1），在 RFC 3501 中定义。\n\n{% endblockquote %}\n\n##### [`imaplib`](https://docs.python.org/3.6/library/imaplib.html#module-imaplib) — IMAP4 协议客户端\n\n[`IMAP4 Objects`](https://docs.python.org/3.6/library/imaplib.html#imap4-objects)\n\n```python\nimport getpass, imaplib\n\nM = imaplib.IMAP4()\nM.login(getpass.getuser(), getpass.getpass())\nM.select()\ntyp, data = M.search(None, 'ALL')\nfor num in data[0].split():\n    typ, data = M.fetch(num, '(RFC822)')\n    print('Message %s\\n%s\\n' % (num, data[0][1]))\nM.close()\nM.logout()\n```\n\n#### [`email`](https://docs.python.org/3.6/library/email.html?highlight=email#module-email) - An email and MIME handling package\n\n#### [`smtpd`](https://docs.python.org/3.6/library/smtpd.html?highlight=smtpd#module-smtpd) - SMTP 服务端\n\n#### [`base64`](https://docs.python.org/3.6/library/base64.html?highlight=base64#module-base64) - Base16, Base32, Base64, Base85 Data Encodings\n\n#### [`mimetypes`](https://docs.python.org/3.6/library/mimetypes.html?highlight=mimetypes#module-mimetypes) - Map filenames to MIME types\n\n{% blockquote 互联网媒体类型 https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91%E5%AA%92%E4%BD%93%E7%B1%BB%E5%9E%8B %}\n\n互联网媒体类型（Internet media type，也称为MIME类型（MIME type）或内容类型（content type））是给互联网上传输的内容赋予的分类类型。一份内容的互联网媒体类型是由其文件格式与内容决定的。互联网媒体类型与文件拓展名相对应，因此计算机系统常常通过拓展名来确定一个文件的媒体类型并决定与其相关联的软件。互联网媒体类型的分类标准由互联网号码分配局（IANA）发布。1996年十一月，媒体类型在RFC 2045中被最初定义，当时仅被使用在SMTP协议的电子邮件中。现在其他的协议（比如HTTP或者SIP）也都常使用MIME类型。 一个MIME类型至少包括两个部分：一个类型（type）和一个子类型（subtype）。此外，它还可能包括一个或多个可选参数（optional parameter）。比如，HTML文件的互联网媒体类型可能是\n\ntext/html; charset = UTF-8\n\n在这个例子中，文件类型为text，子类型为html，而charset是一个可选参数，其值为UTF-8。\n\n{% endblockquote %}\n\n#### [`binascii`](https://docs.python.org/3.6/library/binascii.html?highlight=binascii#module-binascii) - Convert between binary and ASCII\n\n#### [`binhex`](https://docs.python.org/3.6/library/binhex.html?highlight=binhex#module-binhex) - Encode and decode binhex4 files\n\n#### [`quopri`](https://docs.python.org/3.6/library/quopri.html#module-quopri) - Encode and decode MIME quoted-printable data\n\n### 多线程编程\n\n#### [`_thread`](https://docs.python.org/3.6/library/_thread.html#module-_thread) - 低级线程 API\n\n#### [`threading`](https://docs.python.org/3.6/library/threading.html#module-threading) - 基于 `_thread` 的高级线程接口\n\n> `threading`模块支持守护线程([`daemon`](https://docs.python.org/3.6/library/threading.html?highlight=daemon#threading.Thread.daemon) thread)，其工作方式是：守护线程一般是一个等待客户端请求服务的服务器。如果没有客户端请求，守护线程就是空闲的。如果把一个线程设置为守护线程，就表示这个线程是**不重要的**，进程退出时不需要等待这个线程执行完成。\n>\n> 如果主线程准备退出时，不需要等待某些子线程完成，就可以为这些子线程设置守护线程标记。\n\n##### 创建 Thread 实例，传给它一个函数（多线程模式1）\n\n```python\nimport threading\nfrom time import sleep, ctime\n\nloops = [4, 2]\n\n\ndef loop(nloop, nsec):\n    print('start loop', nloop, 'at:', ctime())\n    sleep(nsec)\n    print('loop', nloop, 'done at:', ctime())\n\n\ndef main():\n    print('starting at:', ctime())\n    threads = []\n    nloops = list(range(len(loops)))\n\n    for i in nloops:\n        t = threading.Thread(target=loop,\n                             args=(i, loops[i]))\n        threads.append(t)\n\n    for i in nloops:  # start threads\n        threads[i].start()\n\n    for i in nloops:  # wait for all\n        threads[i].join()  # threads to finish\n\n    print('all DONE at:', ctime())\n\n\nif __name__ == '__main__':\n    main()\n```\n\n当所有线程都被分配完毕后，通过调用每个线程的 `start()` 方法让它们开始执行，而不是在这之前就会执行。\n\n`join()` 方法将等待线程结束，或者在提供了超时时间的情况下，达到超时时间。一旦线程启动，它们就会一直执行，知道给定的函数完成之后退出。如果主线程还有其他事情要做，而不是等待某些线程完成，就可以不调用 `join()` 。 `join()` 方法只有在需要等待线程完成的时候才是有用的。\n\n##### 创建 Thread 实例，传给它一个可调用的类的实例（多线程模式2）\n\n```python\nimport threading\nfrom time import sleep, ctime\n\nloops = [4, 2]\n\nclass ThreadFunc(object):\n    def __init__(self, func, args, name=''):\n        self.name = name\n        self.func = func\n        self.args = args\n\n    def __call__(self):\n        self.func(*self.args)\n\ndef loop(nloop, nsec):\n    print('start loop', nloop, 'at:', ctime())\n    sleep(nsec)\n    print('loop', nloop, 'done at:', ctime())\n\ndef main():\n    print('starting at:', ctime())\n    threads = []\n    nloops = range(len(loops))\n\n    for i in nloops:        # create all threads\n        t = threading.Thread(\n            target=ThreadFunc(loop, (i, loops[i]),\n            loop.__name__))\n        threads.append(t)\n\n    for i in nloops:        # start all threads\n        threads[i].start()\n\n    for i in nloops:        # wait for completion\n        threads[i].join()\n\n    print('all DONE at:', ctime())\n\nif __name__ == '__main__':\n    main()\n```\n\n相对于上一个示例，本次主要是添加了`ThreadFunc`类，并在实例化`Thread`对象的同时实例化了可调用类`ThreadFunc`。\n\n当创建新线程时，`Thread`类的代码将调用`ThreadFunc`对象，对此会调用`__call__()`这个特殊方法。\n\n##### 派生 [Thread](https://docs.python.org/3/library/threading.html?highlight=threading%20thread#thread-objects) 的子类，并创建子类的实例（多线程模式3 - 推荐方式）\n\n```python\nimport threading\nfrom time import sleep, ctime\n\nloops = [4, 2]\n\nclass MyThread(threading.Thread):\n    def __init__(self, func, args, name=''):\n        threading.Thread.__init__(self, name=name)\n        self.func = func\n        self.args = args\n\n    def run(self):\n        self.func(*self.args)\n\ndef loop(nloop, nsec):\n    print('start loop', nloop, 'at:', ctime())\n    sleep(nsec)\n    print('loop', nloop, 'done at:', ctime())\n\ndef main():\n    print('starting at:', ctime())\n    threads = []\n    nloops = range(len(loops))\n\n    for i in nloops:\n        t = MyThread(loop, (i, loops[i]),\n            loop.__name__)\n        threads.append(t)\n\n    for i in nloops:\n        threads[i].start()\n\n    for i in nloops:\n        threads[i].join()\n\n    print('all DONE at:', ctime())\n\nif __name__ == '__main__':\n    main()\n```\n\n> 对于多线程来说，相对推荐这个模式，只需要创建 [`Thread`](https://docs.python.org/3/library/threading.html?highlight=threading%20thread#threading.Thread) 的派生类，并重写 `__init__()` 及 [`run()`](https://docs.python.org/3/library/threading.html?highlight=threading%20thread#threading.Thread.run) 方法即可\n\n#### 多线程实践\n\n##### 图书排名示例\n\n```python\nimport urllib.request\nfrom atexit import register\nfrom re import compile\nfrom threading import Thread\nfrom time import ctime\n\nREGEX = compile('#([\\d,]+) in Books ')\nAMZN = 'https://www.amazon.com/dp/'\nISBNs = {\n    '0132269937': 'Core Python Programming',\n    '0132356139': 'Python Web Development with Django',\n    '0137143419': 'Python Fundamentals',\n}\n\n\ndef getRanking(isbn):\n    opener = urllib.request.build_opener()\n    opener.addheaders = [('User-agent', 'Mozilla/5.0 (X11; U; Linux i686) Gecko/20071127 Firefox/2.0.0.11')]\n    o = opener.open('{0}{1}'.format(AMZN, isbn))\n    data = str(o.read(), 'utf-8')\n    opener.close()\n    return REGEX.findall(data)[0]\n\n\ndef _showRanking(isbn):\n    print('- %r ranked %s' % (\n        ISBNs[isbn], getRanking(isbn)))\n\n\ndef _main():\n    print('At', ctime(), 'on Amazon...')\n    for isbn in ISBNs:\n        Thread(target=_showRanking, args=(isbn,)).start()  # _showRanking(isbn)\n\n\n@register\ndef _atexit():\n    print('all DONE at:', ctime())\n\n\nif __name__ == '__main__':\n    _main()\n```\n\n{% blockquote 竞争冒险 https://zh.wikipedia.org/wiki/%E7%AB%B6%E7%88%AD%E5%8D%B1%E5%AE%B3 %}\n\n**竞争冒险**（race hazard）又名**竞态条件**、**竞争条件**（race condition），它旨在描述一个系统或者进程的输出依赖于不受控制的事件出现顺序或者出现时机。此词源自于两个信号试着彼此竞争，来影响谁先输出。\n\n举例来说，如果计算机中的两个[进程](https://zh.wikipedia.org/wiki/%E8%BF%9B%E7%A8%8B)同时试图修改一个共享内存的内容，在没有[并发控制](https://zh.wikipedia.org/wiki/%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6)的情况下，最后的结果依赖于两个进程的执行顺序与时机。而且如果发生了并发访问冲突，则最后的结果是不正确的。\n\n竞争冒险常见于不良设计的电子系统，尤其是逻辑电路。但它们在[软件](https://zh.wikipedia.org/wiki/%E8%BB%9F%E9%AB%94)中也比较常见，尤其是有采用[多线程](https://zh.wikipedia.org/wiki/%E5%A4%9A%E7%BA%BF%E7%A8%8B)技术的软件。\n\n{% endblockquote %}\n\n##### [Lock Objects](https://docs.python.org/3/library/threading.html?highlight=threading#lock-objects)\n\n**原始锁定是一种同步原语，在锁定时不属于特定线程**。\n\n**当多个线程在[`acquire()`](https://docs.python.org/3/library/threading.html?highlight=threading#threading.Lock.acquire)等待状态转为解锁状态时被阻塞时，当一个[`release()`](https://docs.python.org/3/library/threading.html?highlight=threading#threading.Lock.release) 呼叫将状态重置为解锁状态时，只有一个线程继续进行; 哪一个等待的线程没有被定义，并且可能会因实现而有所不同。**\n\n```python\n#!/usr/bin/env python\n\nfrom atexit import register\nfrom random import randrange\nfrom threading import Thread, Lock, currentThread\nfrom time import sleep, ctime\n\nclass CleanOutputSet(set):\n    def __str__(self):\n        return ', '.join(x for x in self)\n\nlock = Lock()\nloops = (randrange(2, 5) for x in range(randrange(3, 7)))\nremaining = CleanOutputSet()\n\ndef loop(nsec):\n    myname = currentThread().name\n    lock.acquire()\n    remaining.add(myname)\n    print('[%s] Started %s' % (ctime(), myname)) #print '[{0}] Started {1}'.format(ctime(), myname)\n    lock.release()\n    sleep(nsec)\n    lock.acquire()\n    remaining.remove(myname)\n    print('[%s] Completed %s (%d secs)' % ( #print '[{0}] Completed {1} ({2} secs)'.format(\n        ctime(), myname, nsec))\n    print('    (remaining: %s)' % (remaining or 'NONE')) #print '    (remaining: {0})'.format(remaining or 'NONE')\n    lock.release()\n\ndef _main():\n    for pause in loops:\n        Thread(target=loop, args=(pause,)).start()\n\n@register\ndef _atexit():\n    print('all DONE at:', ctime())\n\nif __name__ == '__main__':\n    _main()\n```\n\n```\n[Thu May 10 15:52:48 2018] Started Thread-1\n[Thu May 10 15:52:48 2018] Started Thread-2\n[Thu May 10 15:52:48 2018] Started Thread-3\n[Thu May 10 15:52:48 2018] Started Thread-4\n[Thu May 10 15:52:51 2018] Completed Thread-4 (3 secs)\n    (remaining: Thread-1, Thread-3, Thread-2)\n[Thu May 10 15:52:51 2018] Completed Thread-2 (3 secs)\n    (remaining: Thread-1, Thread-3)\n[Thu May 10 15:52:52 2018] Completed Thread-1 (4 secs)\n    (remaining: Thread-3)\n[Thu May 10 15:52:52 2018] Completed Thread-3 (4 secs)\n    (remaining: NONE)\nall DONE at: Thu May 10 15:52:52 2018\n```\n\n以上示例中由于 `sleep(nsec)` 的存在，才造成了输出后半部分不同线程的结束顺序不同。\n\n> 个人理解：Lock锁线程后会造成所有线程的阻塞和等待。\n\n##### 上下文管理器 [with](https://docs.python.org/3/library/threading.html?highlight=threading#using-locks-conditions-and-semaphores-in-the-with-statement)\n\n```python\nwith some_lock:\n    # do something...\n```\n\n与以下代码是等价的\n\n```python\nsome_lock.acquire()\ntry:\n    # do something...\nfinally:\n    some_lock.release()\n```\n\n#### 信号量([Semaphore Objects](https://docs.python.org/3/library/threading.html?highlight=threading#semaphore-objects))\n\n一个信号量管理一个内部计数器，该计数器由每个 [`release()`](https://docs.python.org/3/library/threading.html?highlight=threading#threading.Semaphore.release)调用递减，并由每个[`release()`](https://docs.python.org/3/library/threading.html?highlight=threading#threading.Semaphore.release)调用递增。 柜台不能低于零; 当 [`release()`](https://docs.python.org/3/library/threading.html?highlight=threading#threading.Semaphore.release)发现它为零时，它会阻塞，等待其他线程调用[`release()`](https://docs.python.org/3/library/threading.html?highlight=threading#threading.Semaphore.release)。\n\n> 信号量通常用于保护容量有限的资源。如果资源的大小是固定的，就应该使用有界的信号量。\n\n主线程中定义信号量\n\n```python\nmaxconnections = 5\n# ...\npool_sema = BoundedSemaphore(value=maxconnections)\n```\n\n工作线程在需要连接到服务器时调用信号量的获取和释放方法：\n\n```python\nwith pool_sema:\n    conn = connectdb()\n    try:\n        # ... use connection ...\n    finally:\n        conn.close()\n```\n\n```python\nimport random\nimport time\nfrom atexit import register\nfrom threading import Thread, currentThread, BoundedSemaphore\n\nMAX = 2\n_sem = BoundedSemaphore(MAX)\n\n\ndef op(index):\n    with _sem:\n        threadName = currentThread().name\n        print('{1} thread {0} 开始执行.'.format(threadName, time.ctime()))\n        sec = random.randint(1, 10)\n        time.sleep(sec)\n        print('{1} thread {0} 开始完成.'.format(threadName, time.ctime()))\n\n\n@register\ndef _atexit():\n    print('all DONE')\n\n\ndef _main():\n    for i in range(5):\n        Thread(target=op, args=(str(i),)).start()\n\n\nif __name__ == '__main__':\n    _main()\n```\n\n输出内容如下：\n\n```\nThu May 10 16:14:10 2018 thread Thread-1 开始执行.\nThu May 10 16:14:10 2018 thread Thread-2 开始执行.\nThu May 10 16:14:15 2018 thread Thread-1 开始完成.\nThu May 10 16:14:15 2018 thread Thread-3 开始执行.\nThu May 10 16:14:20 2018 thread Thread-2 开始完成.\nThu May 10 16:14:20 2018 thread Thread-4 开始执行.\nThu May 10 16:14:21 2018 thread Thread-3 开始完成.\nThu May 10 16:14:21 2018 thread Thread-5 开始执行.\nThu May 10 16:14:28 2018 thread Thread-5 开始完成.\nThu May 10 16:14:29 2018 thread Thread-4 开始完成.\nall DONE\n```\n\n可以看到，开始执行时，最多只执行了 2 个线程，其他线程都在等待。当某一线程执行完成后，剩余线程中的一条开始执行。\n\n#### 同步队列 - [`queue`](https://docs.python.org/3/library/queue.html?highlight=queue#module-queue) — A synchronized queue class\n\n在多线程之间进行数据交换的利器。\n\n[`queue.Queue(*maxsize=0*)`](https://docs.python.org/3/library/queue.html?highlight=queue#queue.Queue) 创建一个**先入先出**的队列。\n\n[`queue.LifoQueue(maxsize=0)`]() 创建一个**后入先出**的队列。\n\n[`queue.PriorityQueue(maxsize=0)`](https://docs.python.org/3/library/queue.html?highlight=queue#queue.PriorityQueue) 创建一个[**优先队列**](https://zh.wikipedia.org/wiki/%E5%84%AA%E5%85%88%E4%BD%87%E5%88%97)。\n\n> `maxsize`是一个整数，用于设置可以放入队列中的项目数的上限。一旦达到此大小，插入将会阻塞，直到消耗队列项目。如果`maxsize`小于或等于零，则队列大小是无限的。\n\n#### 多进程\n\n由于 Python 的 GIL 的限制，多线程更适合于 I/O 密集型应用（I/O释放了GIL，可以允许更多的并发），而不是计算密集型应用。对于计算密集型应用，为了实现更好的并行性，需要使用**多进程**，以便让CPU的其他内核来执行。\n\n##### [`subprocess`](https://docs.python.org/3/library/subprocess.html?highlight=subprocess#module-subprocess) - 子进程管理\n\n##### [`multiprocessing`](https://docs.python.org/3/library/multiprocessing.html?highlight=multiprocess#module-multiprocessing) - 并行进程，该模块允许程序员充分利用给定机器上的多个处理器。\n\n##### [`concurrent.futures`](https://docs.python.org/3/library/concurrent.futures.html?highlight=concurrent%20futures#module-concurrent.futures) - 启动并行任务\n\nPython 3.2 开始提供的一个高级库。可以让开发者不在过分关注同步和线程/进程的管理。\n\n只需要指定线程池/进程池的最大工作数量，提交任务，然后整理结果即可。\n\n###### [`ThreadPoolExecutor`](https://docs.python.org/3/library/concurrent.futures.html?highlight=concurrent%20futures#concurrent.futures.ThreadPoolExecutor) - 支持异步调用的线程池\n\n```python\nimport concurrent.futures\nimport urllib.request\n\nURLS = ['http://www.foxnews.com/',\n        'http://www.cnn.com/',\n        'http://europe.wsj.com/',\n        'http://www.bbc.co.uk/',\n        'http://some-made-up-domain.com/']\n\n# Retrieve a single page and report the URL and contents\ndef load_url(url, timeout):\n    with urllib.request.urlopen(url, timeout=timeout) as conn:\n        return conn.read()\n\n# We can use a with statement to ensure threads are cleaned up promptly\nwith concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:\n    # Start the load operations and mark each future with its URL\n    future_to_url = {executor.submit(load_url, url, 60): url for url in URLS}\n    for future in concurrent.futures.as_completed(future_to_url):\n        url = future_to_url[future]\n        try:\n            data = future.result()\n        except Exception as exc:\n            print('%r generated an exception: %s' % (url, exc))\n        else:\n            print('%r page is %d bytes' % (url, len(data)))\n```\n\n###### [`ProcessPoolExecutor`](https://docs.python.org/3/library/concurrent.futures.html?highlight=concurrent%20futures#concurrent.futures.ProcessPoolExecutor) - 支持异步调用的进程池\n\n```python\nimport concurrent.futures\nimport math\n\nPRIMES = [\n    112272535095293,\n    112582705942171,\n    112272535095293,\n    115280095190773,\n    115797848077099,\n    1099726899285419]\n\ndef is_prime(n):\n    if n % 2 == 0:\n        return False\n\n    sqrt_n = int(math.floor(math.sqrt(n)))\n    for i in range(3, sqrt_n + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n\ndef main():\n    with concurrent.futures.ProcessPoolExecutor() as executor:\n        for number, prime in zip(PRIMES, executor.map(is_prime, PRIMES)):\n            print('%d is prime: %s' % (number, prime))\n\nif __name__ == '__main__':\n    main()\n```\n\n#### 练习\n\n1. 线程和文件。\n\n   1. 创建一个函数，给出一个字节值和一个文件名，然后显示文件中该字节出现的次数。\n   2. 假设输入的文件非常大。该文件允许有多个读者，现在请修改你的解决方案，创建多个线程，使每个线程负责文件某一部分的计数。然后将每个线程的数据进行整合，提供正确的总数。使用 `timeit` 模块对单线程和多线程方案进行计时。\n\n   EXP：对于此类问题，由于并不是I/O密集型操作（单一文本只读取一次的情况下）。由于多线程需要对文本进行分拆，并且多线程之间的锁定和解锁操作等多余操作，会造成采用多线程的性能会低于单一线程性能。\n\n2. 线程、文件和正则表达式。有一个非常大的邮件文件；如果没有（把所有的邮件合并到一个文本文件中）。任务是，使用正则表达式用于识别email地址和web站点的URL。并将其转换为链接形式保存到.html新文件中，当时用Web浏览器打开该文件时，这些链接应该是可以单击的。使用线程对这个大文本文件的转换过程进行分割，最后整合所有结果到一个新的.html文件中。","source":"_posts/pythoncore.md","raw":"---\ntitle: Python 核心编程\ndate: 2018-05-05 22:06:54\nupdated: 2018-05-11\ntags:\n - 编程\n - Python\nphotos:\n - /2018/05/05/pythoncore/pythoncore.png\ncategories:\n - 编程\n - Python\n出版社: 人民邮电出版社\nISBN: 9787115414779\n出版时间: 2016-05-01\ndescription: <!—more—->\n---\n\n### 正则表达式\n\n#### [`re`](https://docs.python.org/3.5/library/re.html?highlight=re#module-re) — Regular expression operations\n\n>  [`re.compile`](https://docs.python.org/3.6/library/re.html?highlight=re#re.compile) 为正则表达式提供了预编译功能。如果程序在执行过程中需要多次调用到正则表达式对象，那么采用预编译可以提升执行性能。\n\nIf you want to locate a match anywhere in *string*, use [`search()`](https://docs.python.org/3.6/library/re.html?highlight=re#re.regex.search) instead (see also [search() vs. match()](https://docs.python.org/3.6/library/re.html?highlight=re#search-vs-match)).\n\n### 网络编程\n\n#### [socket](https://docs.python.org/3.6/library/socket.html?highlight=socket#module-socket) - 低级网络接口\n\n1. 基于文件的 Socket：[`socket.AF_UNIX`](https://docs.python.org/3.6/library/socket.html?highlight=socket#socket.AF_UNIX)\n2. 基于网络的 Socket：[`socket.AF_INET`](https://docs.python.org/3.6/library/socket.html?highlight=socket#socket.AF_INET)\n\n\n1. 有链接的Socket(**TCP**)：[`socket.SOCK_STREAM`](https://docs.python.org/3.6/library/socket.html?highlight=socket#socket.SOCK_STREAM)\n2. 无链接的Socket(**UDP**)：[`socket.SOCK_DGRAM`](https://docs.python.org/3.6/library/socket.html?highlight=socket#socket.SOCK_DGRAM)\n\n`tcpSock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)`\n\n[`socket.sendall(*bytes*[, *flags*])`](https://docs.python.org/3/library/socket.html?highlight=getservbyname#socket.socket.sendall) 与 [`socket.send(*bytes*[, *flags*])`](https://docs.python.org/3/library/socket.html?highlight=getservbyname#socket.socket.send) 不同，此方法继续从字节发送数据，直到发送所有数据或发生错误。\n\n[`socket.send(*bytes*[, *flags*])`](https://docs.python.org/3/library/socket.html?highlight=getservbyname#socket.socket.send) 返回发送的字节数。由应用程序负责检查所有数据是否已发送;\n\nTCP服务端和客户端示例**\n\n{% codeblock 服务端 tsTserv3.py lang:python %}\nfrom socket import *\nfrom time import ctime\n\nHOST = ''\nPORT = 21567\nBUFSIZ = 1024\nADDR = (HOST, PORT)\n\ntcpSerSock = socket(AF_INET, SOCK_STREAM)\ntcpSerSock.bind(ADDR)\ntcpSerSock.listen(5)\n\nwhile True:\n    print('waiting for connection...')\n    tcpCliSock, addr = tcpSerSock.accept()\n    print('...connected from:', addr)\n\n    while True:\n        data = tcpCliSock.recv(BUFSIZ)\n        if not data:\n            break\n        #tcpCliSock.send('[%s] %s' % (bytes(ctime(), 'utf-8'), data))\n        tcpCliSock.send(bytes('[%s] %s' % (ctime(), data.decode('utf-8')), 'utf-8'))\n    \n    tcpCliSock.close()\ntcpSerSock.close()\n{% endcodeblock %}\n\n{% codeblock 客户端 tsTclnt3.py lang:python %}\nfrom socket import *\n\nHOST = '127.0.0.1'\nPORT = 21567\nBUFSIZ = 1024\nADDR = (HOST, PORT)\n\ntcpCliSock = socket(AF_INET, SOCK_STREAM)\ntcpCliSock.connect(ADDR)\n\nwhile True:\n    data = input('> ')\n    if not data:\n        break\n    tcpCliSock.send(bytes(data, 'utf-8'))\n    data = tcpCliSock.recv(BUFSIZ)\n    if not data:\n        break\n    print(data.decode('utf-8'))\n\ntcpCliSock.close()\n{% endcodeblock %}\n\n**执行 TCP 服务端和客户端**\n\n服务端输出如下：\n\n```\nwaiting for connection...\n...connected from: ('127.0.0.1', 57223)\n```\n\n客户端输入及输出如下：\n\n```\n> hi\n[Mon May  7 20:05:26 2018] hi\n> spanish\n[Mon May  7 20:05:33 2018] spanish\n> \n```\n\n#### [`socketserver`](https://docs.python.org/3.6/library/socketserver.html?highlight=socketserver#module-socketserver) - 网络服务框架\n\n**[Examples](https://docs.python.org/3.6/library/socketserver.html?highlight=socketserver#examples)**\n\n#### [`asyncore`](https://docs.python.org/3.6/library/asyncore.html?highlight=asyncore#module-asyncore) / [`asynchat`](https://docs.python.org/3.6/library/asynchat.html#module-asynchat) - 异步 socket 处理器\n\n#### [`select`](https://docs.python.org/3.6/library/select.html?highlight=select#module-select) / [`selectors`](https://docs.python.org/3.6/library/selectors.html#module-selectors)\n\n> Note that on Windows, it only works for sockets;\n>\n> The [`selectors`](https://docs.python.org/3.6/library/selectors.html#module-selectors) module allows high-level and efficient I/O multiplexing, built upon the[`select`](https://docs.python.org/3.6/library/select.html?highlight=select#module-select) module primitives. Users are encouraged to use the [`selectors`](https://docs.python.org/3.6/library/selectors.html#module-selectors) module instead\n\n#### 练习\n\n1. 实现`Python`库参考文档中关于`socket`模块中TCP客户端/服务端程序示例。令其可以识别以下命令。\n   1. `date` 服务器将返回其当前日期/时间戳，即 `time.ctime()`\n   2. `os` 获取操作系统信息（`os.name`）\n   3. `ls` 列出当前目录文件清单（`os.listdir()`列出目录，`os.curdir`是当前目录）\n2. `Daytime`服务。使用`socket.getservbyname()`来确定使用UDP协议的`daytime`服务的端口号。\n\n### 因特网客户端编程\n\n#### [`http`](https://docs.python.org/3.5/library/http.html#module-http) — HTTP 包\n\n> Python3.0起，原 `httplib` 模块被并入 `http` 包中。\n\n- [`http.client`](https://docs.python.org/3.5/library/http.client.html#module-http.client) 低级 HTTP 协议客户端; 高级 HTTP 协议客户端使用 [`urllib.request`](https://docs.python.org/3.5/library/urllib.request.html#module-urllib.request)\n- [`http.server`](https://docs.python.org/3.5/library/http.server.html#module-http.server) 基于 [`socketserver`](https://docs.python.org/3.5/library/socketserver.html#module-socketserver) 的基础 HTTP 服务端类\n- [`http.cookies`](https://docs.python.org/3.5/library/http.cookies.html#module-http.cookies) 使用cookie实施状态管理的实用程序\n- [`http.cookiejar`](https://docs.python.org/3.5/library/http.cookiejar.html#module-http.cookiejar) 提供cookie的持久性\n\n#### [`ftplib`](https://docs.python.org/3.6/library/ftplib.html?highlight=ftplib#module-ftplib) - FTP 协议客户端\n\n```\n>>> from ftplib import FTP\n>>> ftp = FTP('ftp.debian.org')     # connect to host, default port\n>>> ftp.login()                     # user anonymous, passwd anonymous@\n'230 Login successful.'\n>>> ftp.cwd('debian')               # change into \"debian\" directory\n>>> ftp.retrlines('LIST')           # list directory contents\n-rw-rw-r--    1 1176     1176         1063 Jun 15 10:18 README\n...\ndrwxr-sr-x    5 1176     1176         4096 Dec 19  2000 pool\ndrwxr-sr-x    4 1176     1176         4096 Nov 17  2008 project\ndrwxr-xr-x    3 1176     1176         4096 Oct 10  2012 tools\n'226 Directory send OK.'\n>>> ftp.retrbinary('RETR README', open('README', 'wb').write)\n'226 Transfer complete.'\n>>> ftp.quit()\n```\n{% blockquote 主动和被动模式 https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE#%E4%B8%BB%E5%8A%A8%E5%92%8C%E8%A2%AB%E5%8A%A8%E6%A8%A1%E5%BC%8F 文件传输协议 %}\n\n主动模式要求客户端和服务器端同时打开并且监听一个端口以创建连接。在这种情况下，客户端由于安装了防火墙会产生一些问题。所以，创立了被动模式。被动模式只要求服务器端产生一个监听相应端口的进程，这样就可以绕过客户端安装了防火墙的问题。\n\n{% endblockquote %}\n\n> 从 Python2.1开始，默认为**被动模式**。\n\n#### [`nntplib`](https://docs.python.org/3.6/library/nntplib.html?highlight=nntp#module-nntplib) - [网络新闻传输协议](https://zh.wikipedia.org/wiki/%E7%B6%B2%E8%B7%AF%E6%96%B0%E8%81%9E%E5%82%B3%E8%BC%B8%E5%8D%94%E5%AE%9A)\n\n#### [`smtplib`](https://docs.python.org/3.6/library/smtplib.html?highlight=smtplib#module-smtplib) - SMTP 协议客户端\n\n```\n>>> from smtplib import SMTP\n>>> with SMTP(\"domain.org\") as smtp:\n...     smtp.noop()\n...\n(250, b'Ok')\n>>>\n```\n\n**[`SMTP Objects`](https://docs.python.org/3.6/library/smtplib.html?highlight=smtplib#smtp-objects)** [Example](https://docs.python.org/3.6/library/smtplib.html?highlight=smtplib#smtp-example)\n\n```python\nimport smtplib\n\ndef prompt(prompt):\n    return input(prompt).strip()\n\nfromaddr = prompt(\"From: \")\ntoaddrs  = prompt(\"To: \").split()\nprint(\"Enter message, end with ^D (Unix) or ^Z (Windows):\")\n\n# Add the From: and To: headers at the start!\nmsg = (\"From: %s\\r\\nTo: %s\\r\\n\\r\\n\"\n       % (fromaddr, \", \".join(toaddrs)))\nwhile True:\n    try:\n        line = input()\n    except EOFError:\n        break\n    if not line:\n        break\n    msg = msg + line\n\nprint(\"Message length is\", len(msg))\n\nserver = smtplib.SMTP('localhost')\nserver.set_debuglevel(1)\nserver.sendmail(fromaddr, toaddrs, msg)\nserver.quit()\n```\n\n#### [郵局協议（Post Office Protocol，简称 POP）](https://zh.wikipedia.org/wiki/%E9%83%B5%E5%B1%80%E5%8D%94%E5%AE%9A)\n\n{% blockquote 邮局协议 https://zh.wikipedia.org/wiki/%E9%83%B5%E5%B1%80%E5%8D%94%E5%AE%9A %}\n\nPOP支持离线邮件处理。其具体过程是：邮件发送到服务器上，电子邮件客户端调用邮件客户机程序以连接服务器，并下载所有未阅读的电子邮件。这种离线访问模式是一种存储转发服务，将邮件从邮件服务器端送到个人终端机器上，一般是PC机或MAC。一旦邮件发送到PC机或MAC上，邮件服务器上的邮件将会被删除。但目前的POP3邮件服务器大都可以“只下载邮件，服务器端并不删除”，也就是改进的POP3协议。\n\n{% endblockquote %}\n\n##### [`poplib`](https://docs.python.org/3.6/library/poplib.html?highlight=poplib#module-poplib) - POP3 协议客户端\n\n[`POP3 Objects`](https://docs.python.org/3.6/library/poplib.html?highlight=poplib#pop3-objects)\n\n```python\nimport getpass, poplib\n\nM = poplib.POP3('localhost')\nM.user(getpass.getuser())\nM.pass_(getpass.getpass())\nnumMessages = len(M.list()[1])\nfor i in range(numMessages):\n    for j in M.retr(i+1)[1]:\n        print(j)\n```\n\n#### [因特网信息访问协议（缩写为 IMAP，以前称作 交互邮件访问协议）](https://zh.wikipedia.org/wiki/%E5%9B%A0%E7%89%B9%E7%BD%91%E4%BF%A1%E6%81%AF%E8%AE%BF%E9%97%AE%E5%8D%8F%E8%AE%AE)\n\n{% blockquote 因特网信息访问协议 https://zh.wikipedia.org/wiki/%E5%9B%A0%E7%89%B9%E7%BD%91%E4%BF%A1%E6%81%AF%E8%AE%BF%E9%97%AE%E5%8D%8F%E8%AE%AE %}\n\n因特网信息访问协议（缩写为IMAP，以前称作交互邮件访问协议）是一个应用层协议，用来从本地邮件客户端（如Microsoft Outlook、Outlook Express、Foxmail、Mozilla Thunderbird）访问远程服务器上的邮件。\n\nIMAP和POP3（Post Office Protocol - Version 3，邮局协议第三版）是邮件访问最为普遍的Internet标准协议。事实上所有现代的邮件客户端和服务器都对两者给予支持。IMAP现在的版本是“IMAP第四版第一次修订版”（IMAP4rev1），在 RFC 3501 中定义。\n\n{% endblockquote %}\n\n##### [`imaplib`](https://docs.python.org/3.6/library/imaplib.html#module-imaplib) — IMAP4 协议客户端\n\n[`IMAP4 Objects`](https://docs.python.org/3.6/library/imaplib.html#imap4-objects)\n\n```python\nimport getpass, imaplib\n\nM = imaplib.IMAP4()\nM.login(getpass.getuser(), getpass.getpass())\nM.select()\ntyp, data = M.search(None, 'ALL')\nfor num in data[0].split():\n    typ, data = M.fetch(num, '(RFC822)')\n    print('Message %s\\n%s\\n' % (num, data[0][1]))\nM.close()\nM.logout()\n```\n\n#### [`email`](https://docs.python.org/3.6/library/email.html?highlight=email#module-email) - An email and MIME handling package\n\n#### [`smtpd`](https://docs.python.org/3.6/library/smtpd.html?highlight=smtpd#module-smtpd) - SMTP 服务端\n\n#### [`base64`](https://docs.python.org/3.6/library/base64.html?highlight=base64#module-base64) - Base16, Base32, Base64, Base85 Data Encodings\n\n#### [`mimetypes`](https://docs.python.org/3.6/library/mimetypes.html?highlight=mimetypes#module-mimetypes) - Map filenames to MIME types\n\n{% blockquote 互联网媒体类型 https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91%E5%AA%92%E4%BD%93%E7%B1%BB%E5%9E%8B %}\n\n互联网媒体类型（Internet media type，也称为MIME类型（MIME type）或内容类型（content type））是给互联网上传输的内容赋予的分类类型。一份内容的互联网媒体类型是由其文件格式与内容决定的。互联网媒体类型与文件拓展名相对应，因此计算机系统常常通过拓展名来确定一个文件的媒体类型并决定与其相关联的软件。互联网媒体类型的分类标准由互联网号码分配局（IANA）发布。1996年十一月，媒体类型在RFC 2045中被最初定义，当时仅被使用在SMTP协议的电子邮件中。现在其他的协议（比如HTTP或者SIP）也都常使用MIME类型。 一个MIME类型至少包括两个部分：一个类型（type）和一个子类型（subtype）。此外，它还可能包括一个或多个可选参数（optional parameter）。比如，HTML文件的互联网媒体类型可能是\n\ntext/html; charset = UTF-8\n\n在这个例子中，文件类型为text，子类型为html，而charset是一个可选参数，其值为UTF-8。\n\n{% endblockquote %}\n\n#### [`binascii`](https://docs.python.org/3.6/library/binascii.html?highlight=binascii#module-binascii) - Convert between binary and ASCII\n\n#### [`binhex`](https://docs.python.org/3.6/library/binhex.html?highlight=binhex#module-binhex) - Encode and decode binhex4 files\n\n#### [`quopri`](https://docs.python.org/3.6/library/quopri.html#module-quopri) - Encode and decode MIME quoted-printable data\n\n### 多线程编程\n\n#### [`_thread`](https://docs.python.org/3.6/library/_thread.html#module-_thread) - 低级线程 API\n\n#### [`threading`](https://docs.python.org/3.6/library/threading.html#module-threading) - 基于 `_thread` 的高级线程接口\n\n> `threading`模块支持守护线程([`daemon`](https://docs.python.org/3.6/library/threading.html?highlight=daemon#threading.Thread.daemon) thread)，其工作方式是：守护线程一般是一个等待客户端请求服务的服务器。如果没有客户端请求，守护线程就是空闲的。如果把一个线程设置为守护线程，就表示这个线程是**不重要的**，进程退出时不需要等待这个线程执行完成。\n>\n> 如果主线程准备退出时，不需要等待某些子线程完成，就可以为这些子线程设置守护线程标记。\n\n##### 创建 Thread 实例，传给它一个函数（多线程模式1）\n\n```python\nimport threading\nfrom time import sleep, ctime\n\nloops = [4, 2]\n\n\ndef loop(nloop, nsec):\n    print('start loop', nloop, 'at:', ctime())\n    sleep(nsec)\n    print('loop', nloop, 'done at:', ctime())\n\n\ndef main():\n    print('starting at:', ctime())\n    threads = []\n    nloops = list(range(len(loops)))\n\n    for i in nloops:\n        t = threading.Thread(target=loop,\n                             args=(i, loops[i]))\n        threads.append(t)\n\n    for i in nloops:  # start threads\n        threads[i].start()\n\n    for i in nloops:  # wait for all\n        threads[i].join()  # threads to finish\n\n    print('all DONE at:', ctime())\n\n\nif __name__ == '__main__':\n    main()\n```\n\n当所有线程都被分配完毕后，通过调用每个线程的 `start()` 方法让它们开始执行，而不是在这之前就会执行。\n\n`join()` 方法将等待线程结束，或者在提供了超时时间的情况下，达到超时时间。一旦线程启动，它们就会一直执行，知道给定的函数完成之后退出。如果主线程还有其他事情要做，而不是等待某些线程完成，就可以不调用 `join()` 。 `join()` 方法只有在需要等待线程完成的时候才是有用的。\n\n##### 创建 Thread 实例，传给它一个可调用的类的实例（多线程模式2）\n\n```python\nimport threading\nfrom time import sleep, ctime\n\nloops = [4, 2]\n\nclass ThreadFunc(object):\n    def __init__(self, func, args, name=''):\n        self.name = name\n        self.func = func\n        self.args = args\n\n    def __call__(self):\n        self.func(*self.args)\n\ndef loop(nloop, nsec):\n    print('start loop', nloop, 'at:', ctime())\n    sleep(nsec)\n    print('loop', nloop, 'done at:', ctime())\n\ndef main():\n    print('starting at:', ctime())\n    threads = []\n    nloops = range(len(loops))\n\n    for i in nloops:        # create all threads\n        t = threading.Thread(\n            target=ThreadFunc(loop, (i, loops[i]),\n            loop.__name__))\n        threads.append(t)\n\n    for i in nloops:        # start all threads\n        threads[i].start()\n\n    for i in nloops:        # wait for completion\n        threads[i].join()\n\n    print('all DONE at:', ctime())\n\nif __name__ == '__main__':\n    main()\n```\n\n相对于上一个示例，本次主要是添加了`ThreadFunc`类，并在实例化`Thread`对象的同时实例化了可调用类`ThreadFunc`。\n\n当创建新线程时，`Thread`类的代码将调用`ThreadFunc`对象，对此会调用`__call__()`这个特殊方法。\n\n##### 派生 [Thread](https://docs.python.org/3/library/threading.html?highlight=threading%20thread#thread-objects) 的子类，并创建子类的实例（多线程模式3 - 推荐方式）\n\n```python\nimport threading\nfrom time import sleep, ctime\n\nloops = [4, 2]\n\nclass MyThread(threading.Thread):\n    def __init__(self, func, args, name=''):\n        threading.Thread.__init__(self, name=name)\n        self.func = func\n        self.args = args\n\n    def run(self):\n        self.func(*self.args)\n\ndef loop(nloop, nsec):\n    print('start loop', nloop, 'at:', ctime())\n    sleep(nsec)\n    print('loop', nloop, 'done at:', ctime())\n\ndef main():\n    print('starting at:', ctime())\n    threads = []\n    nloops = range(len(loops))\n\n    for i in nloops:\n        t = MyThread(loop, (i, loops[i]),\n            loop.__name__)\n        threads.append(t)\n\n    for i in nloops:\n        threads[i].start()\n\n    for i in nloops:\n        threads[i].join()\n\n    print('all DONE at:', ctime())\n\nif __name__ == '__main__':\n    main()\n```\n\n> 对于多线程来说，相对推荐这个模式，只需要创建 [`Thread`](https://docs.python.org/3/library/threading.html?highlight=threading%20thread#threading.Thread) 的派生类，并重写 `__init__()` 及 [`run()`](https://docs.python.org/3/library/threading.html?highlight=threading%20thread#threading.Thread.run) 方法即可\n\n#### 多线程实践\n\n##### 图书排名示例\n\n```python\nimport urllib.request\nfrom atexit import register\nfrom re import compile\nfrom threading import Thread\nfrom time import ctime\n\nREGEX = compile('#([\\d,]+) in Books ')\nAMZN = 'https://www.amazon.com/dp/'\nISBNs = {\n    '0132269937': 'Core Python Programming',\n    '0132356139': 'Python Web Development with Django',\n    '0137143419': 'Python Fundamentals',\n}\n\n\ndef getRanking(isbn):\n    opener = urllib.request.build_opener()\n    opener.addheaders = [('User-agent', 'Mozilla/5.0 (X11; U; Linux i686) Gecko/20071127 Firefox/2.0.0.11')]\n    o = opener.open('{0}{1}'.format(AMZN, isbn))\n    data = str(o.read(), 'utf-8')\n    opener.close()\n    return REGEX.findall(data)[0]\n\n\ndef _showRanking(isbn):\n    print('- %r ranked %s' % (\n        ISBNs[isbn], getRanking(isbn)))\n\n\ndef _main():\n    print('At', ctime(), 'on Amazon...')\n    for isbn in ISBNs:\n        Thread(target=_showRanking, args=(isbn,)).start()  # _showRanking(isbn)\n\n\n@register\ndef _atexit():\n    print('all DONE at:', ctime())\n\n\nif __name__ == '__main__':\n    _main()\n```\n\n{% blockquote 竞争冒险 https://zh.wikipedia.org/wiki/%E7%AB%B6%E7%88%AD%E5%8D%B1%E5%AE%B3 %}\n\n**竞争冒险**（race hazard）又名**竞态条件**、**竞争条件**（race condition），它旨在描述一个系统或者进程的输出依赖于不受控制的事件出现顺序或者出现时机。此词源自于两个信号试着彼此竞争，来影响谁先输出。\n\n举例来说，如果计算机中的两个[进程](https://zh.wikipedia.org/wiki/%E8%BF%9B%E7%A8%8B)同时试图修改一个共享内存的内容，在没有[并发控制](https://zh.wikipedia.org/wiki/%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6)的情况下，最后的结果依赖于两个进程的执行顺序与时机。而且如果发生了并发访问冲突，则最后的结果是不正确的。\n\n竞争冒险常见于不良设计的电子系统，尤其是逻辑电路。但它们在[软件](https://zh.wikipedia.org/wiki/%E8%BB%9F%E9%AB%94)中也比较常见，尤其是有采用[多线程](https://zh.wikipedia.org/wiki/%E5%A4%9A%E7%BA%BF%E7%A8%8B)技术的软件。\n\n{% endblockquote %}\n\n##### [Lock Objects](https://docs.python.org/3/library/threading.html?highlight=threading#lock-objects)\n\n**原始锁定是一种同步原语，在锁定时不属于特定线程**。\n\n**当多个线程在[`acquire()`](https://docs.python.org/3/library/threading.html?highlight=threading#threading.Lock.acquire)等待状态转为解锁状态时被阻塞时，当一个[`release()`](https://docs.python.org/3/library/threading.html?highlight=threading#threading.Lock.release) 呼叫将状态重置为解锁状态时，只有一个线程继续进行; 哪一个等待的线程没有被定义，并且可能会因实现而有所不同。**\n\n```python\n#!/usr/bin/env python\n\nfrom atexit import register\nfrom random import randrange\nfrom threading import Thread, Lock, currentThread\nfrom time import sleep, ctime\n\nclass CleanOutputSet(set):\n    def __str__(self):\n        return ', '.join(x for x in self)\n\nlock = Lock()\nloops = (randrange(2, 5) for x in range(randrange(3, 7)))\nremaining = CleanOutputSet()\n\ndef loop(nsec):\n    myname = currentThread().name\n    lock.acquire()\n    remaining.add(myname)\n    print('[%s] Started %s' % (ctime(), myname)) #print '[{0}] Started {1}'.format(ctime(), myname)\n    lock.release()\n    sleep(nsec)\n    lock.acquire()\n    remaining.remove(myname)\n    print('[%s] Completed %s (%d secs)' % ( #print '[{0}] Completed {1} ({2} secs)'.format(\n        ctime(), myname, nsec))\n    print('    (remaining: %s)' % (remaining or 'NONE')) #print '    (remaining: {0})'.format(remaining or 'NONE')\n    lock.release()\n\ndef _main():\n    for pause in loops:\n        Thread(target=loop, args=(pause,)).start()\n\n@register\ndef _atexit():\n    print('all DONE at:', ctime())\n\nif __name__ == '__main__':\n    _main()\n```\n\n```\n[Thu May 10 15:52:48 2018] Started Thread-1\n[Thu May 10 15:52:48 2018] Started Thread-2\n[Thu May 10 15:52:48 2018] Started Thread-3\n[Thu May 10 15:52:48 2018] Started Thread-4\n[Thu May 10 15:52:51 2018] Completed Thread-4 (3 secs)\n    (remaining: Thread-1, Thread-3, Thread-2)\n[Thu May 10 15:52:51 2018] Completed Thread-2 (3 secs)\n    (remaining: Thread-1, Thread-3)\n[Thu May 10 15:52:52 2018] Completed Thread-1 (4 secs)\n    (remaining: Thread-3)\n[Thu May 10 15:52:52 2018] Completed Thread-3 (4 secs)\n    (remaining: NONE)\nall DONE at: Thu May 10 15:52:52 2018\n```\n\n以上示例中由于 `sleep(nsec)` 的存在，才造成了输出后半部分不同线程的结束顺序不同。\n\n> 个人理解：Lock锁线程后会造成所有线程的阻塞和等待。\n\n##### 上下文管理器 [with](https://docs.python.org/3/library/threading.html?highlight=threading#using-locks-conditions-and-semaphores-in-the-with-statement)\n\n```python\nwith some_lock:\n    # do something...\n```\n\n与以下代码是等价的\n\n```python\nsome_lock.acquire()\ntry:\n    # do something...\nfinally:\n    some_lock.release()\n```\n\n#### 信号量([Semaphore Objects](https://docs.python.org/3/library/threading.html?highlight=threading#semaphore-objects))\n\n一个信号量管理一个内部计数器，该计数器由每个 [`release()`](https://docs.python.org/3/library/threading.html?highlight=threading#threading.Semaphore.release)调用递减，并由每个[`release()`](https://docs.python.org/3/library/threading.html?highlight=threading#threading.Semaphore.release)调用递增。 柜台不能低于零; 当 [`release()`](https://docs.python.org/3/library/threading.html?highlight=threading#threading.Semaphore.release)发现它为零时，它会阻塞，等待其他线程调用[`release()`](https://docs.python.org/3/library/threading.html?highlight=threading#threading.Semaphore.release)。\n\n> 信号量通常用于保护容量有限的资源。如果资源的大小是固定的，就应该使用有界的信号量。\n\n主线程中定义信号量\n\n```python\nmaxconnections = 5\n# ...\npool_sema = BoundedSemaphore(value=maxconnections)\n```\n\n工作线程在需要连接到服务器时调用信号量的获取和释放方法：\n\n```python\nwith pool_sema:\n    conn = connectdb()\n    try:\n        # ... use connection ...\n    finally:\n        conn.close()\n```\n\n```python\nimport random\nimport time\nfrom atexit import register\nfrom threading import Thread, currentThread, BoundedSemaphore\n\nMAX = 2\n_sem = BoundedSemaphore(MAX)\n\n\ndef op(index):\n    with _sem:\n        threadName = currentThread().name\n        print('{1} thread {0} 开始执行.'.format(threadName, time.ctime()))\n        sec = random.randint(1, 10)\n        time.sleep(sec)\n        print('{1} thread {0} 开始完成.'.format(threadName, time.ctime()))\n\n\n@register\ndef _atexit():\n    print('all DONE')\n\n\ndef _main():\n    for i in range(5):\n        Thread(target=op, args=(str(i),)).start()\n\n\nif __name__ == '__main__':\n    _main()\n```\n\n输出内容如下：\n\n```\nThu May 10 16:14:10 2018 thread Thread-1 开始执行.\nThu May 10 16:14:10 2018 thread Thread-2 开始执行.\nThu May 10 16:14:15 2018 thread Thread-1 开始完成.\nThu May 10 16:14:15 2018 thread Thread-3 开始执行.\nThu May 10 16:14:20 2018 thread Thread-2 开始完成.\nThu May 10 16:14:20 2018 thread Thread-4 开始执行.\nThu May 10 16:14:21 2018 thread Thread-3 开始完成.\nThu May 10 16:14:21 2018 thread Thread-5 开始执行.\nThu May 10 16:14:28 2018 thread Thread-5 开始完成.\nThu May 10 16:14:29 2018 thread Thread-4 开始完成.\nall DONE\n```\n\n可以看到，开始执行时，最多只执行了 2 个线程，其他线程都在等待。当某一线程执行完成后，剩余线程中的一条开始执行。\n\n#### 同步队列 - [`queue`](https://docs.python.org/3/library/queue.html?highlight=queue#module-queue) — A synchronized queue class\n\n在多线程之间进行数据交换的利器。\n\n[`queue.Queue(*maxsize=0*)`](https://docs.python.org/3/library/queue.html?highlight=queue#queue.Queue) 创建一个**先入先出**的队列。\n\n[`queue.LifoQueue(maxsize=0)`]() 创建一个**后入先出**的队列。\n\n[`queue.PriorityQueue(maxsize=0)`](https://docs.python.org/3/library/queue.html?highlight=queue#queue.PriorityQueue) 创建一个[**优先队列**](https://zh.wikipedia.org/wiki/%E5%84%AA%E5%85%88%E4%BD%87%E5%88%97)。\n\n> `maxsize`是一个整数，用于设置可以放入队列中的项目数的上限。一旦达到此大小，插入将会阻塞，直到消耗队列项目。如果`maxsize`小于或等于零，则队列大小是无限的。\n\n#### 多进程\n\n由于 Python 的 GIL 的限制，多线程更适合于 I/O 密集型应用（I/O释放了GIL，可以允许更多的并发），而不是计算密集型应用。对于计算密集型应用，为了实现更好的并行性，需要使用**多进程**，以便让CPU的其他内核来执行。\n\n##### [`subprocess`](https://docs.python.org/3/library/subprocess.html?highlight=subprocess#module-subprocess) - 子进程管理\n\n##### [`multiprocessing`](https://docs.python.org/3/library/multiprocessing.html?highlight=multiprocess#module-multiprocessing) - 并行进程，该模块允许程序员充分利用给定机器上的多个处理器。\n\n##### [`concurrent.futures`](https://docs.python.org/3/library/concurrent.futures.html?highlight=concurrent%20futures#module-concurrent.futures) - 启动并行任务\n\nPython 3.2 开始提供的一个高级库。可以让开发者不在过分关注同步和线程/进程的管理。\n\n只需要指定线程池/进程池的最大工作数量，提交任务，然后整理结果即可。\n\n###### [`ThreadPoolExecutor`](https://docs.python.org/3/library/concurrent.futures.html?highlight=concurrent%20futures#concurrent.futures.ThreadPoolExecutor) - 支持异步调用的线程池\n\n```python\nimport concurrent.futures\nimport urllib.request\n\nURLS = ['http://www.foxnews.com/',\n        'http://www.cnn.com/',\n        'http://europe.wsj.com/',\n        'http://www.bbc.co.uk/',\n        'http://some-made-up-domain.com/']\n\n# Retrieve a single page and report the URL and contents\ndef load_url(url, timeout):\n    with urllib.request.urlopen(url, timeout=timeout) as conn:\n        return conn.read()\n\n# We can use a with statement to ensure threads are cleaned up promptly\nwith concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:\n    # Start the load operations and mark each future with its URL\n    future_to_url = {executor.submit(load_url, url, 60): url for url in URLS}\n    for future in concurrent.futures.as_completed(future_to_url):\n        url = future_to_url[future]\n        try:\n            data = future.result()\n        except Exception as exc:\n            print('%r generated an exception: %s' % (url, exc))\n        else:\n            print('%r page is %d bytes' % (url, len(data)))\n```\n\n###### [`ProcessPoolExecutor`](https://docs.python.org/3/library/concurrent.futures.html?highlight=concurrent%20futures#concurrent.futures.ProcessPoolExecutor) - 支持异步调用的进程池\n\n```python\nimport concurrent.futures\nimport math\n\nPRIMES = [\n    112272535095293,\n    112582705942171,\n    112272535095293,\n    115280095190773,\n    115797848077099,\n    1099726899285419]\n\ndef is_prime(n):\n    if n % 2 == 0:\n        return False\n\n    sqrt_n = int(math.floor(math.sqrt(n)))\n    for i in range(3, sqrt_n + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n\ndef main():\n    with concurrent.futures.ProcessPoolExecutor() as executor:\n        for number, prime in zip(PRIMES, executor.map(is_prime, PRIMES)):\n            print('%d is prime: %s' % (number, prime))\n\nif __name__ == '__main__':\n    main()\n```\n\n#### 练习\n\n1. 线程和文件。\n\n   1. 创建一个函数，给出一个字节值和一个文件名，然后显示文件中该字节出现的次数。\n   2. 假设输入的文件非常大。该文件允许有多个读者，现在请修改你的解决方案，创建多个线程，使每个线程负责文件某一部分的计数。然后将每个线程的数据进行整合，提供正确的总数。使用 `timeit` 模块对单线程和多线程方案进行计时。\n\n   EXP：对于此类问题，由于并不是I/O密集型操作（单一文本只读取一次的情况下）。由于多线程需要对文本进行分拆，并且多线程之间的锁定和解锁操作等多余操作，会造成采用多线程的性能会低于单一线程性能。\n\n2. 线程、文件和正则表达式。有一个非常大的邮件文件；如果没有（把所有的邮件合并到一个文本文件中）。任务是，使用正则表达式用于识别email地址和web站点的URL。并将其转换为链接形式保存到.html新文件中，当时用Web浏览器打开该文件时，这些链接应该是可以单击的。使用线程对这个大文本文件的转换过程进行分割，最后整合所有结果到一个新的.html文件中。","slug":"pythoncore","published":1,"comments":1,"layout":"post","link":"","_id":"cjof51pju0007rgue4mz3f04j","content":"<h3 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h3><h4 id=\"re-—-Regular-expression-operations\"><a href=\"#re-—-Regular-expression-operations\" class=\"headerlink\" title=\"re — Regular expression operations\"></a><a href=\"https://docs.python.org/3.5/library/re.html?highlight=re#module-re\" target=\"_blank\" rel=\"noopener\"><code>re</code></a> — Regular expression operations</h4><blockquote>\n<p> <a href=\"https://docs.python.org/3.6/library/re.html?highlight=re#re.compile\" target=\"_blank\" rel=\"noopener\"><code>re.compile</code></a> 为正则表达式提供了预编译功能。如果程序在执行过程中需要多次调用到正则表达式对象，那么采用预编译可以提升执行性能。</p>\n</blockquote>\n<p>If you want to locate a match anywhere in <em>string</em>, use <a href=\"https://docs.python.org/3.6/library/re.html?highlight=re#re.regex.search\" target=\"_blank\" rel=\"noopener\"><code>search()</code></a> instead (see also <a href=\"https://docs.python.org/3.6/library/re.html?highlight=re#search-vs-match\" target=\"_blank\" rel=\"noopener\">search() vs. match()</a>).</p>\n<h3 id=\"网络编程\"><a href=\"#网络编程\" class=\"headerlink\" title=\"网络编程\"></a>网络编程</h3><h4 id=\"socket-低级网络接口\"><a href=\"#socket-低级网络接口\" class=\"headerlink\" title=\"socket - 低级网络接口\"></a><a href=\"https://docs.python.org/3.6/library/socket.html?highlight=socket#module-socket\" target=\"_blank\" rel=\"noopener\">socket</a> - 低级网络接口</h4><ol>\n<li>基于文件的 Socket：<a href=\"https://docs.python.org/3.6/library/socket.html?highlight=socket#socket.AF_UNIX\" target=\"_blank\" rel=\"noopener\"><code>socket.AF_UNIX</code></a></li>\n<li>基于网络的 Socket：<a href=\"https://docs.python.org/3.6/library/socket.html?highlight=socket#socket.AF_INET\" target=\"_blank\" rel=\"noopener\"><code>socket.AF_INET</code></a></li>\n</ol>\n<ol>\n<li>有链接的Socket(<strong>TCP</strong>)：<a href=\"https://docs.python.org/3.6/library/socket.html?highlight=socket#socket.SOCK_STREAM\" target=\"_blank\" rel=\"noopener\"><code>socket.SOCK_STREAM</code></a></li>\n<li>无链接的Socket(<strong>UDP</strong>)：<a href=\"https://docs.python.org/3.6/library/socket.html?highlight=socket#socket.SOCK_DGRAM\" target=\"_blank\" rel=\"noopener\"><code>socket.SOCK_DGRAM</code></a></li>\n</ol>\n<p><code>tcpSock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</code></p>\n<p><a href=\"https://docs.python.org/3/library/socket.html?highlight=getservbyname#socket.socket.sendall\" target=\"_blank\" rel=\"noopener\"><code>socket.sendall(*bytes*[, *flags*])</code></a> 与 <a href=\"https://docs.python.org/3/library/socket.html?highlight=getservbyname#socket.socket.send\" target=\"_blank\" rel=\"noopener\"><code>socket.send(*bytes*[, *flags*])</code></a> 不同，此方法继续从字节发送数据，直到发送所有数据或发生错误。</p>\n<p><a href=\"https://docs.python.org/3/library/socket.html?highlight=getservbyname#socket.socket.send\" target=\"_blank\" rel=\"noopener\"><code>socket.send(*bytes*[, *flags*])</code></a> 返回发送的字节数。由应用程序负责检查所有数据是否已发送;</p>\n<p>TCP服务端和客户端示例**</p>\n<figure class=\"highlight python\"><figcaption><span>服务端 tsTserv3.py</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> socket <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"keyword\">from</span> time <span class=\"keyword\">import</span> ctime</span><br><span class=\"line\"></span><br><span class=\"line\">HOST = <span class=\"string\">''</span></span><br><span class=\"line\">PORT = <span class=\"number\">21567</span></span><br><span class=\"line\">BUFSIZ = <span class=\"number\">1024</span></span><br><span class=\"line\">ADDR = (HOST, PORT)</span><br><span class=\"line\"></span><br><span class=\"line\">tcpSerSock = socket(AF_INET, SOCK_STREAM)</span><br><span class=\"line\">tcpSerSock.bind(ADDR)</span><br><span class=\"line\">tcpSerSock.listen(<span class=\"number\">5</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span> <span class=\"keyword\">True</span>:</span><br><span class=\"line\">    print(<span class=\"string\">'waiting for connection...'</span>)</span><br><span class=\"line\">    tcpCliSock, addr = tcpSerSock.accept()</span><br><span class=\"line\">    print(<span class=\"string\">'...connected from:'</span>, addr)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"keyword\">True</span>:</span><br><span class=\"line\">        data = tcpCliSock.recv(BUFSIZ)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> data:</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">        <span class=\"comment\">#tcpCliSock.send('[%s] %s' % (bytes(ctime(), 'utf-8'), data))</span></span><br><span class=\"line\">        tcpCliSock.send(bytes(<span class=\"string\">'[%s] %s'</span> % (ctime(), data.decode(<span class=\"string\">'utf-8'</span>)), <span class=\"string\">'utf-8'</span>))</span><br><span class=\"line\">    </span><br><span class=\"line\">    tcpCliSock.close()</span><br><span class=\"line\">tcpSerSock.close()</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><figcaption><span>客户端 tsTclnt3.py</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> socket <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\">HOST = <span class=\"string\">'127.0.0.1'</span></span><br><span class=\"line\">PORT = <span class=\"number\">21567</span></span><br><span class=\"line\">BUFSIZ = <span class=\"number\">1024</span></span><br><span class=\"line\">ADDR = (HOST, PORT)</span><br><span class=\"line\"></span><br><span class=\"line\">tcpCliSock = socket(AF_INET, SOCK_STREAM)</span><br><span class=\"line\">tcpCliSock.connect(ADDR)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span> <span class=\"keyword\">True</span>:</span><br><span class=\"line\">    data = input(<span class=\"string\">'&gt; '</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> data:</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">    tcpCliSock.send(bytes(data, <span class=\"string\">'utf-8'</span>))</span><br><span class=\"line\">    data = tcpCliSock.recv(BUFSIZ)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> data:</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">    print(data.decode(<span class=\"string\">'utf-8'</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">tcpCliSock.close()</span><br></pre></td></tr></table></figure>\n<p><strong>执行 TCP 服务端和客户端</strong></p>\n<p>服务端输出如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">waiting for connection...</span><br><span class=\"line\">...connected from: (&apos;127.0.0.1&apos;, 57223)</span><br></pre></td></tr></table></figure>\n<p>客户端输入及输出如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; hi</span><br><span class=\"line\">[Mon May  7 20:05:26 2018] hi</span><br><span class=\"line\">&gt; spanish</span><br><span class=\"line\">[Mon May  7 20:05:33 2018] spanish</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"socketserver-网络服务框架\"><a href=\"#socketserver-网络服务框架\" class=\"headerlink\" title=\"socketserver - 网络服务框架\"></a><a href=\"https://docs.python.org/3.6/library/socketserver.html?highlight=socketserver#module-socketserver\" target=\"_blank\" rel=\"noopener\"><code>socketserver</code></a> - 网络服务框架</h4><p><strong><a href=\"https://docs.python.org/3.6/library/socketserver.html?highlight=socketserver#examples\" target=\"_blank\" rel=\"noopener\">Examples</a></strong></p>\n<h4 id=\"asyncore-asynchat-异步-socket-处理器\"><a href=\"#asyncore-asynchat-异步-socket-处理器\" class=\"headerlink\" title=\"asyncore / asynchat - 异步 socket 处理器\"></a><a href=\"https://docs.python.org/3.6/library/asyncore.html?highlight=asyncore#module-asyncore\" target=\"_blank\" rel=\"noopener\"><code>asyncore</code></a> / <a href=\"https://docs.python.org/3.6/library/asynchat.html#module-asynchat\" target=\"_blank\" rel=\"noopener\"><code>asynchat</code></a> - 异步 socket 处理器</h4><h4 id=\"select-selectors\"><a href=\"#select-selectors\" class=\"headerlink\" title=\"select / selectors\"></a><a href=\"https://docs.python.org/3.6/library/select.html?highlight=select#module-select\" target=\"_blank\" rel=\"noopener\"><code>select</code></a> / <a href=\"https://docs.python.org/3.6/library/selectors.html#module-selectors\" target=\"_blank\" rel=\"noopener\"><code>selectors</code></a></h4><blockquote>\n<p>Note that on Windows, it only works for sockets;</p>\n<p>The <a href=\"https://docs.python.org/3.6/library/selectors.html#module-selectors\" target=\"_blank\" rel=\"noopener\"><code>selectors</code></a> module allows high-level and efficient I/O multiplexing, built upon the<a href=\"https://docs.python.org/3.6/library/select.html?highlight=select#module-select\" target=\"_blank\" rel=\"noopener\"><code>select</code></a> module primitives. Users are encouraged to use the <a href=\"https://docs.python.org/3.6/library/selectors.html#module-selectors\" target=\"_blank\" rel=\"noopener\"><code>selectors</code></a> module instead</p>\n</blockquote>\n<h4 id=\"练习\"><a href=\"#练习\" class=\"headerlink\" title=\"练习\"></a>练习</h4><ol>\n<li>实现<code>Python</code>库参考文档中关于<code>socket</code>模块中TCP客户端/服务端程序示例。令其可以识别以下命令。<ol>\n<li><code>date</code> 服务器将返回其当前日期/时间戳，即 <code>time.ctime()</code></li>\n<li><code>os</code> 获取操作系统信息（<code>os.name</code>）</li>\n<li><code>ls</code> 列出当前目录文件清单（<code>os.listdir()</code>列出目录，<code>os.curdir</code>是当前目录）</li>\n</ol>\n</li>\n<li><code>Daytime</code>服务。使用<code>socket.getservbyname()</code>来确定使用UDP协议的<code>daytime</code>服务的端口号。</li>\n</ol>\n<h3 id=\"因特网客户端编程\"><a href=\"#因特网客户端编程\" class=\"headerlink\" title=\"因特网客户端编程\"></a>因特网客户端编程</h3><h4 id=\"http-—-HTTP-包\"><a href=\"#http-—-HTTP-包\" class=\"headerlink\" title=\"http — HTTP 包\"></a><a href=\"https://docs.python.org/3.5/library/http.html#module-http\" target=\"_blank\" rel=\"noopener\"><code>http</code></a> — HTTP 包</h4><blockquote>\n<p>Python3.0起，原 <code>httplib</code> 模块被并入 <code>http</code> 包中。</p>\n</blockquote>\n<ul>\n<li><a href=\"https://docs.python.org/3.5/library/http.client.html#module-http.client\" target=\"_blank\" rel=\"noopener\"><code>http.client</code></a> 低级 HTTP 协议客户端; 高级 HTTP 协议客户端使用 <a href=\"https://docs.python.org/3.5/library/urllib.request.html#module-urllib.request\" target=\"_blank\" rel=\"noopener\"><code>urllib.request</code></a></li>\n<li><a href=\"https://docs.python.org/3.5/library/http.server.html#module-http.server\" target=\"_blank\" rel=\"noopener\"><code>http.server</code></a> 基于 <a href=\"https://docs.python.org/3.5/library/socketserver.html#module-socketserver\" target=\"_blank\" rel=\"noopener\"><code>socketserver</code></a> 的基础 HTTP 服务端类</li>\n<li><a href=\"https://docs.python.org/3.5/library/http.cookies.html#module-http.cookies\" target=\"_blank\" rel=\"noopener\"><code>http.cookies</code></a> 使用cookie实施状态管理的实用程序</li>\n<li><a href=\"https://docs.python.org/3.5/library/http.cookiejar.html#module-http.cookiejar\" target=\"_blank\" rel=\"noopener\"><code>http.cookiejar</code></a> 提供cookie的持久性</li>\n</ul>\n<h4 id=\"ftplib-FTP-协议客户端\"><a href=\"#ftplib-FTP-协议客户端\" class=\"headerlink\" title=\"ftplib - FTP 协议客户端\"></a><a href=\"https://docs.python.org/3.6/library/ftplib.html?highlight=ftplib#module-ftplib\" target=\"_blank\" rel=\"noopener\"><code>ftplib</code></a> - FTP 协议客户端</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; from ftplib import FTP</span><br><span class=\"line\">&gt;&gt;&gt; ftp = FTP(&apos;ftp.debian.org&apos;)     # connect to host, default port</span><br><span class=\"line\">&gt;&gt;&gt; ftp.login()                     # user anonymous, passwd anonymous@</span><br><span class=\"line\">&apos;230 Login successful.&apos;</span><br><span class=\"line\">&gt;&gt;&gt; ftp.cwd(&apos;debian&apos;)               # change into &quot;debian&quot; directory</span><br><span class=\"line\">&gt;&gt;&gt; ftp.retrlines(&apos;LIST&apos;)           # list directory contents</span><br><span class=\"line\">-rw-rw-r--    1 1176     1176         1063 Jun 15 10:18 README</span><br><span class=\"line\">...</span><br><span class=\"line\">drwxr-sr-x    5 1176     1176         4096 Dec 19  2000 pool</span><br><span class=\"line\">drwxr-sr-x    4 1176     1176         4096 Nov 17  2008 project</span><br><span class=\"line\">drwxr-xr-x    3 1176     1176         4096 Oct 10  2012 tools</span><br><span class=\"line\">&apos;226 Directory send OK.&apos;</span><br><span class=\"line\">&gt;&gt;&gt; ftp.retrbinary(&apos;RETR README&apos;, open(&apos;README&apos;, &apos;wb&apos;).write)</span><br><span class=\"line\">&apos;226 Transfer complete.&apos;</span><br><span class=\"line\">&gt;&gt;&gt; ftp.quit()</span><br></pre></td></tr></table></figure>\n<blockquote><p>主动模式要求客户端和服务器端同时打开并且监听一个端口以创建连接。在这种情况下，客户端由于安装了防火墙会产生一些问题。所以，创立了被动模式。被动模式只要求服务器端产生一个监听相应端口的进程，这样就可以绕过客户端安装了防火墙的问题。</p>\n<footer><strong>主动和被动模式</strong><cite><a href=\"https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE#%E4%B8%BB%E5%8A%A8%E5%92%8C%E8%A2%AB%E5%8A%A8%E6%A8%A1%E5%BC%8F\" target=\"_blank\" rel=\"noopener\">文件传输协议</a></cite></footer></blockquote>\n<blockquote>\n<p>从 Python2.1开始，默认为<strong>被动模式</strong>。</p>\n</blockquote>\n<h4 id=\"nntplib-网络新闻传输协议\"><a href=\"#nntplib-网络新闻传输协议\" class=\"headerlink\" title=\"nntplib - 网络新闻传输协议\"></a><a href=\"https://docs.python.org/3.6/library/nntplib.html?highlight=nntp#module-nntplib\" target=\"_blank\" rel=\"noopener\"><code>nntplib</code></a> - <a href=\"https://zh.wikipedia.org/wiki/%E7%B6%B2%E8%B7%AF%E6%96%B0%E8%81%9E%E5%82%B3%E8%BC%B8%E5%8D%94%E5%AE%9A\" target=\"_blank\" rel=\"noopener\">网络新闻传输协议</a></h4><h4 id=\"smtplib-SMTP-协议客户端\"><a href=\"#smtplib-SMTP-协议客户端\" class=\"headerlink\" title=\"smtplib - SMTP 协议客户端\"></a><a href=\"https://docs.python.org/3.6/library/smtplib.html?highlight=smtplib#module-smtplib\" target=\"_blank\" rel=\"noopener\"><code>smtplib</code></a> - SMTP 协议客户端</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; from smtplib import SMTP</span><br><span class=\"line\">&gt;&gt;&gt; with SMTP(&quot;domain.org&quot;) as smtp:</span><br><span class=\"line\">...     smtp.noop()</span><br><span class=\"line\">...</span><br><span class=\"line\">(250, b&apos;Ok&apos;)</span><br><span class=\"line\">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>\n<p><strong><a href=\"https://docs.python.org/3.6/library/smtplib.html?highlight=smtplib#smtp-objects\" target=\"_blank\" rel=\"noopener\"><code>SMTP Objects</code></a></strong> <a href=\"https://docs.python.org/3.6/library/smtplib.html?highlight=smtplib#smtp-example\" target=\"_blank\" rel=\"noopener\">Example</a></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> smtplib</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">prompt</span><span class=\"params\">(prompt)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> input(prompt).strip()</span><br><span class=\"line\"></span><br><span class=\"line\">fromaddr = prompt(<span class=\"string\">\"From: \"</span>)</span><br><span class=\"line\">toaddrs  = prompt(<span class=\"string\">\"To: \"</span>).split()</span><br><span class=\"line\">print(<span class=\"string\">\"Enter message, end with ^D (Unix) or ^Z (Windows):\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Add the From: and To: headers at the start!</span></span><br><span class=\"line\">msg = (<span class=\"string\">\"From: %s\\r\\nTo: %s\\r\\n\\r\\n\"</span></span><br><span class=\"line\">       % (fromaddr, <span class=\"string\">\", \"</span>.join(toaddrs)))</span><br><span class=\"line\"><span class=\"keyword\">while</span> <span class=\"keyword\">True</span>:</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        line = input()</span><br><span class=\"line\">    <span class=\"keyword\">except</span> EOFError:</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> line:</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">    msg = msg + line</span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">\"Message length is\"</span>, len(msg))</span><br><span class=\"line\"></span><br><span class=\"line\">server = smtplib.SMTP(<span class=\"string\">'localhost'</span>)</span><br><span class=\"line\">server.set_debuglevel(<span class=\"number\">1</span>)</span><br><span class=\"line\">server.sendmail(fromaddr, toaddrs, msg)</span><br><span class=\"line\">server.quit()</span><br></pre></td></tr></table></figure>\n<h4 id=\"郵局協议（Post-Office-Protocol，简称-POP）\"><a href=\"#郵局協议（Post-Office-Protocol，简称-POP）\" class=\"headerlink\" title=\"郵局協议（Post Office Protocol，简称 POP）\"></a><a href=\"https://zh.wikipedia.org/wiki/%E9%83%B5%E5%B1%80%E5%8D%94%E5%AE%9A\" target=\"_blank\" rel=\"noopener\">郵局協议（Post Office Protocol，简称 POP）</a></h4><blockquote><p>POP支持离线邮件处理。其具体过程是：邮件发送到服务器上，电子邮件客户端调用邮件客户机程序以连接服务器，并下载所有未阅读的电子邮件。这种离线访问模式是一种存储转发服务，将邮件从邮件服务器端送到个人终端机器上，一般是PC机或MAC。一旦邮件发送到PC机或MAC上，邮件服务器上的邮件将会被删除。但目前的POP3邮件服务器大都可以“只下载邮件，服务器端并不删除”，也就是改进的POP3协议。</p>\n<footer><strong>邮局协议</strong><cite><a href=\"https://zh.wikipedia.org/wiki/%E9%83%B5%E5%B1%80%E5%8D%94%E5%AE%9A\" target=\"_blank\" rel=\"noopener\">zh.wikipedia.org/wiki/%E9%83%B5%E5%B1%80%E5%8D%94%E5%AE%9A</a></cite></footer></blockquote>\n<h5 id=\"poplib-POP3-协议客户端\"><a href=\"#poplib-POP3-协议客户端\" class=\"headerlink\" title=\"poplib - POP3 协议客户端\"></a><a href=\"https://docs.python.org/3.6/library/poplib.html?highlight=poplib#module-poplib\" target=\"_blank\" rel=\"noopener\"><code>poplib</code></a> - POP3 协议客户端</h5><p><a href=\"https://docs.python.org/3.6/library/poplib.html?highlight=poplib#pop3-objects\" target=\"_blank\" rel=\"noopener\"><code>POP3 Objects</code></a></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> getpass, poplib</span><br><span class=\"line\"></span><br><span class=\"line\">M = poplib.POP3(<span class=\"string\">'localhost'</span>)</span><br><span class=\"line\">M.user(getpass.getuser())</span><br><span class=\"line\">M.pass_(getpass.getpass())</span><br><span class=\"line\">numMessages = len(M.list()[<span class=\"number\">1</span>])</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(numMessages):</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> M.retr(i+<span class=\"number\">1</span>)[<span class=\"number\">1</span>]:</span><br><span class=\"line\">        print(j)</span><br></pre></td></tr></table></figure>\n<h4 id=\"因特网信息访问协议（缩写为-IMAP，以前称作-交互邮件访问协议）\"><a href=\"#因特网信息访问协议（缩写为-IMAP，以前称作-交互邮件访问协议）\" class=\"headerlink\" title=\"因特网信息访问协议（缩写为 IMAP，以前称作 交互邮件访问协议）\"></a><a href=\"https://zh.wikipedia.org/wiki/%E5%9B%A0%E7%89%B9%E7%BD%91%E4%BF%A1%E6%81%AF%E8%AE%BF%E9%97%AE%E5%8D%8F%E8%AE%AE\" target=\"_blank\" rel=\"noopener\">因特网信息访问协议（缩写为 IMAP，以前称作 交互邮件访问协议）</a></h4><blockquote><p>因特网信息访问协议（缩写为IMAP，以前称作交互邮件访问协议）是一个应用层协议，用来从本地邮件客户端（如Microsoft Outlook、Outlook Express、Foxmail、Mozilla Thunderbird）访问远程服务器上的邮件。</p>\n<p>IMAP和POP3（Post Office Protocol - Version 3，邮局协议第三版）是邮件访问最为普遍的Internet标准协议。事实上所有现代的邮件客户端和服务器都对两者给予支持。IMAP现在的版本是“IMAP第四版第一次修订版”（IMAP4rev1），在 RFC 3501 中定义。</p>\n<footer><strong>因特网信息访问协议</strong><cite><a href=\"https://zh.wikipedia.org/wiki/%E5%9B%A0%E7%89%B9%E7%BD%91%E4%BF%A1%E6%81%AF%E8%AE%BF%E9%97%AE%E5%8D%8F%E8%AE%AE\" target=\"_blank\" rel=\"noopener\">zh.wikipedia.org/wiki/%E5%9B%A0%E7%89%B9%E7%BD%91%E4%BF%A1%E6%81%AF%E8%AE%BF%E9%97%AE%E5%8D%8F%E8%AE%AE</a></cite></footer></blockquote>\n<h5 id=\"imaplib-—-IMAP4-协议客户端\"><a href=\"#imaplib-—-IMAP4-协议客户端\" class=\"headerlink\" title=\"imaplib — IMAP4 协议客户端\"></a><a href=\"https://docs.python.org/3.6/library/imaplib.html#module-imaplib\" target=\"_blank\" rel=\"noopener\"><code>imaplib</code></a> — IMAP4 协议客户端</h5><p><a href=\"https://docs.python.org/3.6/library/imaplib.html#imap4-objects\" target=\"_blank\" rel=\"noopener\"><code>IMAP4 Objects</code></a></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> getpass, imaplib</span><br><span class=\"line\"></span><br><span class=\"line\">M = imaplib.IMAP4()</span><br><span class=\"line\">M.login(getpass.getuser(), getpass.getpass())</span><br><span class=\"line\">M.select()</span><br><span class=\"line\">typ, data = M.search(<span class=\"keyword\">None</span>, <span class=\"string\">'ALL'</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> data[<span class=\"number\">0</span>].split():</span><br><span class=\"line\">    typ, data = M.fetch(num, <span class=\"string\">'(RFC822)'</span>)</span><br><span class=\"line\">    print(<span class=\"string\">'Message %s\\n%s\\n'</span> % (num, data[<span class=\"number\">0</span>][<span class=\"number\">1</span>]))</span><br><span class=\"line\">M.close()</span><br><span class=\"line\">M.logout()</span><br></pre></td></tr></table></figure>\n<h4 id=\"email-An-email-and-MIME-handling-package\"><a href=\"#email-An-email-and-MIME-handling-package\" class=\"headerlink\" title=\"email - An email and MIME handling package\"></a><a href=\"https://docs.python.org/3.6/library/email.html?highlight=email#module-email\" target=\"_blank\" rel=\"noopener\"><code>email</code></a> - An email and MIME handling package</h4><h4 id=\"smtpd-SMTP-服务端\"><a href=\"#smtpd-SMTP-服务端\" class=\"headerlink\" title=\"smtpd - SMTP 服务端\"></a><a href=\"https://docs.python.org/3.6/library/smtpd.html?highlight=smtpd#module-smtpd\" target=\"_blank\" rel=\"noopener\"><code>smtpd</code></a> - SMTP 服务端</h4><h4 id=\"base64-Base16-Base32-Base64-Base85-Data-Encodings\"><a href=\"#base64-Base16-Base32-Base64-Base85-Data-Encodings\" class=\"headerlink\" title=\"base64 - Base16, Base32, Base64, Base85 Data Encodings\"></a><a href=\"https://docs.python.org/3.6/library/base64.html?highlight=base64#module-base64\" target=\"_blank\" rel=\"noopener\"><code>base64</code></a> - Base16, Base32, Base64, Base85 Data Encodings</h4><h4 id=\"mimetypes-Map-filenames-to-MIME-types\"><a href=\"#mimetypes-Map-filenames-to-MIME-types\" class=\"headerlink\" title=\"mimetypes - Map filenames to MIME types\"></a><a href=\"https://docs.python.org/3.6/library/mimetypes.html?highlight=mimetypes#module-mimetypes\" target=\"_blank\" rel=\"noopener\"><code>mimetypes</code></a> - Map filenames to MIME types</h4><blockquote><p>互联网媒体类型（Internet media type，也称为MIME类型（MIME type）或内容类型（content type））是给互联网上传输的内容赋予的分类类型。一份内容的互联网媒体类型是由其文件格式与内容决定的。互联网媒体类型与文件拓展名相对应，因此计算机系统常常通过拓展名来确定一个文件的媒体类型并决定与其相关联的软件。互联网媒体类型的分类标准由互联网号码分配局（IANA）发布。1996年十一月，媒体类型在RFC 2045中被最初定义，当时仅被使用在SMTP协议的电子邮件中。现在其他的协议（比如HTTP或者SIP）也都常使用MIME类型。 一个MIME类型至少包括两个部分：一个类型（type）和一个子类型（subtype）。此外，它还可能包括一个或多个可选参数（optional parameter）。比如，HTML文件的互联网媒体类型可能是</p>\n<p>text/html; charset = UTF-8</p>\n<p>在这个例子中，文件类型为text，子类型为html，而charset是一个可选参数，其值为UTF-8。</p>\n<footer><strong>互联网媒体类型</strong><cite><a href=\"https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91%E5%AA%92%E4%BD%93%E7%B1%BB%E5%9E%8B\" target=\"_blank\" rel=\"noopener\">zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91%E5%AA%92%E4%BD%93%E7%B1%BB%E5%9E%8B</a></cite></footer></blockquote>\n<h4 id=\"binascii-Convert-between-binary-and-ASCII\"><a href=\"#binascii-Convert-between-binary-and-ASCII\" class=\"headerlink\" title=\"binascii - Convert between binary and ASCII\"></a><a href=\"https://docs.python.org/3.6/library/binascii.html?highlight=binascii#module-binascii\" target=\"_blank\" rel=\"noopener\"><code>binascii</code></a> - Convert between binary and ASCII</h4><h4 id=\"binhex-Encode-and-decode-binhex4-files\"><a href=\"#binhex-Encode-and-decode-binhex4-files\" class=\"headerlink\" title=\"binhex - Encode and decode binhex4 files\"></a><a href=\"https://docs.python.org/3.6/library/binhex.html?highlight=binhex#module-binhex\" target=\"_blank\" rel=\"noopener\"><code>binhex</code></a> - Encode and decode binhex4 files</h4><h4 id=\"quopri-Encode-and-decode-MIME-quoted-printable-data\"><a href=\"#quopri-Encode-and-decode-MIME-quoted-printable-data\" class=\"headerlink\" title=\"quopri - Encode and decode MIME quoted-printable data\"></a><a href=\"https://docs.python.org/3.6/library/quopri.html#module-quopri\" target=\"_blank\" rel=\"noopener\"><code>quopri</code></a> - Encode and decode MIME quoted-printable data</h4><h3 id=\"多线程编程\"><a href=\"#多线程编程\" class=\"headerlink\" title=\"多线程编程\"></a>多线程编程</h3><h4 id=\"thread-低级线程-API\"><a href=\"#thread-低级线程-API\" class=\"headerlink\" title=\"_thread - 低级线程 API\"></a><a href=\"https://docs.python.org/3.6/library/_thread.html#module-_thread\" target=\"_blank\" rel=\"noopener\"><code>_thread</code></a> - 低级线程 API</h4><h4 id=\"threading-基于-thread-的高级线程接口\"><a href=\"#threading-基于-thread-的高级线程接口\" class=\"headerlink\" title=\"threading - 基于 _thread 的高级线程接口\"></a><a href=\"https://docs.python.org/3.6/library/threading.html#module-threading\" target=\"_blank\" rel=\"noopener\"><code>threading</code></a> - 基于 <code>_thread</code> 的高级线程接口</h4><blockquote>\n<p><code>threading</code>模块支持守护线程(<a href=\"https://docs.python.org/3.6/library/threading.html?highlight=daemon#threading.Thread.daemon\" target=\"_blank\" rel=\"noopener\"><code>daemon</code></a> thread)，其工作方式是：守护线程一般是一个等待客户端请求服务的服务器。如果没有客户端请求，守护线程就是空闲的。如果把一个线程设置为守护线程，就表示这个线程是<strong>不重要的</strong>，进程退出时不需要等待这个线程执行完成。</p>\n<p>如果主线程准备退出时，不需要等待某些子线程完成，就可以为这些子线程设置守护线程标记。</p>\n</blockquote>\n<h5 id=\"创建-Thread-实例，传给它一个函数（多线程模式1）\"><a href=\"#创建-Thread-实例，传给它一个函数（多线程模式1）\" class=\"headerlink\" title=\"创建 Thread 实例，传给它一个函数（多线程模式1）\"></a>创建 Thread 实例，传给它一个函数（多线程模式1）</h5><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> threading</span><br><span class=\"line\"><span class=\"keyword\">from</span> time <span class=\"keyword\">import</span> sleep, ctime</span><br><span class=\"line\"></span><br><span class=\"line\">loops = [<span class=\"number\">4</span>, <span class=\"number\">2</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">loop</span><span class=\"params\">(nloop, nsec)</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">'start loop'</span>, nloop, <span class=\"string\">'at:'</span>, ctime())</span><br><span class=\"line\">    sleep(nsec)</span><br><span class=\"line\">    print(<span class=\"string\">'loop'</span>, nloop, <span class=\"string\">'done at:'</span>, ctime())</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">'starting at:'</span>, ctime())</span><br><span class=\"line\">    threads = []</span><br><span class=\"line\">    nloops = list(range(len(loops)))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> nloops:</span><br><span class=\"line\">        t = threading.Thread(target=loop,</span><br><span class=\"line\">                             args=(i, loops[i]))</span><br><span class=\"line\">        threads.append(t)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> nloops:  <span class=\"comment\"># start threads</span></span><br><span class=\"line\">        threads[i].start()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> nloops:  <span class=\"comment\"># wait for all</span></span><br><span class=\"line\">        threads[i].join()  <span class=\"comment\"># threads to finish</span></span><br><span class=\"line\"></span><br><span class=\"line\">    print(<span class=\"string\">'all DONE at:'</span>, ctime())</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    main()</span><br></pre></td></tr></table></figure>\n<p>当所有线程都被分配完毕后，通过调用每个线程的 <code>start()</code> 方法让它们开始执行，而不是在这之前就会执行。</p>\n<p><code>join()</code> 方法将等待线程结束，或者在提供了超时时间的情况下，达到超时时间。一旦线程启动，它们就会一直执行，知道给定的函数完成之后退出。如果主线程还有其他事情要做，而不是等待某些线程完成，就可以不调用 <code>join()</code> 。 <code>join()</code> 方法只有在需要等待线程完成的时候才是有用的。</p>\n<h5 id=\"创建-Thread-实例，传给它一个可调用的类的实例（多线程模式2）\"><a href=\"#创建-Thread-实例，传给它一个可调用的类的实例（多线程模式2）\" class=\"headerlink\" title=\"创建 Thread 实例，传给它一个可调用的类的实例（多线程模式2）\"></a>创建 Thread 实例，传给它一个可调用的类的实例（多线程模式2）</h5><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> threading</span><br><span class=\"line\"><span class=\"keyword\">from</span> time <span class=\"keyword\">import</span> sleep, ctime</span><br><span class=\"line\"></span><br><span class=\"line\">loops = [<span class=\"number\">4</span>, <span class=\"number\">2</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadFunc</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, func, args, name=<span class=\"string\">''</span>)</span>:</span></span><br><span class=\"line\">        self.name = name</span><br><span class=\"line\">        self.func = func</span><br><span class=\"line\">        self.args = args</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__call__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        self.func(*self.args)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">loop</span><span class=\"params\">(nloop, nsec)</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">'start loop'</span>, nloop, <span class=\"string\">'at:'</span>, ctime())</span><br><span class=\"line\">    sleep(nsec)</span><br><span class=\"line\">    print(<span class=\"string\">'loop'</span>, nloop, <span class=\"string\">'done at:'</span>, ctime())</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">'starting at:'</span>, ctime())</span><br><span class=\"line\">    threads = []</span><br><span class=\"line\">    nloops = range(len(loops))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> nloops:        <span class=\"comment\"># create all threads</span></span><br><span class=\"line\">        t = threading.Thread(</span><br><span class=\"line\">            target=ThreadFunc(loop, (i, loops[i]),</span><br><span class=\"line\">            loop.__name__))</span><br><span class=\"line\">        threads.append(t)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> nloops:        <span class=\"comment\"># start all threads</span></span><br><span class=\"line\">        threads[i].start()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> nloops:        <span class=\"comment\"># wait for completion</span></span><br><span class=\"line\">        threads[i].join()</span><br><span class=\"line\"></span><br><span class=\"line\">    print(<span class=\"string\">'all DONE at:'</span>, ctime())</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    main()</span><br></pre></td></tr></table></figure>\n<p>相对于上一个示例，本次主要是添加了<code>ThreadFunc</code>类，并在实例化<code>Thread</code>对象的同时实例化了可调用类<code>ThreadFunc</code>。</p>\n<p>当创建新线程时，<code>Thread</code>类的代码将调用<code>ThreadFunc</code>对象，对此会调用<code>__call__()</code>这个特殊方法。</p>\n<h5 id=\"派生-Thread-的子类，并创建子类的实例（多线程模式3-推荐方式）\"><a href=\"#派生-Thread-的子类，并创建子类的实例（多线程模式3-推荐方式）\" class=\"headerlink\" title=\"派生 Thread 的子类，并创建子类的实例（多线程模式3 - 推荐方式）\"></a>派生 <a href=\"https://docs.python.org/3/library/threading.html?highlight=threading%20thread#thread-objects\" target=\"_blank\" rel=\"noopener\">Thread</a> 的子类，并创建子类的实例（多线程模式3 - 推荐方式）</h5><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> threading</span><br><span class=\"line\"><span class=\"keyword\">from</span> time <span class=\"keyword\">import</span> sleep, ctime</span><br><span class=\"line\"></span><br><span class=\"line\">loops = [<span class=\"number\">4</span>, <span class=\"number\">2</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThread</span><span class=\"params\">(threading.Thread)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, func, args, name=<span class=\"string\">''</span>)</span>:</span></span><br><span class=\"line\">        threading.Thread.__init__(self, name=name)</span><br><span class=\"line\">        self.func = func</span><br><span class=\"line\">        self.args = args</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        self.func(*self.args)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">loop</span><span class=\"params\">(nloop, nsec)</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">'start loop'</span>, nloop, <span class=\"string\">'at:'</span>, ctime())</span><br><span class=\"line\">    sleep(nsec)</span><br><span class=\"line\">    print(<span class=\"string\">'loop'</span>, nloop, <span class=\"string\">'done at:'</span>, ctime())</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">'starting at:'</span>, ctime())</span><br><span class=\"line\">    threads = []</span><br><span class=\"line\">    nloops = range(len(loops))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> nloops:</span><br><span class=\"line\">        t = MyThread(loop, (i, loops[i]),</span><br><span class=\"line\">            loop.__name__)</span><br><span class=\"line\">        threads.append(t)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> nloops:</span><br><span class=\"line\">        threads[i].start()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> nloops:</span><br><span class=\"line\">        threads[i].join()</span><br><span class=\"line\"></span><br><span class=\"line\">    print(<span class=\"string\">'all DONE at:'</span>, ctime())</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    main()</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>对于多线程来说，相对推荐这个模式，只需要创建 <a href=\"https://docs.python.org/3/library/threading.html?highlight=threading%20thread#threading.Thread\" target=\"_blank\" rel=\"noopener\"><code>Thread</code></a> 的派生类，并重写 <code>__init__()</code> 及 <a href=\"https://docs.python.org/3/library/threading.html?highlight=threading%20thread#threading.Thread.run\" target=\"_blank\" rel=\"noopener\"><code>run()</code></a> 方法即可</p>\n</blockquote>\n<h4 id=\"多线程实践\"><a href=\"#多线程实践\" class=\"headerlink\" title=\"多线程实践\"></a>多线程实践</h4><h5 id=\"图书排名示例\"><a href=\"#图书排名示例\" class=\"headerlink\" title=\"图书排名示例\"></a>图书排名示例</h5><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> urllib.request</span><br><span class=\"line\"><span class=\"keyword\">from</span> atexit <span class=\"keyword\">import</span> register</span><br><span class=\"line\"><span class=\"keyword\">from</span> re <span class=\"keyword\">import</span> compile</span><br><span class=\"line\"><span class=\"keyword\">from</span> threading <span class=\"keyword\">import</span> Thread</span><br><span class=\"line\"><span class=\"keyword\">from</span> time <span class=\"keyword\">import</span> ctime</span><br><span class=\"line\"></span><br><span class=\"line\">REGEX = compile(<span class=\"string\">'#([\\d,]+) in Books '</span>)</span><br><span class=\"line\">AMZN = <span class=\"string\">'https://www.amazon.com/dp/'</span></span><br><span class=\"line\">ISBNs = &#123;</span><br><span class=\"line\">    <span class=\"string\">'0132269937'</span>: <span class=\"string\">'Core Python Programming'</span>,</span><br><span class=\"line\">    <span class=\"string\">'0132356139'</span>: <span class=\"string\">'Python Web Development with Django'</span>,</span><br><span class=\"line\">    <span class=\"string\">'0137143419'</span>: <span class=\"string\">'Python Fundamentals'</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getRanking</span><span class=\"params\">(isbn)</span>:</span></span><br><span class=\"line\">    opener = urllib.request.build_opener()</span><br><span class=\"line\">    opener.addheaders = [(<span class=\"string\">'User-agent'</span>, <span class=\"string\">'Mozilla/5.0 (X11; U; Linux i686) Gecko/20071127 Firefox/2.0.0.11'</span>)]</span><br><span class=\"line\">    o = opener.open(<span class=\"string\">'&#123;0&#125;&#123;1&#125;'</span>.format(AMZN, isbn))</span><br><span class=\"line\">    data = str(o.read(), <span class=\"string\">'utf-8'</span>)</span><br><span class=\"line\">    opener.close()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> REGEX.findall(data)[<span class=\"number\">0</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_showRanking</span><span class=\"params\">(isbn)</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">'- %r ranked %s'</span> % (</span><br><span class=\"line\">        ISBNs[isbn], getRanking(isbn)))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_main</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">'At'</span>, ctime(), <span class=\"string\">'on Amazon...'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> isbn <span class=\"keyword\">in</span> ISBNs:</span><br><span class=\"line\">        Thread(target=_showRanking, args=(isbn,)).start()  <span class=\"comment\"># _showRanking(isbn)</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@register</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_atexit</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">'all DONE at:'</span>, ctime())</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    _main()</span><br></pre></td></tr></table></figure>\n<blockquote><p><strong>竞争冒险</strong>（race hazard）又名<strong>竞态条件</strong>、<strong>竞争条件</strong>（race condition），它旨在描述一个系统或者进程的输出依赖于不受控制的事件出现顺序或者出现时机。此词源自于两个信号试着彼此竞争，来影响谁先输出。</p>\n<p>举例来说，如果计算机中的两个<a href=\"https://zh.wikipedia.org/wiki/%E8%BF%9B%E7%A8%8B\" target=\"_blank\" rel=\"noopener\">进程</a>同时试图修改一个共享内存的内容，在没有<a href=\"https://zh.wikipedia.org/wiki/%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6\" target=\"_blank\" rel=\"noopener\">并发控制</a>的情况下，最后的结果依赖于两个进程的执行顺序与时机。而且如果发生了并发访问冲突，则最后的结果是不正确的。</p>\n<p>竞争冒险常见于不良设计的电子系统，尤其是逻辑电路。但它们在<a href=\"https://zh.wikipedia.org/wiki/%E8%BB%9F%E9%AB%94\" target=\"_blank\" rel=\"noopener\">软件</a>中也比较常见，尤其是有采用<a href=\"https://zh.wikipedia.org/wiki/%E5%A4%9A%E7%BA%BF%E7%A8%8B\" target=\"_blank\" rel=\"noopener\">多线程</a>技术的软件。</p>\n<footer><strong>竞争冒险</strong><cite><a href=\"https://zh.wikipedia.org/wiki/%E7%AB%B6%E7%88%AD%E5%8D%B1%E5%AE%B3\" target=\"_blank\" rel=\"noopener\">zh.wikipedia.org/wiki/%E7%AB%B6%E7%88%AD%E5%8D%B1%E5%AE%B3</a></cite></footer></blockquote>\n<h5 id=\"Lock-Objects\"><a href=\"#Lock-Objects\" class=\"headerlink\" title=\"Lock Objects\"></a><a href=\"https://docs.python.org/3/library/threading.html?highlight=threading#lock-objects\" target=\"_blank\" rel=\"noopener\">Lock Objects</a></h5><p><strong>原始锁定是一种同步原语，在锁定时不属于特定线程</strong>。</p>\n<p><strong>当多个线程在<a href=\"https://docs.python.org/3/library/threading.html?highlight=threading#threading.Lock.acquire\" target=\"_blank\" rel=\"noopener\"><code>acquire()</code></a>等待状态转为解锁状态时被阻塞时，当一个<a href=\"https://docs.python.org/3/library/threading.html?highlight=threading#threading.Lock.release\" target=\"_blank\" rel=\"noopener\"><code>release()</code></a> 呼叫将状态重置为解锁状态时，只有一个线程继续进行; 哪一个等待的线程没有被定义，并且可能会因实现而有所不同。</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/env python</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> atexit <span class=\"keyword\">import</span> register</span><br><span class=\"line\"><span class=\"keyword\">from</span> random <span class=\"keyword\">import</span> randrange</span><br><span class=\"line\"><span class=\"keyword\">from</span> threading <span class=\"keyword\">import</span> Thread, Lock, currentThread</span><br><span class=\"line\"><span class=\"keyword\">from</span> time <span class=\"keyword\">import</span> sleep, ctime</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CleanOutputSet</span><span class=\"params\">(set)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__str__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">', '</span>.join(x <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> self)</span><br><span class=\"line\"></span><br><span class=\"line\">lock = Lock()</span><br><span class=\"line\">loops = (randrange(<span class=\"number\">2</span>, <span class=\"number\">5</span>) <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> range(randrange(<span class=\"number\">3</span>, <span class=\"number\">7</span>)))</span><br><span class=\"line\">remaining = CleanOutputSet()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">loop</span><span class=\"params\">(nsec)</span>:</span></span><br><span class=\"line\">    myname = currentThread().name</span><br><span class=\"line\">    lock.acquire()</span><br><span class=\"line\">    remaining.add(myname)</span><br><span class=\"line\">    print(<span class=\"string\">'[%s] Started %s'</span> % (ctime(), myname)) <span class=\"comment\">#print '[&#123;0&#125;] Started &#123;1&#125;'.format(ctime(), myname)</span></span><br><span class=\"line\">    lock.release()</span><br><span class=\"line\">    sleep(nsec)</span><br><span class=\"line\">    lock.acquire()</span><br><span class=\"line\">    remaining.remove(myname)</span><br><span class=\"line\">    print(<span class=\"string\">'[%s] Completed %s (%d secs)'</span> % ( <span class=\"comment\">#print '[&#123;0&#125;] Completed &#123;1&#125; (&#123;2&#125; secs)'.format(</span></span><br><span class=\"line\">        ctime(), myname, nsec))</span><br><span class=\"line\">    print(<span class=\"string\">'    (remaining: %s)'</span> % (remaining <span class=\"keyword\">or</span> <span class=\"string\">'NONE'</span>)) <span class=\"comment\">#print '    (remaining: &#123;0&#125;)'.format(remaining or 'NONE')</span></span><br><span class=\"line\">    lock.release()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_main</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> pause <span class=\"keyword\">in</span> loops:</span><br><span class=\"line\">        Thread(target=loop, args=(pause,)).start()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@register</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_atexit</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">'all DONE at:'</span>, ctime())</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    _main()</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">[Thu May 10 15:52:48 2018] Started Thread-1</span><br><span class=\"line\">[Thu May 10 15:52:48 2018] Started Thread-2</span><br><span class=\"line\">[Thu May 10 15:52:48 2018] Started Thread-3</span><br><span class=\"line\">[Thu May 10 15:52:48 2018] Started Thread-4</span><br><span class=\"line\">[Thu May 10 15:52:51 2018] Completed Thread-4 (3 secs)</span><br><span class=\"line\">    (remaining: Thread-1, Thread-3, Thread-2)</span><br><span class=\"line\">[Thu May 10 15:52:51 2018] Completed Thread-2 (3 secs)</span><br><span class=\"line\">    (remaining: Thread-1, Thread-3)</span><br><span class=\"line\">[Thu May 10 15:52:52 2018] Completed Thread-1 (4 secs)</span><br><span class=\"line\">    (remaining: Thread-3)</span><br><span class=\"line\">[Thu May 10 15:52:52 2018] Completed Thread-3 (4 secs)</span><br><span class=\"line\">    (remaining: NONE)</span><br><span class=\"line\">all DONE at: Thu May 10 15:52:52 2018</span><br></pre></td></tr></table></figure>\n<p>以上示例中由于 <code>sleep(nsec)</code> 的存在，才造成了输出后半部分不同线程的结束顺序不同。</p>\n<blockquote>\n<p>个人理解：Lock锁线程后会造成所有线程的阻塞和等待。</p>\n</blockquote>\n<h5 id=\"上下文管理器-with\"><a href=\"#上下文管理器-with\" class=\"headerlink\" title=\"上下文管理器 with\"></a>上下文管理器 <a href=\"https://docs.python.org/3/library/threading.html?highlight=threading#using-locks-conditions-and-semaphores-in-the-with-statement\" target=\"_blank\" rel=\"noopener\">with</a></h5><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">with</span> some_lock:</span><br><span class=\"line\">    <span class=\"comment\"># do something...</span></span><br></pre></td></tr></table></figure>\n<p>与以下代码是等价的</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">some_lock.acquire()</span><br><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    <span class=\"comment\"># do something...</span></span><br><span class=\"line\"><span class=\"keyword\">finally</span>:</span><br><span class=\"line\">    some_lock.release()</span><br></pre></td></tr></table></figure>\n<h4 id=\"信号量-Semaphore-Objects\"><a href=\"#信号量-Semaphore-Objects\" class=\"headerlink\" title=\"信号量(Semaphore Objects)\"></a>信号量(<a href=\"https://docs.python.org/3/library/threading.html?highlight=threading#semaphore-objects\" target=\"_blank\" rel=\"noopener\">Semaphore Objects</a>)</h4><p>一个信号量管理一个内部计数器，该计数器由每个 <a href=\"https://docs.python.org/3/library/threading.html?highlight=threading#threading.Semaphore.release\" target=\"_blank\" rel=\"noopener\"><code>release()</code></a>调用递减，并由每个<a href=\"https://docs.python.org/3/library/threading.html?highlight=threading#threading.Semaphore.release\" target=\"_blank\" rel=\"noopener\"><code>release()</code></a>调用递增。 柜台不能低于零; 当 <a href=\"https://docs.python.org/3/library/threading.html?highlight=threading#threading.Semaphore.release\" target=\"_blank\" rel=\"noopener\"><code>release()</code></a>发现它为零时，它会阻塞，等待其他线程调用<a href=\"https://docs.python.org/3/library/threading.html?highlight=threading#threading.Semaphore.release\" target=\"_blank\" rel=\"noopener\"><code>release()</code></a>。</p>\n<blockquote>\n<p>信号量通常用于保护容量有限的资源。如果资源的大小是固定的，就应该使用有界的信号量。</p>\n</blockquote>\n<p>主线程中定义信号量</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">maxconnections = <span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"comment\"># ...</span></span><br><span class=\"line\">pool_sema = BoundedSemaphore(value=maxconnections)</span><br></pre></td></tr></table></figure>\n<p>工作线程在需要连接到服务器时调用信号量的获取和释放方法：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">with</span> pool_sema:</span><br><span class=\"line\">    conn = connectdb()</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        <span class=\"comment\"># ... use connection ...</span></span><br><span class=\"line\">    <span class=\"keyword\">finally</span>:</span><br><span class=\"line\">        conn.close()</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> random</span><br><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"><span class=\"keyword\">from</span> atexit <span class=\"keyword\">import</span> register</span><br><span class=\"line\"><span class=\"keyword\">from</span> threading <span class=\"keyword\">import</span> Thread, currentThread, BoundedSemaphore</span><br><span class=\"line\"></span><br><span class=\"line\">MAX = <span class=\"number\">2</span></span><br><span class=\"line\">_sem = BoundedSemaphore(MAX)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">op</span><span class=\"params\">(index)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">with</span> _sem:</span><br><span class=\"line\">        threadName = currentThread().name</span><br><span class=\"line\">        print(<span class=\"string\">'&#123;1&#125; thread &#123;0&#125; 开始执行.'</span>.format(threadName, time.ctime()))</span><br><span class=\"line\">        sec = random.randint(<span class=\"number\">1</span>, <span class=\"number\">10</span>)</span><br><span class=\"line\">        time.sleep(sec)</span><br><span class=\"line\">        print(<span class=\"string\">'&#123;1&#125; thread &#123;0&#125; 开始完成.'</span>.format(threadName, time.ctime()))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@register</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_atexit</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">'all DONE'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_main</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">5</span>):</span><br><span class=\"line\">        Thread(target=op, args=(str(i),)).start()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    _main()</span><br></pre></td></tr></table></figure>\n<p>输出内容如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Thu May 10 16:14:10 2018 thread Thread-1 开始执行.</span><br><span class=\"line\">Thu May 10 16:14:10 2018 thread Thread-2 开始执行.</span><br><span class=\"line\">Thu May 10 16:14:15 2018 thread Thread-1 开始完成.</span><br><span class=\"line\">Thu May 10 16:14:15 2018 thread Thread-3 开始执行.</span><br><span class=\"line\">Thu May 10 16:14:20 2018 thread Thread-2 开始完成.</span><br><span class=\"line\">Thu May 10 16:14:20 2018 thread Thread-4 开始执行.</span><br><span class=\"line\">Thu May 10 16:14:21 2018 thread Thread-3 开始完成.</span><br><span class=\"line\">Thu May 10 16:14:21 2018 thread Thread-5 开始执行.</span><br><span class=\"line\">Thu May 10 16:14:28 2018 thread Thread-5 开始完成.</span><br><span class=\"line\">Thu May 10 16:14:29 2018 thread Thread-4 开始完成.</span><br><span class=\"line\">all DONE</span><br></pre></td></tr></table></figure>\n<p>可以看到，开始执行时，最多只执行了 2 个线程，其他线程都在等待。当某一线程执行完成后，剩余线程中的一条开始执行。</p>\n<h4 id=\"同步队列-queue-—-A-synchronized-queue-class\"><a href=\"#同步队列-queue-—-A-synchronized-queue-class\" class=\"headerlink\" title=\"同步队列 - queue — A synchronized queue class\"></a>同步队列 - <a href=\"https://docs.python.org/3/library/queue.html?highlight=queue#module-queue\" target=\"_blank\" rel=\"noopener\"><code>queue</code></a> — A synchronized queue class</h4><p>在多线程之间进行数据交换的利器。</p>\n<p><a href=\"https://docs.python.org/3/library/queue.html?highlight=queue#queue.Queue\" target=\"_blank\" rel=\"noopener\"><code>queue.Queue(*maxsize=0*)</code></a> 创建一个<strong>先入先出</strong>的队列。</p>\n<p><a href=\"\"><code>queue.LifoQueue(maxsize=0)</code></a> 创建一个<strong>后入先出</strong>的队列。</p>\n<p><a href=\"https://docs.python.org/3/library/queue.html?highlight=queue#queue.PriorityQueue\" target=\"_blank\" rel=\"noopener\"><code>queue.PriorityQueue(maxsize=0)</code></a> 创建一个<a href=\"https://zh.wikipedia.org/wiki/%E5%84%AA%E5%85%88%E4%BD%87%E5%88%97\" target=\"_blank\" rel=\"noopener\"><strong>优先队列</strong></a>。</p>\n<blockquote>\n<p><code>maxsize</code>是一个整数，用于设置可以放入队列中的项目数的上限。一旦达到此大小，插入将会阻塞，直到消耗队列项目。如果<code>maxsize</code>小于或等于零，则队列大小是无限的。</p>\n</blockquote>\n<h4 id=\"多进程\"><a href=\"#多进程\" class=\"headerlink\" title=\"多进程\"></a>多进程</h4><p>由于 Python 的 GIL 的限制，多线程更适合于 I/O 密集型应用（I/O释放了GIL，可以允许更多的并发），而不是计算密集型应用。对于计算密集型应用，为了实现更好的并行性，需要使用<strong>多进程</strong>，以便让CPU的其他内核来执行。</p>\n<h5 id=\"subprocess-子进程管理\"><a href=\"#subprocess-子进程管理\" class=\"headerlink\" title=\"subprocess - 子进程管理\"></a><a href=\"https://docs.python.org/3/library/subprocess.html?highlight=subprocess#module-subprocess\" target=\"_blank\" rel=\"noopener\"><code>subprocess</code></a> - 子进程管理</h5><h5 id=\"multiprocessing-并行进程，该模块允许程序员充分利用给定机器上的多个处理器。\"><a href=\"#multiprocessing-并行进程，该模块允许程序员充分利用给定机器上的多个处理器。\" class=\"headerlink\" title=\"multiprocessing - 并行进程，该模块允许程序员充分利用给定机器上的多个处理器。\"></a><a href=\"https://docs.python.org/3/library/multiprocessing.html?highlight=multiprocess#module-multiprocessing\" target=\"_blank\" rel=\"noopener\"><code>multiprocessing</code></a> - 并行进程，该模块允许程序员充分利用给定机器上的多个处理器。</h5><h5 id=\"concurrent-futures-启动并行任务\"><a href=\"#concurrent-futures-启动并行任务\" class=\"headerlink\" title=\"concurrent.futures - 启动并行任务\"></a><a href=\"https://docs.python.org/3/library/concurrent.futures.html?highlight=concurrent%20futures#module-concurrent.futures\" target=\"_blank\" rel=\"noopener\"><code>concurrent.futures</code></a> - 启动并行任务</h5><p>Python 3.2 开始提供的一个高级库。可以让开发者不在过分关注同步和线程/进程的管理。</p>\n<p>只需要指定线程池/进程池的最大工作数量，提交任务，然后整理结果即可。</p>\n<h6 id=\"ThreadPoolExecutor-支持异步调用的线程池\"><a href=\"#ThreadPoolExecutor-支持异步调用的线程池\" class=\"headerlink\" title=\"ThreadPoolExecutor - 支持异步调用的线程池\"></a><a href=\"https://docs.python.org/3/library/concurrent.futures.html?highlight=concurrent%20futures#concurrent.futures.ThreadPoolExecutor\" target=\"_blank\" rel=\"noopener\"><code>ThreadPoolExecutor</code></a> - 支持异步调用的线程池</h6><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> concurrent.futures</span><br><span class=\"line\"><span class=\"keyword\">import</span> urllib.request</span><br><span class=\"line\"></span><br><span class=\"line\">URLS = [<span class=\"string\">'http://www.foxnews.com/'</span>,</span><br><span class=\"line\">        <span class=\"string\">'http://www.cnn.com/'</span>,</span><br><span class=\"line\">        <span class=\"string\">'http://europe.wsj.com/'</span>,</span><br><span class=\"line\">        <span class=\"string\">'http://www.bbc.co.uk/'</span>,</span><br><span class=\"line\">        <span class=\"string\">'http://some-made-up-domain.com/'</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Retrieve a single page and report the URL and contents</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">load_url</span><span class=\"params\">(url, timeout)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">with</span> urllib.request.urlopen(url, timeout=timeout) <span class=\"keyword\">as</span> conn:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> conn.read()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># We can use a with statement to ensure threads are cleaned up promptly</span></span><br><span class=\"line\"><span class=\"keyword\">with</span> concurrent.futures.ThreadPoolExecutor(max_workers=<span class=\"number\">5</span>) <span class=\"keyword\">as</span> executor:</span><br><span class=\"line\">    <span class=\"comment\"># Start the load operations and mark each future with its URL</span></span><br><span class=\"line\">    future_to_url = &#123;executor.submit(load_url, url, <span class=\"number\">60</span>): url <span class=\"keyword\">for</span> url <span class=\"keyword\">in</span> URLS&#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> future <span class=\"keyword\">in</span> concurrent.futures.as_completed(future_to_url):</span><br><span class=\"line\">        url = future_to_url[future]</span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            data = future.result()</span><br><span class=\"line\">        <span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> exc:</span><br><span class=\"line\">            print(<span class=\"string\">'%r generated an exception: %s'</span> % (url, exc))</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            print(<span class=\"string\">'%r page is %d bytes'</span> % (url, len(data)))</span><br></pre></td></tr></table></figure>\n<h6 id=\"ProcessPoolExecutor-支持异步调用的进程池\"><a href=\"#ProcessPoolExecutor-支持异步调用的进程池\" class=\"headerlink\" title=\"ProcessPoolExecutor - 支持异步调用的进程池\"></a><a href=\"https://docs.python.org/3/library/concurrent.futures.html?highlight=concurrent%20futures#concurrent.futures.ProcessPoolExecutor\" target=\"_blank\" rel=\"noopener\"><code>ProcessPoolExecutor</code></a> - 支持异步调用的进程池</h6><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> concurrent.futures</span><br><span class=\"line\"><span class=\"keyword\">import</span> math</span><br><span class=\"line\"></span><br><span class=\"line\">PRIMES = [</span><br><span class=\"line\">    <span class=\"number\">112272535095293</span>,</span><br><span class=\"line\">    <span class=\"number\">112582705942171</span>,</span><br><span class=\"line\">    <span class=\"number\">112272535095293</span>,</span><br><span class=\"line\">    <span class=\"number\">115280095190773</span>,</span><br><span class=\"line\">    <span class=\"number\">115797848077099</span>,</span><br><span class=\"line\">    <span class=\"number\">1099726899285419</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">is_prime</span><span class=\"params\">(n)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> n % <span class=\"number\">2</span> == <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\"></span><br><span class=\"line\">    sqrt_n = int(math.floor(math.sqrt(n)))</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">3</span>, sqrt_n + <span class=\"number\">1</span>, <span class=\"number\">2</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n % i == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">with</span> concurrent.futures.ProcessPoolExecutor() <span class=\"keyword\">as</span> executor:</span><br><span class=\"line\">        <span class=\"keyword\">for</span> number, prime <span class=\"keyword\">in</span> zip(PRIMES, executor.map(is_prime, PRIMES)):</span><br><span class=\"line\">            print(<span class=\"string\">'%d is prime: %s'</span> % (number, prime))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    main()</span><br></pre></td></tr></table></figure>\n<h4 id=\"练习-1\"><a href=\"#练习-1\" class=\"headerlink\" title=\"练习\"></a>练习</h4><ol>\n<li><p>线程和文件。</p>\n<ol>\n<li>创建一个函数，给出一个字节值和一个文件名，然后显示文件中该字节出现的次数。</li>\n<li>假设输入的文件非常大。该文件允许有多个读者，现在请修改你的解决方案，创建多个线程，使每个线程负责文件某一部分的计数。然后将每个线程的数据进行整合，提供正确的总数。使用 <code>timeit</code> 模块对单线程和多线程方案进行计时。</li>\n</ol>\n<p>EXP：对于此类问题，由于并不是I/O密集型操作（单一文本只读取一次的情况下）。由于多线程需要对文本进行分拆，并且多线程之间的锁定和解锁操作等多余操作，会造成采用多线程的性能会低于单一线程性能。</p>\n</li>\n<li><p>线程、文件和正则表达式。有一个非常大的邮件文件；如果没有（把所有的邮件合并到一个文本文件中）。任务是，使用正则表达式用于识别email地址和web站点的URL。并将其转换为链接形式保存到.html新文件中，当时用Web浏览器打开该文件时，这些链接应该是可以单击的。使用线程对这个大文本文件的转换过程进行分割，最后整合所有结果到一个新的.html文件中。</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h3><h4 id=\"re-—-Regular-expression-operations\"><a href=\"#re-—-Regular-expression-operations\" class=\"headerlink\" title=\"re — Regular expression operations\"></a><a href=\"https://docs.python.org/3.5/library/re.html?highlight=re#module-re\" target=\"_blank\" rel=\"noopener\"><code>re</code></a> — Regular expression operations</h4><blockquote>\n<p> <a href=\"https://docs.python.org/3.6/library/re.html?highlight=re#re.compile\" target=\"_blank\" rel=\"noopener\"><code>re.compile</code></a> 为正则表达式提供了预编译功能。如果程序在执行过程中需要多次调用到正则表达式对象，那么采用预编译可以提升执行性能。</p>\n</blockquote>\n<p>If you want to locate a match anywhere in <em>string</em>, use <a href=\"https://docs.python.org/3.6/library/re.html?highlight=re#re.regex.search\" target=\"_blank\" rel=\"noopener\"><code>search()</code></a> instead (see also <a href=\"https://docs.python.org/3.6/library/re.html?highlight=re#search-vs-match\" target=\"_blank\" rel=\"noopener\">search() vs. match()</a>).</p>\n<h3 id=\"网络编程\"><a href=\"#网络编程\" class=\"headerlink\" title=\"网络编程\"></a>网络编程</h3><h4 id=\"socket-低级网络接口\"><a href=\"#socket-低级网络接口\" class=\"headerlink\" title=\"socket - 低级网络接口\"></a><a href=\"https://docs.python.org/3.6/library/socket.html?highlight=socket#module-socket\" target=\"_blank\" rel=\"noopener\">socket</a> - 低级网络接口</h4><ol>\n<li>基于文件的 Socket：<a href=\"https://docs.python.org/3.6/library/socket.html?highlight=socket#socket.AF_UNIX\" target=\"_blank\" rel=\"noopener\"><code>socket.AF_UNIX</code></a></li>\n<li>基于网络的 Socket：<a href=\"https://docs.python.org/3.6/library/socket.html?highlight=socket#socket.AF_INET\" target=\"_blank\" rel=\"noopener\"><code>socket.AF_INET</code></a></li>\n</ol>\n<ol>\n<li>有链接的Socket(<strong>TCP</strong>)：<a href=\"https://docs.python.org/3.6/library/socket.html?highlight=socket#socket.SOCK_STREAM\" target=\"_blank\" rel=\"noopener\"><code>socket.SOCK_STREAM</code></a></li>\n<li>无链接的Socket(<strong>UDP</strong>)：<a href=\"https://docs.python.org/3.6/library/socket.html?highlight=socket#socket.SOCK_DGRAM\" target=\"_blank\" rel=\"noopener\"><code>socket.SOCK_DGRAM</code></a></li>\n</ol>\n<p><code>tcpSock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</code></p>\n<p><a href=\"https://docs.python.org/3/library/socket.html?highlight=getservbyname#socket.socket.sendall\" target=\"_blank\" rel=\"noopener\"><code>socket.sendall(*bytes*[, *flags*])</code></a> 与 <a href=\"https://docs.python.org/3/library/socket.html?highlight=getservbyname#socket.socket.send\" target=\"_blank\" rel=\"noopener\"><code>socket.send(*bytes*[, *flags*])</code></a> 不同，此方法继续从字节发送数据，直到发送所有数据或发生错误。</p>\n<p><a href=\"https://docs.python.org/3/library/socket.html?highlight=getservbyname#socket.socket.send\" target=\"_blank\" rel=\"noopener\"><code>socket.send(*bytes*[, *flags*])</code></a> 返回发送的字节数。由应用程序负责检查所有数据是否已发送;</p>\n<p>TCP服务端和客户端示例**</p>\n<figure class=\"highlight python\"><figcaption><span>服务端 tsTserv3.py</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> socket <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"keyword\">from</span> time <span class=\"keyword\">import</span> ctime</span><br><span class=\"line\"></span><br><span class=\"line\">HOST = <span class=\"string\">''</span></span><br><span class=\"line\">PORT = <span class=\"number\">21567</span></span><br><span class=\"line\">BUFSIZ = <span class=\"number\">1024</span></span><br><span class=\"line\">ADDR = (HOST, PORT)</span><br><span class=\"line\"></span><br><span class=\"line\">tcpSerSock = socket(AF_INET, SOCK_STREAM)</span><br><span class=\"line\">tcpSerSock.bind(ADDR)</span><br><span class=\"line\">tcpSerSock.listen(<span class=\"number\">5</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span> <span class=\"keyword\">True</span>:</span><br><span class=\"line\">    print(<span class=\"string\">'waiting for connection...'</span>)</span><br><span class=\"line\">    tcpCliSock, addr = tcpSerSock.accept()</span><br><span class=\"line\">    print(<span class=\"string\">'...connected from:'</span>, addr)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"keyword\">True</span>:</span><br><span class=\"line\">        data = tcpCliSock.recv(BUFSIZ)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> data:</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">        <span class=\"comment\">#tcpCliSock.send('[%s] %s' % (bytes(ctime(), 'utf-8'), data))</span></span><br><span class=\"line\">        tcpCliSock.send(bytes(<span class=\"string\">'[%s] %s'</span> % (ctime(), data.decode(<span class=\"string\">'utf-8'</span>)), <span class=\"string\">'utf-8'</span>))</span><br><span class=\"line\">    </span><br><span class=\"line\">    tcpCliSock.close()</span><br><span class=\"line\">tcpSerSock.close()</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><figcaption><span>客户端 tsTclnt3.py</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> socket <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\">HOST = <span class=\"string\">'127.0.0.1'</span></span><br><span class=\"line\">PORT = <span class=\"number\">21567</span></span><br><span class=\"line\">BUFSIZ = <span class=\"number\">1024</span></span><br><span class=\"line\">ADDR = (HOST, PORT)</span><br><span class=\"line\"></span><br><span class=\"line\">tcpCliSock = socket(AF_INET, SOCK_STREAM)</span><br><span class=\"line\">tcpCliSock.connect(ADDR)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span> <span class=\"keyword\">True</span>:</span><br><span class=\"line\">    data = input(<span class=\"string\">'&gt; '</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> data:</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">    tcpCliSock.send(bytes(data, <span class=\"string\">'utf-8'</span>))</span><br><span class=\"line\">    data = tcpCliSock.recv(BUFSIZ)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> data:</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">    print(data.decode(<span class=\"string\">'utf-8'</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">tcpCliSock.close()</span><br></pre></td></tr></table></figure>\n<p><strong>执行 TCP 服务端和客户端</strong></p>\n<p>服务端输出如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">waiting for connection...</span><br><span class=\"line\">...connected from: (&apos;127.0.0.1&apos;, 57223)</span><br></pre></td></tr></table></figure>\n<p>客户端输入及输出如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; hi</span><br><span class=\"line\">[Mon May  7 20:05:26 2018] hi</span><br><span class=\"line\">&gt; spanish</span><br><span class=\"line\">[Mon May  7 20:05:33 2018] spanish</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"socketserver-网络服务框架\"><a href=\"#socketserver-网络服务框架\" class=\"headerlink\" title=\"socketserver - 网络服务框架\"></a><a href=\"https://docs.python.org/3.6/library/socketserver.html?highlight=socketserver#module-socketserver\" target=\"_blank\" rel=\"noopener\"><code>socketserver</code></a> - 网络服务框架</h4><p><strong><a href=\"https://docs.python.org/3.6/library/socketserver.html?highlight=socketserver#examples\" target=\"_blank\" rel=\"noopener\">Examples</a></strong></p>\n<h4 id=\"asyncore-asynchat-异步-socket-处理器\"><a href=\"#asyncore-asynchat-异步-socket-处理器\" class=\"headerlink\" title=\"asyncore / asynchat - 异步 socket 处理器\"></a><a href=\"https://docs.python.org/3.6/library/asyncore.html?highlight=asyncore#module-asyncore\" target=\"_blank\" rel=\"noopener\"><code>asyncore</code></a> / <a href=\"https://docs.python.org/3.6/library/asynchat.html#module-asynchat\" target=\"_blank\" rel=\"noopener\"><code>asynchat</code></a> - 异步 socket 处理器</h4><h4 id=\"select-selectors\"><a href=\"#select-selectors\" class=\"headerlink\" title=\"select / selectors\"></a><a href=\"https://docs.python.org/3.6/library/select.html?highlight=select#module-select\" target=\"_blank\" rel=\"noopener\"><code>select</code></a> / <a href=\"https://docs.python.org/3.6/library/selectors.html#module-selectors\" target=\"_blank\" rel=\"noopener\"><code>selectors</code></a></h4><blockquote>\n<p>Note that on Windows, it only works for sockets;</p>\n<p>The <a href=\"https://docs.python.org/3.6/library/selectors.html#module-selectors\" target=\"_blank\" rel=\"noopener\"><code>selectors</code></a> module allows high-level and efficient I/O multiplexing, built upon the<a href=\"https://docs.python.org/3.6/library/select.html?highlight=select#module-select\" target=\"_blank\" rel=\"noopener\"><code>select</code></a> module primitives. Users are encouraged to use the <a href=\"https://docs.python.org/3.6/library/selectors.html#module-selectors\" target=\"_blank\" rel=\"noopener\"><code>selectors</code></a> module instead</p>\n</blockquote>\n<h4 id=\"练习\"><a href=\"#练习\" class=\"headerlink\" title=\"练习\"></a>练习</h4><ol>\n<li>实现<code>Python</code>库参考文档中关于<code>socket</code>模块中TCP客户端/服务端程序示例。令其可以识别以下命令。<ol>\n<li><code>date</code> 服务器将返回其当前日期/时间戳，即 <code>time.ctime()</code></li>\n<li><code>os</code> 获取操作系统信息（<code>os.name</code>）</li>\n<li><code>ls</code> 列出当前目录文件清单（<code>os.listdir()</code>列出目录，<code>os.curdir</code>是当前目录）</li>\n</ol>\n</li>\n<li><code>Daytime</code>服务。使用<code>socket.getservbyname()</code>来确定使用UDP协议的<code>daytime</code>服务的端口号。</li>\n</ol>\n<h3 id=\"因特网客户端编程\"><a href=\"#因特网客户端编程\" class=\"headerlink\" title=\"因特网客户端编程\"></a>因特网客户端编程</h3><h4 id=\"http-—-HTTP-包\"><a href=\"#http-—-HTTP-包\" class=\"headerlink\" title=\"http — HTTP 包\"></a><a href=\"https://docs.python.org/3.5/library/http.html#module-http\" target=\"_blank\" rel=\"noopener\"><code>http</code></a> — HTTP 包</h4><blockquote>\n<p>Python3.0起，原 <code>httplib</code> 模块被并入 <code>http</code> 包中。</p>\n</blockquote>\n<ul>\n<li><a href=\"https://docs.python.org/3.5/library/http.client.html#module-http.client\" target=\"_blank\" rel=\"noopener\"><code>http.client</code></a> 低级 HTTP 协议客户端; 高级 HTTP 协议客户端使用 <a href=\"https://docs.python.org/3.5/library/urllib.request.html#module-urllib.request\" target=\"_blank\" rel=\"noopener\"><code>urllib.request</code></a></li>\n<li><a href=\"https://docs.python.org/3.5/library/http.server.html#module-http.server\" target=\"_blank\" rel=\"noopener\"><code>http.server</code></a> 基于 <a href=\"https://docs.python.org/3.5/library/socketserver.html#module-socketserver\" target=\"_blank\" rel=\"noopener\"><code>socketserver</code></a> 的基础 HTTP 服务端类</li>\n<li><a href=\"https://docs.python.org/3.5/library/http.cookies.html#module-http.cookies\" target=\"_blank\" rel=\"noopener\"><code>http.cookies</code></a> 使用cookie实施状态管理的实用程序</li>\n<li><a href=\"https://docs.python.org/3.5/library/http.cookiejar.html#module-http.cookiejar\" target=\"_blank\" rel=\"noopener\"><code>http.cookiejar</code></a> 提供cookie的持久性</li>\n</ul>\n<h4 id=\"ftplib-FTP-协议客户端\"><a href=\"#ftplib-FTP-协议客户端\" class=\"headerlink\" title=\"ftplib - FTP 协议客户端\"></a><a href=\"https://docs.python.org/3.6/library/ftplib.html?highlight=ftplib#module-ftplib\" target=\"_blank\" rel=\"noopener\"><code>ftplib</code></a> - FTP 协议客户端</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; from ftplib import FTP</span><br><span class=\"line\">&gt;&gt;&gt; ftp = FTP(&apos;ftp.debian.org&apos;)     # connect to host, default port</span><br><span class=\"line\">&gt;&gt;&gt; ftp.login()                     # user anonymous, passwd anonymous@</span><br><span class=\"line\">&apos;230 Login successful.&apos;</span><br><span class=\"line\">&gt;&gt;&gt; ftp.cwd(&apos;debian&apos;)               # change into &quot;debian&quot; directory</span><br><span class=\"line\">&gt;&gt;&gt; ftp.retrlines(&apos;LIST&apos;)           # list directory contents</span><br><span class=\"line\">-rw-rw-r--    1 1176     1176         1063 Jun 15 10:18 README</span><br><span class=\"line\">...</span><br><span class=\"line\">drwxr-sr-x    5 1176     1176         4096 Dec 19  2000 pool</span><br><span class=\"line\">drwxr-sr-x    4 1176     1176         4096 Nov 17  2008 project</span><br><span class=\"line\">drwxr-xr-x    3 1176     1176         4096 Oct 10  2012 tools</span><br><span class=\"line\">&apos;226 Directory send OK.&apos;</span><br><span class=\"line\">&gt;&gt;&gt; ftp.retrbinary(&apos;RETR README&apos;, open(&apos;README&apos;, &apos;wb&apos;).write)</span><br><span class=\"line\">&apos;226 Transfer complete.&apos;</span><br><span class=\"line\">&gt;&gt;&gt; ftp.quit()</span><br></pre></td></tr></table></figure>\n<blockquote><p>主动模式要求客户端和服务器端同时打开并且监听一个端口以创建连接。在这种情况下，客户端由于安装了防火墙会产生一些问题。所以，创立了被动模式。被动模式只要求服务器端产生一个监听相应端口的进程，这样就可以绕过客户端安装了防火墙的问题。</p>\n<footer><strong>主动和被动模式</strong><cite><a href=\"https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE#%E4%B8%BB%E5%8A%A8%E5%92%8C%E8%A2%AB%E5%8A%A8%E6%A8%A1%E5%BC%8F\" target=\"_blank\" rel=\"noopener\">文件传输协议</a></cite></footer></blockquote>\n<blockquote>\n<p>从 Python2.1开始，默认为<strong>被动模式</strong>。</p>\n</blockquote>\n<h4 id=\"nntplib-网络新闻传输协议\"><a href=\"#nntplib-网络新闻传输协议\" class=\"headerlink\" title=\"nntplib - 网络新闻传输协议\"></a><a href=\"https://docs.python.org/3.6/library/nntplib.html?highlight=nntp#module-nntplib\" target=\"_blank\" rel=\"noopener\"><code>nntplib</code></a> - <a href=\"https://zh.wikipedia.org/wiki/%E7%B6%B2%E8%B7%AF%E6%96%B0%E8%81%9E%E5%82%B3%E8%BC%B8%E5%8D%94%E5%AE%9A\" target=\"_blank\" rel=\"noopener\">网络新闻传输协议</a></h4><h4 id=\"smtplib-SMTP-协议客户端\"><a href=\"#smtplib-SMTP-协议客户端\" class=\"headerlink\" title=\"smtplib - SMTP 协议客户端\"></a><a href=\"https://docs.python.org/3.6/library/smtplib.html?highlight=smtplib#module-smtplib\" target=\"_blank\" rel=\"noopener\"><code>smtplib</code></a> - SMTP 协议客户端</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; from smtplib import SMTP</span><br><span class=\"line\">&gt;&gt;&gt; with SMTP(&quot;domain.org&quot;) as smtp:</span><br><span class=\"line\">...     smtp.noop()</span><br><span class=\"line\">...</span><br><span class=\"line\">(250, b&apos;Ok&apos;)</span><br><span class=\"line\">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>\n<p><strong><a href=\"https://docs.python.org/3.6/library/smtplib.html?highlight=smtplib#smtp-objects\" target=\"_blank\" rel=\"noopener\"><code>SMTP Objects</code></a></strong> <a href=\"https://docs.python.org/3.6/library/smtplib.html?highlight=smtplib#smtp-example\" target=\"_blank\" rel=\"noopener\">Example</a></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> smtplib</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">prompt</span><span class=\"params\">(prompt)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> input(prompt).strip()</span><br><span class=\"line\"></span><br><span class=\"line\">fromaddr = prompt(<span class=\"string\">\"From: \"</span>)</span><br><span class=\"line\">toaddrs  = prompt(<span class=\"string\">\"To: \"</span>).split()</span><br><span class=\"line\">print(<span class=\"string\">\"Enter message, end with ^D (Unix) or ^Z (Windows):\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Add the From: and To: headers at the start!</span></span><br><span class=\"line\">msg = (<span class=\"string\">\"From: %s\\r\\nTo: %s\\r\\n\\r\\n\"</span></span><br><span class=\"line\">       % (fromaddr, <span class=\"string\">\", \"</span>.join(toaddrs)))</span><br><span class=\"line\"><span class=\"keyword\">while</span> <span class=\"keyword\">True</span>:</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        line = input()</span><br><span class=\"line\">    <span class=\"keyword\">except</span> EOFError:</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> line:</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">    msg = msg + line</span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">\"Message length is\"</span>, len(msg))</span><br><span class=\"line\"></span><br><span class=\"line\">server = smtplib.SMTP(<span class=\"string\">'localhost'</span>)</span><br><span class=\"line\">server.set_debuglevel(<span class=\"number\">1</span>)</span><br><span class=\"line\">server.sendmail(fromaddr, toaddrs, msg)</span><br><span class=\"line\">server.quit()</span><br></pre></td></tr></table></figure>\n<h4 id=\"郵局協议（Post-Office-Protocol，简称-POP）\"><a href=\"#郵局協议（Post-Office-Protocol，简称-POP）\" class=\"headerlink\" title=\"郵局協议（Post Office Protocol，简称 POP）\"></a><a href=\"https://zh.wikipedia.org/wiki/%E9%83%B5%E5%B1%80%E5%8D%94%E5%AE%9A\" target=\"_blank\" rel=\"noopener\">郵局協议（Post Office Protocol，简称 POP）</a></h4><blockquote><p>POP支持离线邮件处理。其具体过程是：邮件发送到服务器上，电子邮件客户端调用邮件客户机程序以连接服务器，并下载所有未阅读的电子邮件。这种离线访问模式是一种存储转发服务，将邮件从邮件服务器端送到个人终端机器上，一般是PC机或MAC。一旦邮件发送到PC机或MAC上，邮件服务器上的邮件将会被删除。但目前的POP3邮件服务器大都可以“只下载邮件，服务器端并不删除”，也就是改进的POP3协议。</p>\n<footer><strong>邮局协议</strong><cite><a href=\"https://zh.wikipedia.org/wiki/%E9%83%B5%E5%B1%80%E5%8D%94%E5%AE%9A\" target=\"_blank\" rel=\"noopener\">zh.wikipedia.org/wiki/%E9%83%B5%E5%B1%80%E5%8D%94%E5%AE%9A</a></cite></footer></blockquote>\n<h5 id=\"poplib-POP3-协议客户端\"><a href=\"#poplib-POP3-协议客户端\" class=\"headerlink\" title=\"poplib - POP3 协议客户端\"></a><a href=\"https://docs.python.org/3.6/library/poplib.html?highlight=poplib#module-poplib\" target=\"_blank\" rel=\"noopener\"><code>poplib</code></a> - POP3 协议客户端</h5><p><a href=\"https://docs.python.org/3.6/library/poplib.html?highlight=poplib#pop3-objects\" target=\"_blank\" rel=\"noopener\"><code>POP3 Objects</code></a></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> getpass, poplib</span><br><span class=\"line\"></span><br><span class=\"line\">M = poplib.POP3(<span class=\"string\">'localhost'</span>)</span><br><span class=\"line\">M.user(getpass.getuser())</span><br><span class=\"line\">M.pass_(getpass.getpass())</span><br><span class=\"line\">numMessages = len(M.list()[<span class=\"number\">1</span>])</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(numMessages):</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> M.retr(i+<span class=\"number\">1</span>)[<span class=\"number\">1</span>]:</span><br><span class=\"line\">        print(j)</span><br></pre></td></tr></table></figure>\n<h4 id=\"因特网信息访问协议（缩写为-IMAP，以前称作-交互邮件访问协议）\"><a href=\"#因特网信息访问协议（缩写为-IMAP，以前称作-交互邮件访问协议）\" class=\"headerlink\" title=\"因特网信息访问协议（缩写为 IMAP，以前称作 交互邮件访问协议）\"></a><a href=\"https://zh.wikipedia.org/wiki/%E5%9B%A0%E7%89%B9%E7%BD%91%E4%BF%A1%E6%81%AF%E8%AE%BF%E9%97%AE%E5%8D%8F%E8%AE%AE\" target=\"_blank\" rel=\"noopener\">因特网信息访问协议（缩写为 IMAP，以前称作 交互邮件访问协议）</a></h4><blockquote><p>因特网信息访问协议（缩写为IMAP，以前称作交互邮件访问协议）是一个应用层协议，用来从本地邮件客户端（如Microsoft Outlook、Outlook Express、Foxmail、Mozilla Thunderbird）访问远程服务器上的邮件。</p>\n<p>IMAP和POP3（Post Office Protocol - Version 3，邮局协议第三版）是邮件访问最为普遍的Internet标准协议。事实上所有现代的邮件客户端和服务器都对两者给予支持。IMAP现在的版本是“IMAP第四版第一次修订版”（IMAP4rev1），在 RFC 3501 中定义。</p>\n<footer><strong>因特网信息访问协议</strong><cite><a href=\"https://zh.wikipedia.org/wiki/%E5%9B%A0%E7%89%B9%E7%BD%91%E4%BF%A1%E6%81%AF%E8%AE%BF%E9%97%AE%E5%8D%8F%E8%AE%AE\" target=\"_blank\" rel=\"noopener\">zh.wikipedia.org/wiki/%E5%9B%A0%E7%89%B9%E7%BD%91%E4%BF%A1%E6%81%AF%E8%AE%BF%E9%97%AE%E5%8D%8F%E8%AE%AE</a></cite></footer></blockquote>\n<h5 id=\"imaplib-—-IMAP4-协议客户端\"><a href=\"#imaplib-—-IMAP4-协议客户端\" class=\"headerlink\" title=\"imaplib — IMAP4 协议客户端\"></a><a href=\"https://docs.python.org/3.6/library/imaplib.html#module-imaplib\" target=\"_blank\" rel=\"noopener\"><code>imaplib</code></a> — IMAP4 协议客户端</h5><p><a href=\"https://docs.python.org/3.6/library/imaplib.html#imap4-objects\" target=\"_blank\" rel=\"noopener\"><code>IMAP4 Objects</code></a></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> getpass, imaplib</span><br><span class=\"line\"></span><br><span class=\"line\">M = imaplib.IMAP4()</span><br><span class=\"line\">M.login(getpass.getuser(), getpass.getpass())</span><br><span class=\"line\">M.select()</span><br><span class=\"line\">typ, data = M.search(<span class=\"keyword\">None</span>, <span class=\"string\">'ALL'</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> data[<span class=\"number\">0</span>].split():</span><br><span class=\"line\">    typ, data = M.fetch(num, <span class=\"string\">'(RFC822)'</span>)</span><br><span class=\"line\">    print(<span class=\"string\">'Message %s\\n%s\\n'</span> % (num, data[<span class=\"number\">0</span>][<span class=\"number\">1</span>]))</span><br><span class=\"line\">M.close()</span><br><span class=\"line\">M.logout()</span><br></pre></td></tr></table></figure>\n<h4 id=\"email-An-email-and-MIME-handling-package\"><a href=\"#email-An-email-and-MIME-handling-package\" class=\"headerlink\" title=\"email - An email and MIME handling package\"></a><a href=\"https://docs.python.org/3.6/library/email.html?highlight=email#module-email\" target=\"_blank\" rel=\"noopener\"><code>email</code></a> - An email and MIME handling package</h4><h4 id=\"smtpd-SMTP-服务端\"><a href=\"#smtpd-SMTP-服务端\" class=\"headerlink\" title=\"smtpd - SMTP 服务端\"></a><a href=\"https://docs.python.org/3.6/library/smtpd.html?highlight=smtpd#module-smtpd\" target=\"_blank\" rel=\"noopener\"><code>smtpd</code></a> - SMTP 服务端</h4><h4 id=\"base64-Base16-Base32-Base64-Base85-Data-Encodings\"><a href=\"#base64-Base16-Base32-Base64-Base85-Data-Encodings\" class=\"headerlink\" title=\"base64 - Base16, Base32, Base64, Base85 Data Encodings\"></a><a href=\"https://docs.python.org/3.6/library/base64.html?highlight=base64#module-base64\" target=\"_blank\" rel=\"noopener\"><code>base64</code></a> - Base16, Base32, Base64, Base85 Data Encodings</h4><h4 id=\"mimetypes-Map-filenames-to-MIME-types\"><a href=\"#mimetypes-Map-filenames-to-MIME-types\" class=\"headerlink\" title=\"mimetypes - Map filenames to MIME types\"></a><a href=\"https://docs.python.org/3.6/library/mimetypes.html?highlight=mimetypes#module-mimetypes\" target=\"_blank\" rel=\"noopener\"><code>mimetypes</code></a> - Map filenames to MIME types</h4><blockquote><p>互联网媒体类型（Internet media type，也称为MIME类型（MIME type）或内容类型（content type））是给互联网上传输的内容赋予的分类类型。一份内容的互联网媒体类型是由其文件格式与内容决定的。互联网媒体类型与文件拓展名相对应，因此计算机系统常常通过拓展名来确定一个文件的媒体类型并决定与其相关联的软件。互联网媒体类型的分类标准由互联网号码分配局（IANA）发布。1996年十一月，媒体类型在RFC 2045中被最初定义，当时仅被使用在SMTP协议的电子邮件中。现在其他的协议（比如HTTP或者SIP）也都常使用MIME类型。 一个MIME类型至少包括两个部分：一个类型（type）和一个子类型（subtype）。此外，它还可能包括一个或多个可选参数（optional parameter）。比如，HTML文件的互联网媒体类型可能是</p>\n<p>text/html; charset = UTF-8</p>\n<p>在这个例子中，文件类型为text，子类型为html，而charset是一个可选参数，其值为UTF-8。</p>\n<footer><strong>互联网媒体类型</strong><cite><a href=\"https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91%E5%AA%92%E4%BD%93%E7%B1%BB%E5%9E%8B\" target=\"_blank\" rel=\"noopener\">zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91%E5%AA%92%E4%BD%93%E7%B1%BB%E5%9E%8B</a></cite></footer></blockquote>\n<h4 id=\"binascii-Convert-between-binary-and-ASCII\"><a href=\"#binascii-Convert-between-binary-and-ASCII\" class=\"headerlink\" title=\"binascii - Convert between binary and ASCII\"></a><a href=\"https://docs.python.org/3.6/library/binascii.html?highlight=binascii#module-binascii\" target=\"_blank\" rel=\"noopener\"><code>binascii</code></a> - Convert between binary and ASCII</h4><h4 id=\"binhex-Encode-and-decode-binhex4-files\"><a href=\"#binhex-Encode-and-decode-binhex4-files\" class=\"headerlink\" title=\"binhex - Encode and decode binhex4 files\"></a><a href=\"https://docs.python.org/3.6/library/binhex.html?highlight=binhex#module-binhex\" target=\"_blank\" rel=\"noopener\"><code>binhex</code></a> - Encode and decode binhex4 files</h4><h4 id=\"quopri-Encode-and-decode-MIME-quoted-printable-data\"><a href=\"#quopri-Encode-and-decode-MIME-quoted-printable-data\" class=\"headerlink\" title=\"quopri - Encode and decode MIME quoted-printable data\"></a><a href=\"https://docs.python.org/3.6/library/quopri.html#module-quopri\" target=\"_blank\" rel=\"noopener\"><code>quopri</code></a> - Encode and decode MIME quoted-printable data</h4><h3 id=\"多线程编程\"><a href=\"#多线程编程\" class=\"headerlink\" title=\"多线程编程\"></a>多线程编程</h3><h4 id=\"thread-低级线程-API\"><a href=\"#thread-低级线程-API\" class=\"headerlink\" title=\"_thread - 低级线程 API\"></a><a href=\"https://docs.python.org/3.6/library/_thread.html#module-_thread\" target=\"_blank\" rel=\"noopener\"><code>_thread</code></a> - 低级线程 API</h4><h4 id=\"threading-基于-thread-的高级线程接口\"><a href=\"#threading-基于-thread-的高级线程接口\" class=\"headerlink\" title=\"threading - 基于 _thread 的高级线程接口\"></a><a href=\"https://docs.python.org/3.6/library/threading.html#module-threading\" target=\"_blank\" rel=\"noopener\"><code>threading</code></a> - 基于 <code>_thread</code> 的高级线程接口</h4><blockquote>\n<p><code>threading</code>模块支持守护线程(<a href=\"https://docs.python.org/3.6/library/threading.html?highlight=daemon#threading.Thread.daemon\" target=\"_blank\" rel=\"noopener\"><code>daemon</code></a> thread)，其工作方式是：守护线程一般是一个等待客户端请求服务的服务器。如果没有客户端请求，守护线程就是空闲的。如果把一个线程设置为守护线程，就表示这个线程是<strong>不重要的</strong>，进程退出时不需要等待这个线程执行完成。</p>\n<p>如果主线程准备退出时，不需要等待某些子线程完成，就可以为这些子线程设置守护线程标记。</p>\n</blockquote>\n<h5 id=\"创建-Thread-实例，传给它一个函数（多线程模式1）\"><a href=\"#创建-Thread-实例，传给它一个函数（多线程模式1）\" class=\"headerlink\" title=\"创建 Thread 实例，传给它一个函数（多线程模式1）\"></a>创建 Thread 实例，传给它一个函数（多线程模式1）</h5><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> threading</span><br><span class=\"line\"><span class=\"keyword\">from</span> time <span class=\"keyword\">import</span> sleep, ctime</span><br><span class=\"line\"></span><br><span class=\"line\">loops = [<span class=\"number\">4</span>, <span class=\"number\">2</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">loop</span><span class=\"params\">(nloop, nsec)</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">'start loop'</span>, nloop, <span class=\"string\">'at:'</span>, ctime())</span><br><span class=\"line\">    sleep(nsec)</span><br><span class=\"line\">    print(<span class=\"string\">'loop'</span>, nloop, <span class=\"string\">'done at:'</span>, ctime())</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">'starting at:'</span>, ctime())</span><br><span class=\"line\">    threads = []</span><br><span class=\"line\">    nloops = list(range(len(loops)))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> nloops:</span><br><span class=\"line\">        t = threading.Thread(target=loop,</span><br><span class=\"line\">                             args=(i, loops[i]))</span><br><span class=\"line\">        threads.append(t)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> nloops:  <span class=\"comment\"># start threads</span></span><br><span class=\"line\">        threads[i].start()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> nloops:  <span class=\"comment\"># wait for all</span></span><br><span class=\"line\">        threads[i].join()  <span class=\"comment\"># threads to finish</span></span><br><span class=\"line\"></span><br><span class=\"line\">    print(<span class=\"string\">'all DONE at:'</span>, ctime())</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    main()</span><br></pre></td></tr></table></figure>\n<p>当所有线程都被分配完毕后，通过调用每个线程的 <code>start()</code> 方法让它们开始执行，而不是在这之前就会执行。</p>\n<p><code>join()</code> 方法将等待线程结束，或者在提供了超时时间的情况下，达到超时时间。一旦线程启动，它们就会一直执行，知道给定的函数完成之后退出。如果主线程还有其他事情要做，而不是等待某些线程完成，就可以不调用 <code>join()</code> 。 <code>join()</code> 方法只有在需要等待线程完成的时候才是有用的。</p>\n<h5 id=\"创建-Thread-实例，传给它一个可调用的类的实例（多线程模式2）\"><a href=\"#创建-Thread-实例，传给它一个可调用的类的实例（多线程模式2）\" class=\"headerlink\" title=\"创建 Thread 实例，传给它一个可调用的类的实例（多线程模式2）\"></a>创建 Thread 实例，传给它一个可调用的类的实例（多线程模式2）</h5><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> threading</span><br><span class=\"line\"><span class=\"keyword\">from</span> time <span class=\"keyword\">import</span> sleep, ctime</span><br><span class=\"line\"></span><br><span class=\"line\">loops = [<span class=\"number\">4</span>, <span class=\"number\">2</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadFunc</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, func, args, name=<span class=\"string\">''</span>)</span>:</span></span><br><span class=\"line\">        self.name = name</span><br><span class=\"line\">        self.func = func</span><br><span class=\"line\">        self.args = args</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__call__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        self.func(*self.args)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">loop</span><span class=\"params\">(nloop, nsec)</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">'start loop'</span>, nloop, <span class=\"string\">'at:'</span>, ctime())</span><br><span class=\"line\">    sleep(nsec)</span><br><span class=\"line\">    print(<span class=\"string\">'loop'</span>, nloop, <span class=\"string\">'done at:'</span>, ctime())</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">'starting at:'</span>, ctime())</span><br><span class=\"line\">    threads = []</span><br><span class=\"line\">    nloops = range(len(loops))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> nloops:        <span class=\"comment\"># create all threads</span></span><br><span class=\"line\">        t = threading.Thread(</span><br><span class=\"line\">            target=ThreadFunc(loop, (i, loops[i]),</span><br><span class=\"line\">            loop.__name__))</span><br><span class=\"line\">        threads.append(t)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> nloops:        <span class=\"comment\"># start all threads</span></span><br><span class=\"line\">        threads[i].start()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> nloops:        <span class=\"comment\"># wait for completion</span></span><br><span class=\"line\">        threads[i].join()</span><br><span class=\"line\"></span><br><span class=\"line\">    print(<span class=\"string\">'all DONE at:'</span>, ctime())</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    main()</span><br></pre></td></tr></table></figure>\n<p>相对于上一个示例，本次主要是添加了<code>ThreadFunc</code>类，并在实例化<code>Thread</code>对象的同时实例化了可调用类<code>ThreadFunc</code>。</p>\n<p>当创建新线程时，<code>Thread</code>类的代码将调用<code>ThreadFunc</code>对象，对此会调用<code>__call__()</code>这个特殊方法。</p>\n<h5 id=\"派生-Thread-的子类，并创建子类的实例（多线程模式3-推荐方式）\"><a href=\"#派生-Thread-的子类，并创建子类的实例（多线程模式3-推荐方式）\" class=\"headerlink\" title=\"派生 Thread 的子类，并创建子类的实例（多线程模式3 - 推荐方式）\"></a>派生 <a href=\"https://docs.python.org/3/library/threading.html?highlight=threading%20thread#thread-objects\" target=\"_blank\" rel=\"noopener\">Thread</a> 的子类，并创建子类的实例（多线程模式3 - 推荐方式）</h5><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> threading</span><br><span class=\"line\"><span class=\"keyword\">from</span> time <span class=\"keyword\">import</span> sleep, ctime</span><br><span class=\"line\"></span><br><span class=\"line\">loops = [<span class=\"number\">4</span>, <span class=\"number\">2</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThread</span><span class=\"params\">(threading.Thread)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, func, args, name=<span class=\"string\">''</span>)</span>:</span></span><br><span class=\"line\">        threading.Thread.__init__(self, name=name)</span><br><span class=\"line\">        self.func = func</span><br><span class=\"line\">        self.args = args</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        self.func(*self.args)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">loop</span><span class=\"params\">(nloop, nsec)</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">'start loop'</span>, nloop, <span class=\"string\">'at:'</span>, ctime())</span><br><span class=\"line\">    sleep(nsec)</span><br><span class=\"line\">    print(<span class=\"string\">'loop'</span>, nloop, <span class=\"string\">'done at:'</span>, ctime())</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">'starting at:'</span>, ctime())</span><br><span class=\"line\">    threads = []</span><br><span class=\"line\">    nloops = range(len(loops))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> nloops:</span><br><span class=\"line\">        t = MyThread(loop, (i, loops[i]),</span><br><span class=\"line\">            loop.__name__)</span><br><span class=\"line\">        threads.append(t)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> nloops:</span><br><span class=\"line\">        threads[i].start()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> nloops:</span><br><span class=\"line\">        threads[i].join()</span><br><span class=\"line\"></span><br><span class=\"line\">    print(<span class=\"string\">'all DONE at:'</span>, ctime())</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    main()</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>对于多线程来说，相对推荐这个模式，只需要创建 <a href=\"https://docs.python.org/3/library/threading.html?highlight=threading%20thread#threading.Thread\" target=\"_blank\" rel=\"noopener\"><code>Thread</code></a> 的派生类，并重写 <code>__init__()</code> 及 <a href=\"https://docs.python.org/3/library/threading.html?highlight=threading%20thread#threading.Thread.run\" target=\"_blank\" rel=\"noopener\"><code>run()</code></a> 方法即可</p>\n</blockquote>\n<h4 id=\"多线程实践\"><a href=\"#多线程实践\" class=\"headerlink\" title=\"多线程实践\"></a>多线程实践</h4><h5 id=\"图书排名示例\"><a href=\"#图书排名示例\" class=\"headerlink\" title=\"图书排名示例\"></a>图书排名示例</h5><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> urllib.request</span><br><span class=\"line\"><span class=\"keyword\">from</span> atexit <span class=\"keyword\">import</span> register</span><br><span class=\"line\"><span class=\"keyword\">from</span> re <span class=\"keyword\">import</span> compile</span><br><span class=\"line\"><span class=\"keyword\">from</span> threading <span class=\"keyword\">import</span> Thread</span><br><span class=\"line\"><span class=\"keyword\">from</span> time <span class=\"keyword\">import</span> ctime</span><br><span class=\"line\"></span><br><span class=\"line\">REGEX = compile(<span class=\"string\">'#([\\d,]+) in Books '</span>)</span><br><span class=\"line\">AMZN = <span class=\"string\">'https://www.amazon.com/dp/'</span></span><br><span class=\"line\">ISBNs = &#123;</span><br><span class=\"line\">    <span class=\"string\">'0132269937'</span>: <span class=\"string\">'Core Python Programming'</span>,</span><br><span class=\"line\">    <span class=\"string\">'0132356139'</span>: <span class=\"string\">'Python Web Development with Django'</span>,</span><br><span class=\"line\">    <span class=\"string\">'0137143419'</span>: <span class=\"string\">'Python Fundamentals'</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getRanking</span><span class=\"params\">(isbn)</span>:</span></span><br><span class=\"line\">    opener = urllib.request.build_opener()</span><br><span class=\"line\">    opener.addheaders = [(<span class=\"string\">'User-agent'</span>, <span class=\"string\">'Mozilla/5.0 (X11; U; Linux i686) Gecko/20071127 Firefox/2.0.0.11'</span>)]</span><br><span class=\"line\">    o = opener.open(<span class=\"string\">'&#123;0&#125;&#123;1&#125;'</span>.format(AMZN, isbn))</span><br><span class=\"line\">    data = str(o.read(), <span class=\"string\">'utf-8'</span>)</span><br><span class=\"line\">    opener.close()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> REGEX.findall(data)[<span class=\"number\">0</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_showRanking</span><span class=\"params\">(isbn)</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">'- %r ranked %s'</span> % (</span><br><span class=\"line\">        ISBNs[isbn], getRanking(isbn)))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_main</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">'At'</span>, ctime(), <span class=\"string\">'on Amazon...'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> isbn <span class=\"keyword\">in</span> ISBNs:</span><br><span class=\"line\">        Thread(target=_showRanking, args=(isbn,)).start()  <span class=\"comment\"># _showRanking(isbn)</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@register</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_atexit</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">'all DONE at:'</span>, ctime())</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    _main()</span><br></pre></td></tr></table></figure>\n<blockquote><p><strong>竞争冒险</strong>（race hazard）又名<strong>竞态条件</strong>、<strong>竞争条件</strong>（race condition），它旨在描述一个系统或者进程的输出依赖于不受控制的事件出现顺序或者出现时机。此词源自于两个信号试着彼此竞争，来影响谁先输出。</p>\n<p>举例来说，如果计算机中的两个<a href=\"https://zh.wikipedia.org/wiki/%E8%BF%9B%E7%A8%8B\" target=\"_blank\" rel=\"noopener\">进程</a>同时试图修改一个共享内存的内容，在没有<a href=\"https://zh.wikipedia.org/wiki/%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6\" target=\"_blank\" rel=\"noopener\">并发控制</a>的情况下，最后的结果依赖于两个进程的执行顺序与时机。而且如果发生了并发访问冲突，则最后的结果是不正确的。</p>\n<p>竞争冒险常见于不良设计的电子系统，尤其是逻辑电路。但它们在<a href=\"https://zh.wikipedia.org/wiki/%E8%BB%9F%E9%AB%94\" target=\"_blank\" rel=\"noopener\">软件</a>中也比较常见，尤其是有采用<a href=\"https://zh.wikipedia.org/wiki/%E5%A4%9A%E7%BA%BF%E7%A8%8B\" target=\"_blank\" rel=\"noopener\">多线程</a>技术的软件。</p>\n<footer><strong>竞争冒险</strong><cite><a href=\"https://zh.wikipedia.org/wiki/%E7%AB%B6%E7%88%AD%E5%8D%B1%E5%AE%B3\" target=\"_blank\" rel=\"noopener\">zh.wikipedia.org/wiki/%E7%AB%B6%E7%88%AD%E5%8D%B1%E5%AE%B3</a></cite></footer></blockquote>\n<h5 id=\"Lock-Objects\"><a href=\"#Lock-Objects\" class=\"headerlink\" title=\"Lock Objects\"></a><a href=\"https://docs.python.org/3/library/threading.html?highlight=threading#lock-objects\" target=\"_blank\" rel=\"noopener\">Lock Objects</a></h5><p><strong>原始锁定是一种同步原语，在锁定时不属于特定线程</strong>。</p>\n<p><strong>当多个线程在<a href=\"https://docs.python.org/3/library/threading.html?highlight=threading#threading.Lock.acquire\" target=\"_blank\" rel=\"noopener\"><code>acquire()</code></a>等待状态转为解锁状态时被阻塞时，当一个<a href=\"https://docs.python.org/3/library/threading.html?highlight=threading#threading.Lock.release\" target=\"_blank\" rel=\"noopener\"><code>release()</code></a> 呼叫将状态重置为解锁状态时，只有一个线程继续进行; 哪一个等待的线程没有被定义，并且可能会因实现而有所不同。</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/env python</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> atexit <span class=\"keyword\">import</span> register</span><br><span class=\"line\"><span class=\"keyword\">from</span> random <span class=\"keyword\">import</span> randrange</span><br><span class=\"line\"><span class=\"keyword\">from</span> threading <span class=\"keyword\">import</span> Thread, Lock, currentThread</span><br><span class=\"line\"><span class=\"keyword\">from</span> time <span class=\"keyword\">import</span> sleep, ctime</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CleanOutputSet</span><span class=\"params\">(set)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__str__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">', '</span>.join(x <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> self)</span><br><span class=\"line\"></span><br><span class=\"line\">lock = Lock()</span><br><span class=\"line\">loops = (randrange(<span class=\"number\">2</span>, <span class=\"number\">5</span>) <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> range(randrange(<span class=\"number\">3</span>, <span class=\"number\">7</span>)))</span><br><span class=\"line\">remaining = CleanOutputSet()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">loop</span><span class=\"params\">(nsec)</span>:</span></span><br><span class=\"line\">    myname = currentThread().name</span><br><span class=\"line\">    lock.acquire()</span><br><span class=\"line\">    remaining.add(myname)</span><br><span class=\"line\">    print(<span class=\"string\">'[%s] Started %s'</span> % (ctime(), myname)) <span class=\"comment\">#print '[&#123;0&#125;] Started &#123;1&#125;'.format(ctime(), myname)</span></span><br><span class=\"line\">    lock.release()</span><br><span class=\"line\">    sleep(nsec)</span><br><span class=\"line\">    lock.acquire()</span><br><span class=\"line\">    remaining.remove(myname)</span><br><span class=\"line\">    print(<span class=\"string\">'[%s] Completed %s (%d secs)'</span> % ( <span class=\"comment\">#print '[&#123;0&#125;] Completed &#123;1&#125; (&#123;2&#125; secs)'.format(</span></span><br><span class=\"line\">        ctime(), myname, nsec))</span><br><span class=\"line\">    print(<span class=\"string\">'    (remaining: %s)'</span> % (remaining <span class=\"keyword\">or</span> <span class=\"string\">'NONE'</span>)) <span class=\"comment\">#print '    (remaining: &#123;0&#125;)'.format(remaining or 'NONE')</span></span><br><span class=\"line\">    lock.release()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_main</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> pause <span class=\"keyword\">in</span> loops:</span><br><span class=\"line\">        Thread(target=loop, args=(pause,)).start()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@register</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_atexit</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">'all DONE at:'</span>, ctime())</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    _main()</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">[Thu May 10 15:52:48 2018] Started Thread-1</span><br><span class=\"line\">[Thu May 10 15:52:48 2018] Started Thread-2</span><br><span class=\"line\">[Thu May 10 15:52:48 2018] Started Thread-3</span><br><span class=\"line\">[Thu May 10 15:52:48 2018] Started Thread-4</span><br><span class=\"line\">[Thu May 10 15:52:51 2018] Completed Thread-4 (3 secs)</span><br><span class=\"line\">    (remaining: Thread-1, Thread-3, Thread-2)</span><br><span class=\"line\">[Thu May 10 15:52:51 2018] Completed Thread-2 (3 secs)</span><br><span class=\"line\">    (remaining: Thread-1, Thread-3)</span><br><span class=\"line\">[Thu May 10 15:52:52 2018] Completed Thread-1 (4 secs)</span><br><span class=\"line\">    (remaining: Thread-3)</span><br><span class=\"line\">[Thu May 10 15:52:52 2018] Completed Thread-3 (4 secs)</span><br><span class=\"line\">    (remaining: NONE)</span><br><span class=\"line\">all DONE at: Thu May 10 15:52:52 2018</span><br></pre></td></tr></table></figure>\n<p>以上示例中由于 <code>sleep(nsec)</code> 的存在，才造成了输出后半部分不同线程的结束顺序不同。</p>\n<blockquote>\n<p>个人理解：Lock锁线程后会造成所有线程的阻塞和等待。</p>\n</blockquote>\n<h5 id=\"上下文管理器-with\"><a href=\"#上下文管理器-with\" class=\"headerlink\" title=\"上下文管理器 with\"></a>上下文管理器 <a href=\"https://docs.python.org/3/library/threading.html?highlight=threading#using-locks-conditions-and-semaphores-in-the-with-statement\" target=\"_blank\" rel=\"noopener\">with</a></h5><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">with</span> some_lock:</span><br><span class=\"line\">    <span class=\"comment\"># do something...</span></span><br></pre></td></tr></table></figure>\n<p>与以下代码是等价的</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">some_lock.acquire()</span><br><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    <span class=\"comment\"># do something...</span></span><br><span class=\"line\"><span class=\"keyword\">finally</span>:</span><br><span class=\"line\">    some_lock.release()</span><br></pre></td></tr></table></figure>\n<h4 id=\"信号量-Semaphore-Objects\"><a href=\"#信号量-Semaphore-Objects\" class=\"headerlink\" title=\"信号量(Semaphore Objects)\"></a>信号量(<a href=\"https://docs.python.org/3/library/threading.html?highlight=threading#semaphore-objects\" target=\"_blank\" rel=\"noopener\">Semaphore Objects</a>)</h4><p>一个信号量管理一个内部计数器，该计数器由每个 <a href=\"https://docs.python.org/3/library/threading.html?highlight=threading#threading.Semaphore.release\" target=\"_blank\" rel=\"noopener\"><code>release()</code></a>调用递减，并由每个<a href=\"https://docs.python.org/3/library/threading.html?highlight=threading#threading.Semaphore.release\" target=\"_blank\" rel=\"noopener\"><code>release()</code></a>调用递增。 柜台不能低于零; 当 <a href=\"https://docs.python.org/3/library/threading.html?highlight=threading#threading.Semaphore.release\" target=\"_blank\" rel=\"noopener\"><code>release()</code></a>发现它为零时，它会阻塞，等待其他线程调用<a href=\"https://docs.python.org/3/library/threading.html?highlight=threading#threading.Semaphore.release\" target=\"_blank\" rel=\"noopener\"><code>release()</code></a>。</p>\n<blockquote>\n<p>信号量通常用于保护容量有限的资源。如果资源的大小是固定的，就应该使用有界的信号量。</p>\n</blockquote>\n<p>主线程中定义信号量</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">maxconnections = <span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"comment\"># ...</span></span><br><span class=\"line\">pool_sema = BoundedSemaphore(value=maxconnections)</span><br></pre></td></tr></table></figure>\n<p>工作线程在需要连接到服务器时调用信号量的获取和释放方法：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">with</span> pool_sema:</span><br><span class=\"line\">    conn = connectdb()</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        <span class=\"comment\"># ... use connection ...</span></span><br><span class=\"line\">    <span class=\"keyword\">finally</span>:</span><br><span class=\"line\">        conn.close()</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> random</span><br><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"><span class=\"keyword\">from</span> atexit <span class=\"keyword\">import</span> register</span><br><span class=\"line\"><span class=\"keyword\">from</span> threading <span class=\"keyword\">import</span> Thread, currentThread, BoundedSemaphore</span><br><span class=\"line\"></span><br><span class=\"line\">MAX = <span class=\"number\">2</span></span><br><span class=\"line\">_sem = BoundedSemaphore(MAX)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">op</span><span class=\"params\">(index)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">with</span> _sem:</span><br><span class=\"line\">        threadName = currentThread().name</span><br><span class=\"line\">        print(<span class=\"string\">'&#123;1&#125; thread &#123;0&#125; 开始执行.'</span>.format(threadName, time.ctime()))</span><br><span class=\"line\">        sec = random.randint(<span class=\"number\">1</span>, <span class=\"number\">10</span>)</span><br><span class=\"line\">        time.sleep(sec)</span><br><span class=\"line\">        print(<span class=\"string\">'&#123;1&#125; thread &#123;0&#125; 开始完成.'</span>.format(threadName, time.ctime()))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@register</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_atexit</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">'all DONE'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_main</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">5</span>):</span><br><span class=\"line\">        Thread(target=op, args=(str(i),)).start()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    _main()</span><br></pre></td></tr></table></figure>\n<p>输出内容如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Thu May 10 16:14:10 2018 thread Thread-1 开始执行.</span><br><span class=\"line\">Thu May 10 16:14:10 2018 thread Thread-2 开始执行.</span><br><span class=\"line\">Thu May 10 16:14:15 2018 thread Thread-1 开始完成.</span><br><span class=\"line\">Thu May 10 16:14:15 2018 thread Thread-3 开始执行.</span><br><span class=\"line\">Thu May 10 16:14:20 2018 thread Thread-2 开始完成.</span><br><span class=\"line\">Thu May 10 16:14:20 2018 thread Thread-4 开始执行.</span><br><span class=\"line\">Thu May 10 16:14:21 2018 thread Thread-3 开始完成.</span><br><span class=\"line\">Thu May 10 16:14:21 2018 thread Thread-5 开始执行.</span><br><span class=\"line\">Thu May 10 16:14:28 2018 thread Thread-5 开始完成.</span><br><span class=\"line\">Thu May 10 16:14:29 2018 thread Thread-4 开始完成.</span><br><span class=\"line\">all DONE</span><br></pre></td></tr></table></figure>\n<p>可以看到，开始执行时，最多只执行了 2 个线程，其他线程都在等待。当某一线程执行完成后，剩余线程中的一条开始执行。</p>\n<h4 id=\"同步队列-queue-—-A-synchronized-queue-class\"><a href=\"#同步队列-queue-—-A-synchronized-queue-class\" class=\"headerlink\" title=\"同步队列 - queue — A synchronized queue class\"></a>同步队列 - <a href=\"https://docs.python.org/3/library/queue.html?highlight=queue#module-queue\" target=\"_blank\" rel=\"noopener\"><code>queue</code></a> — A synchronized queue class</h4><p>在多线程之间进行数据交换的利器。</p>\n<p><a href=\"https://docs.python.org/3/library/queue.html?highlight=queue#queue.Queue\" target=\"_blank\" rel=\"noopener\"><code>queue.Queue(*maxsize=0*)</code></a> 创建一个<strong>先入先出</strong>的队列。</p>\n<p><a href=\"\"><code>queue.LifoQueue(maxsize=0)</code></a> 创建一个<strong>后入先出</strong>的队列。</p>\n<p><a href=\"https://docs.python.org/3/library/queue.html?highlight=queue#queue.PriorityQueue\" target=\"_blank\" rel=\"noopener\"><code>queue.PriorityQueue(maxsize=0)</code></a> 创建一个<a href=\"https://zh.wikipedia.org/wiki/%E5%84%AA%E5%85%88%E4%BD%87%E5%88%97\" target=\"_blank\" rel=\"noopener\"><strong>优先队列</strong></a>。</p>\n<blockquote>\n<p><code>maxsize</code>是一个整数，用于设置可以放入队列中的项目数的上限。一旦达到此大小，插入将会阻塞，直到消耗队列项目。如果<code>maxsize</code>小于或等于零，则队列大小是无限的。</p>\n</blockquote>\n<h4 id=\"多进程\"><a href=\"#多进程\" class=\"headerlink\" title=\"多进程\"></a>多进程</h4><p>由于 Python 的 GIL 的限制，多线程更适合于 I/O 密集型应用（I/O释放了GIL，可以允许更多的并发），而不是计算密集型应用。对于计算密集型应用，为了实现更好的并行性，需要使用<strong>多进程</strong>，以便让CPU的其他内核来执行。</p>\n<h5 id=\"subprocess-子进程管理\"><a href=\"#subprocess-子进程管理\" class=\"headerlink\" title=\"subprocess - 子进程管理\"></a><a href=\"https://docs.python.org/3/library/subprocess.html?highlight=subprocess#module-subprocess\" target=\"_blank\" rel=\"noopener\"><code>subprocess</code></a> - 子进程管理</h5><h5 id=\"multiprocessing-并行进程，该模块允许程序员充分利用给定机器上的多个处理器。\"><a href=\"#multiprocessing-并行进程，该模块允许程序员充分利用给定机器上的多个处理器。\" class=\"headerlink\" title=\"multiprocessing - 并行进程，该模块允许程序员充分利用给定机器上的多个处理器。\"></a><a href=\"https://docs.python.org/3/library/multiprocessing.html?highlight=multiprocess#module-multiprocessing\" target=\"_blank\" rel=\"noopener\"><code>multiprocessing</code></a> - 并行进程，该模块允许程序员充分利用给定机器上的多个处理器。</h5><h5 id=\"concurrent-futures-启动并行任务\"><a href=\"#concurrent-futures-启动并行任务\" class=\"headerlink\" title=\"concurrent.futures - 启动并行任务\"></a><a href=\"https://docs.python.org/3/library/concurrent.futures.html?highlight=concurrent%20futures#module-concurrent.futures\" target=\"_blank\" rel=\"noopener\"><code>concurrent.futures</code></a> - 启动并行任务</h5><p>Python 3.2 开始提供的一个高级库。可以让开发者不在过分关注同步和线程/进程的管理。</p>\n<p>只需要指定线程池/进程池的最大工作数量，提交任务，然后整理结果即可。</p>\n<h6 id=\"ThreadPoolExecutor-支持异步调用的线程池\"><a href=\"#ThreadPoolExecutor-支持异步调用的线程池\" class=\"headerlink\" title=\"ThreadPoolExecutor - 支持异步调用的线程池\"></a><a href=\"https://docs.python.org/3/library/concurrent.futures.html?highlight=concurrent%20futures#concurrent.futures.ThreadPoolExecutor\" target=\"_blank\" rel=\"noopener\"><code>ThreadPoolExecutor</code></a> - 支持异步调用的线程池</h6><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> concurrent.futures</span><br><span class=\"line\"><span class=\"keyword\">import</span> urllib.request</span><br><span class=\"line\"></span><br><span class=\"line\">URLS = [<span class=\"string\">'http://www.foxnews.com/'</span>,</span><br><span class=\"line\">        <span class=\"string\">'http://www.cnn.com/'</span>,</span><br><span class=\"line\">        <span class=\"string\">'http://europe.wsj.com/'</span>,</span><br><span class=\"line\">        <span class=\"string\">'http://www.bbc.co.uk/'</span>,</span><br><span class=\"line\">        <span class=\"string\">'http://some-made-up-domain.com/'</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Retrieve a single page and report the URL and contents</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">load_url</span><span class=\"params\">(url, timeout)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">with</span> urllib.request.urlopen(url, timeout=timeout) <span class=\"keyword\">as</span> conn:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> conn.read()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># We can use a with statement to ensure threads are cleaned up promptly</span></span><br><span class=\"line\"><span class=\"keyword\">with</span> concurrent.futures.ThreadPoolExecutor(max_workers=<span class=\"number\">5</span>) <span class=\"keyword\">as</span> executor:</span><br><span class=\"line\">    <span class=\"comment\"># Start the load operations and mark each future with its URL</span></span><br><span class=\"line\">    future_to_url = &#123;executor.submit(load_url, url, <span class=\"number\">60</span>): url <span class=\"keyword\">for</span> url <span class=\"keyword\">in</span> URLS&#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> future <span class=\"keyword\">in</span> concurrent.futures.as_completed(future_to_url):</span><br><span class=\"line\">        url = future_to_url[future]</span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            data = future.result()</span><br><span class=\"line\">        <span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> exc:</span><br><span class=\"line\">            print(<span class=\"string\">'%r generated an exception: %s'</span> % (url, exc))</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            print(<span class=\"string\">'%r page is %d bytes'</span> % (url, len(data)))</span><br></pre></td></tr></table></figure>\n<h6 id=\"ProcessPoolExecutor-支持异步调用的进程池\"><a href=\"#ProcessPoolExecutor-支持异步调用的进程池\" class=\"headerlink\" title=\"ProcessPoolExecutor - 支持异步调用的进程池\"></a><a href=\"https://docs.python.org/3/library/concurrent.futures.html?highlight=concurrent%20futures#concurrent.futures.ProcessPoolExecutor\" target=\"_blank\" rel=\"noopener\"><code>ProcessPoolExecutor</code></a> - 支持异步调用的进程池</h6><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> concurrent.futures</span><br><span class=\"line\"><span class=\"keyword\">import</span> math</span><br><span class=\"line\"></span><br><span class=\"line\">PRIMES = [</span><br><span class=\"line\">    <span class=\"number\">112272535095293</span>,</span><br><span class=\"line\">    <span class=\"number\">112582705942171</span>,</span><br><span class=\"line\">    <span class=\"number\">112272535095293</span>,</span><br><span class=\"line\">    <span class=\"number\">115280095190773</span>,</span><br><span class=\"line\">    <span class=\"number\">115797848077099</span>,</span><br><span class=\"line\">    <span class=\"number\">1099726899285419</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">is_prime</span><span class=\"params\">(n)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> n % <span class=\"number\">2</span> == <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\"></span><br><span class=\"line\">    sqrt_n = int(math.floor(math.sqrt(n)))</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">3</span>, sqrt_n + <span class=\"number\">1</span>, <span class=\"number\">2</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n % i == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">with</span> concurrent.futures.ProcessPoolExecutor() <span class=\"keyword\">as</span> executor:</span><br><span class=\"line\">        <span class=\"keyword\">for</span> number, prime <span class=\"keyword\">in</span> zip(PRIMES, executor.map(is_prime, PRIMES)):</span><br><span class=\"line\">            print(<span class=\"string\">'%d is prime: %s'</span> % (number, prime))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    main()</span><br></pre></td></tr></table></figure>\n<h4 id=\"练习-1\"><a href=\"#练习-1\" class=\"headerlink\" title=\"练习\"></a>练习</h4><ol>\n<li><p>线程和文件。</p>\n<ol>\n<li>创建一个函数，给出一个字节值和一个文件名，然后显示文件中该字节出现的次数。</li>\n<li>假设输入的文件非常大。该文件允许有多个读者，现在请修改你的解决方案，创建多个线程，使每个线程负责文件某一部分的计数。然后将每个线程的数据进行整合，提供正确的总数。使用 <code>timeit</code> 模块对单线程和多线程方案进行计时。</li>\n</ol>\n<p>EXP：对于此类问题，由于并不是I/O密集型操作（单一文本只读取一次的情况下）。由于多线程需要对文本进行分拆，并且多线程之间的锁定和解锁操作等多余操作，会造成采用多线程的性能会低于单一线程性能。</p>\n</li>\n<li><p>线程、文件和正则表达式。有一个非常大的邮件文件；如果没有（把所有的邮件合并到一个文本文件中）。任务是，使用正则表达式用于识别email地址和web站点的URL。并将其转换为链接形式保存到.html新文件中，当时用Web浏览器打开该文件时，这些链接应该是可以单击的。使用线程对这个大文本文件的转换过程进行分割，最后整合所有结果到一个新的.html文件中。</p>\n</li>\n</ol>\n"},{"title":"人类简史-从动物到上帝","updated":"2018-05-17T16:00:00.000Z","date":"2018-05-01T16:00:00.000Z","ISBN":9787508660752,"出版社":"中信出版社","出版时间":"2017-02-28T16:00:00.000Z","版次":2,"description":"<!--more-->","photos":["/2018/05/02/rljs/rljs.png"],"_content":"\n经过5天的泛读后，初略的写下几点简单的读后感，并摘录了部分书中的观点。本书从不同的视角解读了人类的发展历史，解析了人类自身、人类与其他物种之间的关系及相互影响，并对于人类未来的发展方向提供了多个角度的思辨观点。很多观点都是之前我们未曾考虑或不愿直面的。以后还需要花更多的时间来精读此书。\n\n**读后感：**\n\n1. 人类现行的法律、法规、权利、义务、货币、民族等等一切均由集体认可的集体想象而来。\n2. 从许多小文化到少数大文化（帝国）再到最后的全球单一文化（帝国），应该是人类历史无法避免的结果。\n3. 人类经过多次革命，已经摧毁或改变了地球上大部分的生物，最终可能也将摧毁自身。\n4. 对于历史的研究，现在更多的只是研究了历史的表象，而缺少对于产生原因的多方位、深层次思考。\n\n\n**内容摘录：**\n\n## 第一部分 认知革命\n\n### 第四章 毁天灭地的人类洪水\n\n{% blockquote P69 %}\n智人的第一波殖民正是整个动物界最大也是最快速的一场生态浩劫。其中受创最深的是那些大型、毛茸茸的动物。在认知革命发生的时候，地球上大约有200属体重超过50公斤的大型陆生哺乳动物。而等到农业革命的时候，只剩下大约100属。换句话说，甚至远在人类还没有发明轮子、文字和铁器之前，智人就已经让全球大约一半的大型兽类魂归西天、就此灭绝了。 \n{% endblockquote %}\n\n{% blockquote P70~P71 %}\n\n第一波的灭绝浪潮是由于采集者的扩张，接着第二波灭绝浪潮则是因为农民的扩张；今日的第三波灭绝浪潮：由工业活动所造成的物种灭绝。对全世界上所有的大型动物来说，这场人类洪水的唯一幸存者可能只剩下人类自己，还有其他登上诺亚方舟但只作为人类盘中佳肴的家禽家畜。\n\n{% endblockquote %}\n\n## 第二部分 农业革命\n\n### 第五章 史上最大骗局\n\n{% blockquote P77 %}\n\n农业革命让人类的食物总量增加，但量的增加并不代表吃得更好、过的更悠闲，反而只是造成人口爆炸，而且产生一群养尊处优、娇生惯养的精英分子。农业革命可以说是史上最大的一桩骗局。\n\n{% endblockquote %}\n\n{% blockquote P78 %}\n\n其实不是我们驯化了小麦，而是小麦驯化了我们。\n\n{% endblockquote %}\n\n{% blockquote P88~P93 %}\n\n**革命的受害者**  \n\n{% endblockquote %}\n\n### 第六章 盖起金字塔\n\n{% blockquote P98 %}\n\n正是这些征收来的多余粮食，养活了政治、战争、艺术和哲学，建立起了宫殿、堡垒、纪念碑和庙宇。在现代晚期之前，总人口有九成以上是农民，日出而作、胼手胝足。他们生产出来的多余粮食养活了一小撮的精英份子：国王、官员、战士、牧师、艺术家和思想家，但历史写的几乎全是这些人的故事。于是，历史只告诉了我们极少数的人在做什么，而其他绝大多数人的生活就是不停地挑水耕田。 \n\n{% endblockquote %}\n\n### 第八章 历史从无正义\n\n{% blockquote P133 %}\n\n就算身处不同阶级的人发展出了完全一样的能力，因为他们面对的游戏规则不同，最后结果也可能天差地别。这场游戏，其实早就被种种法律限制和潜规则束缚住了手脚，根本不知道公平在哪里。\n\n{% endblockquote %}\n\n## 第三部分 人类的融合统一\n\n### 第九章 历史的方向\n\n{% blockquote P157 %}\n\n农业革命之后，人类社会规模变得更大、更复杂，而维系社会秩序的虚拟故事也更为细致完整。人类机会从出生到死亡都被种种虚构的故事和概念围绕，让他们以特定的方式思考，以特定的标准行事，想要特定的东西，也遵守特定的规范。就是这样，让数百万计的陌生人能遵照这种人造而非天生的直觉，合作无间。这种人造的直觉就是“文化“。 \n\n{% endblockquote %}\n\n### 第十章 金钱的味道\n\n{% blockquote P178 %}\n\n千百年来，哲学家、思想家和宗教人物都对钱嗤之以鼻，称钱为万恶的根源。但就算真是如此，钱同时也是人类最能接受的东西。比起语言、法律、文化、宗教和社会习俗，钱的心胸更为开阔。所有人类创造的信念系统之中，只有金钱能够跨越几乎所有文化鸿沟，不会因为宗教、性别、种族、年龄或性取向而有所歧视。也多亏了有金钱制度，才让人就算互不认识，不清楚对方人品，也能携手合作。\n\n{% endblockquote %}\n\n### 第十一章 帝国的愿景\n\n{% blockquote P197 %}\n\n![](timg.jpg)\n\n泰姬·玛哈尔陵。究竟算是“纯正”的印度文化，还是外来的穆斯林帝国主义建筑？\n\n{% endblockquote %}\n\n### 第十二章 宗教的法则\n\n{% blockquote P199 %}\n\n在金钱和帝国之外，宗教是第三种让人类统一的力量。\n\n{% endblockquote %}\n\n### 第十三章 成功的秘密\n\n历史是所谓的“二级”混沌系统。\n\n## 第四部分 科学革命\n\n### 第十四章 发现自己的无知\n\n{% blockquote P236 %}\n\n现代科学的基础就是拉丁文前缀\"ignoramus-\"，意为”我们不知道“。从这种立场，我们承认了自己并非无所不知。更重要的是，我们也愿意在知识进展之后，承认过去相信的可能是错的。于是，再也没有什么概念、想法或理论是神圣不可挑战的。\n\n{% endblockquote %}\n\n### 第十五章 科学与帝国的联姻\n\n{% blockquote P266~P267 %}\n\n欧洲帝国主义和先前的所有帝国完全不同。过去的帝国主义者都认为自己已经了解了整个世界，“征服世界”只是为了要利用和传播他们自己对于世界的看法。相较之下，欧洲帝国主义之所以要前往遥远的彼岸，除了为了新领土，也是为了新知识。\n\n{% endblockquote %}\n\n### 第十六章 资本主义教条\n\n{% blockquote P293 %}\n\n在《国富论》的第一卷第八章，亚当·斯密提出了一下的创新论述：如果地主、织工或鞋匠赚得的利润高于养家糊口基本所需，就会雇佣更多助手，好进一步提高自己的利润。利润越高，能雇的助手也越多。由此可见，民间企业的获利正是社会整体财富和繁荣的基础。\n\n{% endblockquote %}\n\n{% blockquote P294 %}\n\n所谓的“资本主义”（Capitalism），认为“资本”（capital）与“财富”（wealth）有所不同。资本指的是投入生产的各种金钱、物品和资源。而财富指的则是那些埋在地下或者浪费在非生产性活动的金钱、物品和资源。\n\n{% endblockquote %}\n\n{% blockquote P296~P297 %}\n\n资本主义的基本原则在于，因为不论是正义、自由甚至快乐都必须依赖于经济成长，所以可以说经济成长就是至善（或至少十分接近）。\n\n科学家总能每隔几年就取得另一项发现，提出另一项发明。\n\n印钞票的是银行和政府，但最后埋单的是科学家。\n\n如果实验室的脚步不敌泡沫破灭的速度，可以想见经济前景就会令人十分担忧。\n\n{% endblockquote %}\n\n资本主义与帝国的紧密关系。-东印度公司、鸦片战争。\n\n{% blockquote P306 %}\n\n西方政府几乎就像是资本家的工会。\n\n{% endblockquote %}\n\n{% blockquote P339~P340 %}\n\n如果组成国家和市场的是一个又一个孤单的个人，而不是关系紧密的家庭或社群，要干预个人生活也就容易得多。现代高楼公寓，所有人各自锁在自己家里，连每户该付多少清洁费都无法达成共识，又怎么可能一起站出来抵抗国家机器？\n\n国家、市场与个人之见的交易并不容易。国家和市场对于权力义务的划分意见不同，个人有抱怨这两者要得太多，又给得太少。很多时候，个人遭到市场的剥削，而国家不但不保护个人，反而还用军队、警察和官僚施加迫害。没人想得到，这种互动本身就有不少问题，更公然抵触过去世世代代的社会运作模式，竟然还是能够成功。经过数百万年的演化，人类的生活和思考方式都预设自己属于社群。但仅仅过了两个世纪，我们就成了互相疏远的个人。这可以说是文化力量的最佳证明。\n\n{% endblockquote %}\n\n{% blockquote P342 %}\n\n现代所兴起的两大想象社群，就是“民族”和“消费大众”。所谓民族，是国家的想象社群。而所谓消费大众，则是市场的想象社群。\n\n消费主义和民族主义可说是夙夜匪解，努力说服我们自己和其他数百万人是一伙的，认为我们有共同的过去、共同的利益以及共同的未来。这并不是谎言，而是一场想象。\n\n{% endblockquote %}\n\n### 第十七章 工业的巨轮\n\n### 第十八章 一场永远的革命\n\n### 第十九章 从此过着幸福快乐的日子\n\n### 第二十章 智人末日\n\n以上四章可供思辨的内容较多，就不再一一摘录。","source":"_posts/rljs.md","raw":"title: 人类简史-从动物到上帝\nupdated: 2018-05-18\ndate: 2018-05-02\nISBN: 9787508660752\n出版社: 中信出版社\n出版时间: 2017-03-01\n版次: 2\ndescription: <!--more-->\nphotos:\n- /2018/05/02/rljs/rljs.png\n\ntags:\n\n - 阅读\n\n - 人文\n\n - 历史\n\n - 社会科学\n\ncategories:\n\n - 阅读\n\n---\n\n经过5天的泛读后，初略的写下几点简单的读后感，并摘录了部分书中的观点。本书从不同的视角解读了人类的发展历史，解析了人类自身、人类与其他物种之间的关系及相互影响，并对于人类未来的发展方向提供了多个角度的思辨观点。很多观点都是之前我们未曾考虑或不愿直面的。以后还需要花更多的时间来精读此书。\n\n**读后感：**\n\n1. 人类现行的法律、法规、权利、义务、货币、民族等等一切均由集体认可的集体想象而来。\n2. 从许多小文化到少数大文化（帝国）再到最后的全球单一文化（帝国），应该是人类历史无法避免的结果。\n3. 人类经过多次革命，已经摧毁或改变了地球上大部分的生物，最终可能也将摧毁自身。\n4. 对于历史的研究，现在更多的只是研究了历史的表象，而缺少对于产生原因的多方位、深层次思考。\n\n\n**内容摘录：**\n\n## 第一部分 认知革命\n\n### 第四章 毁天灭地的人类洪水\n\n{% blockquote P69 %}\n智人的第一波殖民正是整个动物界最大也是最快速的一场生态浩劫。其中受创最深的是那些大型、毛茸茸的动物。在认知革命发生的时候，地球上大约有200属体重超过50公斤的大型陆生哺乳动物。而等到农业革命的时候，只剩下大约100属。换句话说，甚至远在人类还没有发明轮子、文字和铁器之前，智人就已经让全球大约一半的大型兽类魂归西天、就此灭绝了。 \n{% endblockquote %}\n\n{% blockquote P70~P71 %}\n\n第一波的灭绝浪潮是由于采集者的扩张，接着第二波灭绝浪潮则是因为农民的扩张；今日的第三波灭绝浪潮：由工业活动所造成的物种灭绝。对全世界上所有的大型动物来说，这场人类洪水的唯一幸存者可能只剩下人类自己，还有其他登上诺亚方舟但只作为人类盘中佳肴的家禽家畜。\n\n{% endblockquote %}\n\n## 第二部分 农业革命\n\n### 第五章 史上最大骗局\n\n{% blockquote P77 %}\n\n农业革命让人类的食物总量增加，但量的增加并不代表吃得更好、过的更悠闲，反而只是造成人口爆炸，而且产生一群养尊处优、娇生惯养的精英分子。农业革命可以说是史上最大的一桩骗局。\n\n{% endblockquote %}\n\n{% blockquote P78 %}\n\n其实不是我们驯化了小麦，而是小麦驯化了我们。\n\n{% endblockquote %}\n\n{% blockquote P88~P93 %}\n\n**革命的受害者**  \n\n{% endblockquote %}\n\n### 第六章 盖起金字塔\n\n{% blockquote P98 %}\n\n正是这些征收来的多余粮食，养活了政治、战争、艺术和哲学，建立起了宫殿、堡垒、纪念碑和庙宇。在现代晚期之前，总人口有九成以上是农民，日出而作、胼手胝足。他们生产出来的多余粮食养活了一小撮的精英份子：国王、官员、战士、牧师、艺术家和思想家，但历史写的几乎全是这些人的故事。于是，历史只告诉了我们极少数的人在做什么，而其他绝大多数人的生活就是不停地挑水耕田。 \n\n{% endblockquote %}\n\n### 第八章 历史从无正义\n\n{% blockquote P133 %}\n\n就算身处不同阶级的人发展出了完全一样的能力，因为他们面对的游戏规则不同，最后结果也可能天差地别。这场游戏，其实早就被种种法律限制和潜规则束缚住了手脚，根本不知道公平在哪里。\n\n{% endblockquote %}\n\n## 第三部分 人类的融合统一\n\n### 第九章 历史的方向\n\n{% blockquote P157 %}\n\n农业革命之后，人类社会规模变得更大、更复杂，而维系社会秩序的虚拟故事也更为细致完整。人类机会从出生到死亡都被种种虚构的故事和概念围绕，让他们以特定的方式思考，以特定的标准行事，想要特定的东西，也遵守特定的规范。就是这样，让数百万计的陌生人能遵照这种人造而非天生的直觉，合作无间。这种人造的直觉就是“文化“。 \n\n{% endblockquote %}\n\n### 第十章 金钱的味道\n\n{% blockquote P178 %}\n\n千百年来，哲学家、思想家和宗教人物都对钱嗤之以鼻，称钱为万恶的根源。但就算真是如此，钱同时也是人类最能接受的东西。比起语言、法律、文化、宗教和社会习俗，钱的心胸更为开阔。所有人类创造的信念系统之中，只有金钱能够跨越几乎所有文化鸿沟，不会因为宗教、性别、种族、年龄或性取向而有所歧视。也多亏了有金钱制度，才让人就算互不认识，不清楚对方人品，也能携手合作。\n\n{% endblockquote %}\n\n### 第十一章 帝国的愿景\n\n{% blockquote P197 %}\n\n![](timg.jpg)\n\n泰姬·玛哈尔陵。究竟算是“纯正”的印度文化，还是外来的穆斯林帝国主义建筑？\n\n{% endblockquote %}\n\n### 第十二章 宗教的法则\n\n{% blockquote P199 %}\n\n在金钱和帝国之外，宗教是第三种让人类统一的力量。\n\n{% endblockquote %}\n\n### 第十三章 成功的秘密\n\n历史是所谓的“二级”混沌系统。\n\n## 第四部分 科学革命\n\n### 第十四章 发现自己的无知\n\n{% blockquote P236 %}\n\n现代科学的基础就是拉丁文前缀\"ignoramus-\"，意为”我们不知道“。从这种立场，我们承认了自己并非无所不知。更重要的是，我们也愿意在知识进展之后，承认过去相信的可能是错的。于是，再也没有什么概念、想法或理论是神圣不可挑战的。\n\n{% endblockquote %}\n\n### 第十五章 科学与帝国的联姻\n\n{% blockquote P266~P267 %}\n\n欧洲帝国主义和先前的所有帝国完全不同。过去的帝国主义者都认为自己已经了解了整个世界，“征服世界”只是为了要利用和传播他们自己对于世界的看法。相较之下，欧洲帝国主义之所以要前往遥远的彼岸，除了为了新领土，也是为了新知识。\n\n{% endblockquote %}\n\n### 第十六章 资本主义教条\n\n{% blockquote P293 %}\n\n在《国富论》的第一卷第八章，亚当·斯密提出了一下的创新论述：如果地主、织工或鞋匠赚得的利润高于养家糊口基本所需，就会雇佣更多助手，好进一步提高自己的利润。利润越高，能雇的助手也越多。由此可见，民间企业的获利正是社会整体财富和繁荣的基础。\n\n{% endblockquote %}\n\n{% blockquote P294 %}\n\n所谓的“资本主义”（Capitalism），认为“资本”（capital）与“财富”（wealth）有所不同。资本指的是投入生产的各种金钱、物品和资源。而财富指的则是那些埋在地下或者浪费在非生产性活动的金钱、物品和资源。\n\n{% endblockquote %}\n\n{% blockquote P296~P297 %}\n\n资本主义的基本原则在于，因为不论是正义、自由甚至快乐都必须依赖于经济成长，所以可以说经济成长就是至善（或至少十分接近）。\n\n科学家总能每隔几年就取得另一项发现，提出另一项发明。\n\n印钞票的是银行和政府，但最后埋单的是科学家。\n\n如果实验室的脚步不敌泡沫破灭的速度，可以想见经济前景就会令人十分担忧。\n\n{% endblockquote %}\n\n资本主义与帝国的紧密关系。-东印度公司、鸦片战争。\n\n{% blockquote P306 %}\n\n西方政府几乎就像是资本家的工会。\n\n{% endblockquote %}\n\n{% blockquote P339~P340 %}\n\n如果组成国家和市场的是一个又一个孤单的个人，而不是关系紧密的家庭或社群，要干预个人生活也就容易得多。现代高楼公寓，所有人各自锁在自己家里，连每户该付多少清洁费都无法达成共识，又怎么可能一起站出来抵抗国家机器？\n\n国家、市场与个人之见的交易并不容易。国家和市场对于权力义务的划分意见不同，个人有抱怨这两者要得太多，又给得太少。很多时候，个人遭到市场的剥削，而国家不但不保护个人，反而还用军队、警察和官僚施加迫害。没人想得到，这种互动本身就有不少问题，更公然抵触过去世世代代的社会运作模式，竟然还是能够成功。经过数百万年的演化，人类的生活和思考方式都预设自己属于社群。但仅仅过了两个世纪，我们就成了互相疏远的个人。这可以说是文化力量的最佳证明。\n\n{% endblockquote %}\n\n{% blockquote P342 %}\n\n现代所兴起的两大想象社群，就是“民族”和“消费大众”。所谓民族，是国家的想象社群。而所谓消费大众，则是市场的想象社群。\n\n消费主义和民族主义可说是夙夜匪解，努力说服我们自己和其他数百万人是一伙的，认为我们有共同的过去、共同的利益以及共同的未来。这并不是谎言，而是一场想象。\n\n{% endblockquote %}\n\n### 第十七章 工业的巨轮\n\n### 第十八章 一场永远的革命\n\n### 第十九章 从此过着幸福快乐的日子\n\n### 第二十章 智人末日\n\n以上四章可供思辨的内容较多，就不再一一摘录。","slug":"rljs","published":1,"comments":1,"layout":"post","link":"","_id":"cjof51pjx0008rgueyozx92q4","content":"<p>经过5天的泛读后，初略的写下几点简单的读后感，并摘录了部分书中的观点。本书从不同的视角解读了人类的发展历史，解析了人类自身、人类与其他物种之间的关系及相互影响，并对于人类未来的发展方向提供了多个角度的思辨观点。很多观点都是之前我们未曾考虑或不愿直面的。以后还需要花更多的时间来精读此书。</p>\n<p><strong>读后感：</strong></p>\n<ol>\n<li>人类现行的法律、法规、权利、义务、货币、民族等等一切均由集体认可的集体想象而来。</li>\n<li>从许多小文化到少数大文化（帝国）再到最后的全球单一文化（帝国），应该是人类历史无法避免的结果。</li>\n<li>人类经过多次革命，已经摧毁或改变了地球上大部分的生物，最终可能也将摧毁自身。</li>\n<li>对于历史的研究，现在更多的只是研究了历史的表象，而缺少对于产生原因的多方位、深层次思考。</li>\n</ol>\n<p><strong>内容摘录：</strong></p>\n<h2 id=\"第一部分-认知革命\"><a href=\"#第一部分-认知革命\" class=\"headerlink\" title=\"第一部分 认知革命\"></a>第一部分 认知革命</h2><h3 id=\"第四章-毁天灭地的人类洪水\"><a href=\"#第四章-毁天灭地的人类洪水\" class=\"headerlink\" title=\"第四章 毁天灭地的人类洪水\"></a>第四章 毁天灭地的人类洪水</h3><blockquote><p>智人的第一波殖民正是整个动物界最大也是最快速的一场生态浩劫。其中受创最深的是那些大型、毛茸茸的动物。在认知革命发生的时候，地球上大约有200属体重超过50公斤的大型陆生哺乳动物。而等到农业革命的时候，只剩下大约100属。换句话说，甚至远在人类还没有发明轮子、文字和铁器之前，智人就已经让全球大约一半的大型兽类魂归西天、就此灭绝了。 </p>\n<footer><strong>P69</strong></footer></blockquote>\n<blockquote><p>第一波的灭绝浪潮是由于采集者的扩张，接着第二波灭绝浪潮则是因为农民的扩张；今日的第三波灭绝浪潮：由工业活动所造成的物种灭绝。对全世界上所有的大型动物来说，这场人类洪水的唯一幸存者可能只剩下人类自己，还有其他登上诺亚方舟但只作为人类盘中佳肴的家禽家畜。</p>\n<footer><strong>P70~P71</strong></footer></blockquote>\n<h2 id=\"第二部分-农业革命\"><a href=\"#第二部分-农业革命\" class=\"headerlink\" title=\"第二部分 农业革命\"></a>第二部分 农业革命</h2><h3 id=\"第五章-史上最大骗局\"><a href=\"#第五章-史上最大骗局\" class=\"headerlink\" title=\"第五章 史上最大骗局\"></a>第五章 史上最大骗局</h3><blockquote><p>农业革命让人类的食物总量增加，但量的增加并不代表吃得更好、过的更悠闲，反而只是造成人口爆炸，而且产生一群养尊处优、娇生惯养的精英分子。农业革命可以说是史上最大的一桩骗局。</p>\n<footer><strong>P77</strong></footer></blockquote>\n<blockquote><p>其实不是我们驯化了小麦，而是小麦驯化了我们。</p>\n<footer><strong>P78</strong></footer></blockquote>\n<blockquote><p><strong>革命的受害者</strong>  </p>\n<footer><strong>P88~P93</strong></footer></blockquote>\n<h3 id=\"第六章-盖起金字塔\"><a href=\"#第六章-盖起金字塔\" class=\"headerlink\" title=\"第六章 盖起金字塔\"></a>第六章 盖起金字塔</h3><blockquote><p>正是这些征收来的多余粮食，养活了政治、战争、艺术和哲学，建立起了宫殿、堡垒、纪念碑和庙宇。在现代晚期之前，总人口有九成以上是农民，日出而作、胼手胝足。他们生产出来的多余粮食养活了一小撮的精英份子：国王、官员、战士、牧师、艺术家和思想家，但历史写的几乎全是这些人的故事。于是，历史只告诉了我们极少数的人在做什么，而其他绝大多数人的生活就是不停地挑水耕田。 </p>\n<footer><strong>P98</strong></footer></blockquote>\n<h3 id=\"第八章-历史从无正义\"><a href=\"#第八章-历史从无正义\" class=\"headerlink\" title=\"第八章 历史从无正义\"></a>第八章 历史从无正义</h3><blockquote><p>就算身处不同阶级的人发展出了完全一样的能力，因为他们面对的游戏规则不同，最后结果也可能天差地别。这场游戏，其实早就被种种法律限制和潜规则束缚住了手脚，根本不知道公平在哪里。</p>\n<footer><strong>P133</strong></footer></blockquote>\n<h2 id=\"第三部分-人类的融合统一\"><a href=\"#第三部分-人类的融合统一\" class=\"headerlink\" title=\"第三部分 人类的融合统一\"></a>第三部分 人类的融合统一</h2><h3 id=\"第九章-历史的方向\"><a href=\"#第九章-历史的方向\" class=\"headerlink\" title=\"第九章 历史的方向\"></a>第九章 历史的方向</h3><blockquote><p>农业革命之后，人类社会规模变得更大、更复杂，而维系社会秩序的虚拟故事也更为细致完整。人类机会从出生到死亡都被种种虚构的故事和概念围绕，让他们以特定的方式思考，以特定的标准行事，想要特定的东西，也遵守特定的规范。就是这样，让数百万计的陌生人能遵照这种人造而非天生的直觉，合作无间。这种人造的直觉就是“文化“。 </p>\n<footer><strong>P157</strong></footer></blockquote>\n<h3 id=\"第十章-金钱的味道\"><a href=\"#第十章-金钱的味道\" class=\"headerlink\" title=\"第十章 金钱的味道\"></a>第十章 金钱的味道</h3><blockquote><p>千百年来，哲学家、思想家和宗教人物都对钱嗤之以鼻，称钱为万恶的根源。但就算真是如此，钱同时也是人类最能接受的东西。比起语言、法律、文化、宗教和社会习俗，钱的心胸更为开阔。所有人类创造的信念系统之中，只有金钱能够跨越几乎所有文化鸿沟，不会因为宗教、性别、种族、年龄或性取向而有所歧视。也多亏了有金钱制度，才让人就算互不认识，不清楚对方人品，也能携手合作。</p>\n<footer><strong>P178</strong></footer></blockquote>\n<h3 id=\"第十一章-帝国的愿景\"><a href=\"#第十一章-帝国的愿景\" class=\"headerlink\" title=\"第十一章 帝国的愿景\"></a>第十一章 帝国的愿景</h3><blockquote><p><img src=\"timg.jpg\" alt=\"\"></p>\n<p>泰姬·玛哈尔陵。究竟算是“纯正”的印度文化，还是外来的穆斯林帝国主义建筑？</p>\n<footer><strong>P197</strong></footer></blockquote>\n<h3 id=\"第十二章-宗教的法则\"><a href=\"#第十二章-宗教的法则\" class=\"headerlink\" title=\"第十二章 宗教的法则\"></a>第十二章 宗教的法则</h3><blockquote><p>在金钱和帝国之外，宗教是第三种让人类统一的力量。</p>\n<footer><strong>P199</strong></footer></blockquote>\n<h3 id=\"第十三章-成功的秘密\"><a href=\"#第十三章-成功的秘密\" class=\"headerlink\" title=\"第十三章 成功的秘密\"></a>第十三章 成功的秘密</h3><p>历史是所谓的“二级”混沌系统。</p>\n<h2 id=\"第四部分-科学革命\"><a href=\"#第四部分-科学革命\" class=\"headerlink\" title=\"第四部分 科学革命\"></a>第四部分 科学革命</h2><h3 id=\"第十四章-发现自己的无知\"><a href=\"#第十四章-发现自己的无知\" class=\"headerlink\" title=\"第十四章 发现自己的无知\"></a>第十四章 发现自己的无知</h3><blockquote><p>现代科学的基础就是拉丁文前缀”ignoramus-“，意为”我们不知道“。从这种立场，我们承认了自己并非无所不知。更重要的是，我们也愿意在知识进展之后，承认过去相信的可能是错的。于是，再也没有什么概念、想法或理论是神圣不可挑战的。</p>\n<footer><strong>P236</strong></footer></blockquote>\n<h3 id=\"第十五章-科学与帝国的联姻\"><a href=\"#第十五章-科学与帝国的联姻\" class=\"headerlink\" title=\"第十五章 科学与帝国的联姻\"></a>第十五章 科学与帝国的联姻</h3><blockquote><p>欧洲帝国主义和先前的所有帝国完全不同。过去的帝国主义者都认为自己已经了解了整个世界，“征服世界”只是为了要利用和传播他们自己对于世界的看法。相较之下，欧洲帝国主义之所以要前往遥远的彼岸，除了为了新领土，也是为了新知识。</p>\n<footer><strong>P266~P267</strong></footer></blockquote>\n<h3 id=\"第十六章-资本主义教条\"><a href=\"#第十六章-资本主义教条\" class=\"headerlink\" title=\"第十六章 资本主义教条\"></a>第十六章 资本主义教条</h3><blockquote><p>在《国富论》的第一卷第八章，亚当·斯密提出了一下的创新论述：如果地主、织工或鞋匠赚得的利润高于养家糊口基本所需，就会雇佣更多助手，好进一步提高自己的利润。利润越高，能雇的助手也越多。由此可见，民间企业的获利正是社会整体财富和繁荣的基础。</p>\n<footer><strong>P293</strong></footer></blockquote>\n<blockquote><p>所谓的“资本主义”（Capitalism），认为“资本”（capital）与“财富”（wealth）有所不同。资本指的是投入生产的各种金钱、物品和资源。而财富指的则是那些埋在地下或者浪费在非生产性活动的金钱、物品和资源。</p>\n<footer><strong>P294</strong></footer></blockquote>\n<blockquote><p>资本主义的基本原则在于，因为不论是正义、自由甚至快乐都必须依赖于经济成长，所以可以说经济成长就是至善（或至少十分接近）。</p>\n<p>科学家总能每隔几年就取得另一项发现，提出另一项发明。</p>\n<p>印钞票的是银行和政府，但最后埋单的是科学家。</p>\n<p>如果实验室的脚步不敌泡沫破灭的速度，可以想见经济前景就会令人十分担忧。</p>\n<footer><strong>P296~P297</strong></footer></blockquote>\n<p>资本主义与帝国的紧密关系。-东印度公司、鸦片战争。</p>\n<blockquote><p>西方政府几乎就像是资本家的工会。</p>\n<footer><strong>P306</strong></footer></blockquote>\n<blockquote><p>如果组成国家和市场的是一个又一个孤单的个人，而不是关系紧密的家庭或社群，要干预个人生活也就容易得多。现代高楼公寓，所有人各自锁在自己家里，连每户该付多少清洁费都无法达成共识，又怎么可能一起站出来抵抗国家机器？</p>\n<p>国家、市场与个人之见的交易并不容易。国家和市场对于权力义务的划分意见不同，个人有抱怨这两者要得太多，又给得太少。很多时候，个人遭到市场的剥削，而国家不但不保护个人，反而还用军队、警察和官僚施加迫害。没人想得到，这种互动本身就有不少问题，更公然抵触过去世世代代的社会运作模式，竟然还是能够成功。经过数百万年的演化，人类的生活和思考方式都预设自己属于社群。但仅仅过了两个世纪，我们就成了互相疏远的个人。这可以说是文化力量的最佳证明。</p>\n<footer><strong>P339~P340</strong></footer></blockquote>\n<blockquote><p>现代所兴起的两大想象社群，就是“民族”和“消费大众”。所谓民族，是国家的想象社群。而所谓消费大众，则是市场的想象社群。</p>\n<p>消费主义和民族主义可说是夙夜匪解，努力说服我们自己和其他数百万人是一伙的，认为我们有共同的过去、共同的利益以及共同的未来。这并不是谎言，而是一场想象。</p>\n<footer><strong>P342</strong></footer></blockquote>\n<h3 id=\"第十七章-工业的巨轮\"><a href=\"#第十七章-工业的巨轮\" class=\"headerlink\" title=\"第十七章 工业的巨轮\"></a>第十七章 工业的巨轮</h3><h3 id=\"第十八章-一场永远的革命\"><a href=\"#第十八章-一场永远的革命\" class=\"headerlink\" title=\"第十八章 一场永远的革命\"></a>第十八章 一场永远的革命</h3><h3 id=\"第十九章-从此过着幸福快乐的日子\"><a href=\"#第十九章-从此过着幸福快乐的日子\" class=\"headerlink\" title=\"第十九章 从此过着幸福快乐的日子\"></a>第十九章 从此过着幸福快乐的日子</h3><h3 id=\"第二十章-智人末日\"><a href=\"#第二十章-智人末日\" class=\"headerlink\" title=\"第二十章 智人末日\"></a>第二十章 智人末日</h3><p>以上四章可供思辨的内容较多，就不再一一摘录。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>经过5天的泛读后，初略的写下几点简单的读后感，并摘录了部分书中的观点。本书从不同的视角解读了人类的发展历史，解析了人类自身、人类与其他物种之间的关系及相互影响，并对于人类未来的发展方向提供了多个角度的思辨观点。很多观点都是之前我们未曾考虑或不愿直面的。以后还需要花更多的时间来精读此书。</p>\n<p><strong>读后感：</strong></p>\n<ol>\n<li>人类现行的法律、法规、权利、义务、货币、民族等等一切均由集体认可的集体想象而来。</li>\n<li>从许多小文化到少数大文化（帝国）再到最后的全球单一文化（帝国），应该是人类历史无法避免的结果。</li>\n<li>人类经过多次革命，已经摧毁或改变了地球上大部分的生物，最终可能也将摧毁自身。</li>\n<li>对于历史的研究，现在更多的只是研究了历史的表象，而缺少对于产生原因的多方位、深层次思考。</li>\n</ol>\n<p><strong>内容摘录：</strong></p>\n<h2 id=\"第一部分-认知革命\"><a href=\"#第一部分-认知革命\" class=\"headerlink\" title=\"第一部分 认知革命\"></a>第一部分 认知革命</h2><h3 id=\"第四章-毁天灭地的人类洪水\"><a href=\"#第四章-毁天灭地的人类洪水\" class=\"headerlink\" title=\"第四章 毁天灭地的人类洪水\"></a>第四章 毁天灭地的人类洪水</h3><blockquote><p>智人的第一波殖民正是整个动物界最大也是最快速的一场生态浩劫。其中受创最深的是那些大型、毛茸茸的动物。在认知革命发生的时候，地球上大约有200属体重超过50公斤的大型陆生哺乳动物。而等到农业革命的时候，只剩下大约100属。换句话说，甚至远在人类还没有发明轮子、文字和铁器之前，智人就已经让全球大约一半的大型兽类魂归西天、就此灭绝了。 </p>\n<footer><strong>P69</strong></footer></blockquote>\n<blockquote><p>第一波的灭绝浪潮是由于采集者的扩张，接着第二波灭绝浪潮则是因为农民的扩张；今日的第三波灭绝浪潮：由工业活动所造成的物种灭绝。对全世界上所有的大型动物来说，这场人类洪水的唯一幸存者可能只剩下人类自己，还有其他登上诺亚方舟但只作为人类盘中佳肴的家禽家畜。</p>\n<footer><strong>P70~P71</strong></footer></blockquote>\n<h2 id=\"第二部分-农业革命\"><a href=\"#第二部分-农业革命\" class=\"headerlink\" title=\"第二部分 农业革命\"></a>第二部分 农业革命</h2><h3 id=\"第五章-史上最大骗局\"><a href=\"#第五章-史上最大骗局\" class=\"headerlink\" title=\"第五章 史上最大骗局\"></a>第五章 史上最大骗局</h3><blockquote><p>农业革命让人类的食物总量增加，但量的增加并不代表吃得更好、过的更悠闲，反而只是造成人口爆炸，而且产生一群养尊处优、娇生惯养的精英分子。农业革命可以说是史上最大的一桩骗局。</p>\n<footer><strong>P77</strong></footer></blockquote>\n<blockquote><p>其实不是我们驯化了小麦，而是小麦驯化了我们。</p>\n<footer><strong>P78</strong></footer></blockquote>\n<blockquote><p><strong>革命的受害者</strong>  </p>\n<footer><strong>P88~P93</strong></footer></blockquote>\n<h3 id=\"第六章-盖起金字塔\"><a href=\"#第六章-盖起金字塔\" class=\"headerlink\" title=\"第六章 盖起金字塔\"></a>第六章 盖起金字塔</h3><blockquote><p>正是这些征收来的多余粮食，养活了政治、战争、艺术和哲学，建立起了宫殿、堡垒、纪念碑和庙宇。在现代晚期之前，总人口有九成以上是农民，日出而作、胼手胝足。他们生产出来的多余粮食养活了一小撮的精英份子：国王、官员、战士、牧师、艺术家和思想家，但历史写的几乎全是这些人的故事。于是，历史只告诉了我们极少数的人在做什么，而其他绝大多数人的生活就是不停地挑水耕田。 </p>\n<footer><strong>P98</strong></footer></blockquote>\n<h3 id=\"第八章-历史从无正义\"><a href=\"#第八章-历史从无正义\" class=\"headerlink\" title=\"第八章 历史从无正义\"></a>第八章 历史从无正义</h3><blockquote><p>就算身处不同阶级的人发展出了完全一样的能力，因为他们面对的游戏规则不同，最后结果也可能天差地别。这场游戏，其实早就被种种法律限制和潜规则束缚住了手脚，根本不知道公平在哪里。</p>\n<footer><strong>P133</strong></footer></blockquote>\n<h2 id=\"第三部分-人类的融合统一\"><a href=\"#第三部分-人类的融合统一\" class=\"headerlink\" title=\"第三部分 人类的融合统一\"></a>第三部分 人类的融合统一</h2><h3 id=\"第九章-历史的方向\"><a href=\"#第九章-历史的方向\" class=\"headerlink\" title=\"第九章 历史的方向\"></a>第九章 历史的方向</h3><blockquote><p>农业革命之后，人类社会规模变得更大、更复杂，而维系社会秩序的虚拟故事也更为细致完整。人类机会从出生到死亡都被种种虚构的故事和概念围绕，让他们以特定的方式思考，以特定的标准行事，想要特定的东西，也遵守特定的规范。就是这样，让数百万计的陌生人能遵照这种人造而非天生的直觉，合作无间。这种人造的直觉就是“文化“。 </p>\n<footer><strong>P157</strong></footer></blockquote>\n<h3 id=\"第十章-金钱的味道\"><a href=\"#第十章-金钱的味道\" class=\"headerlink\" title=\"第十章 金钱的味道\"></a>第十章 金钱的味道</h3><blockquote><p>千百年来，哲学家、思想家和宗教人物都对钱嗤之以鼻，称钱为万恶的根源。但就算真是如此，钱同时也是人类最能接受的东西。比起语言、法律、文化、宗教和社会习俗，钱的心胸更为开阔。所有人类创造的信念系统之中，只有金钱能够跨越几乎所有文化鸿沟，不会因为宗教、性别、种族、年龄或性取向而有所歧视。也多亏了有金钱制度，才让人就算互不认识，不清楚对方人品，也能携手合作。</p>\n<footer><strong>P178</strong></footer></blockquote>\n<h3 id=\"第十一章-帝国的愿景\"><a href=\"#第十一章-帝国的愿景\" class=\"headerlink\" title=\"第十一章 帝国的愿景\"></a>第十一章 帝国的愿景</h3><blockquote><p><img src=\"timg.jpg\" alt=\"\"></p>\n<p>泰姬·玛哈尔陵。究竟算是“纯正”的印度文化，还是外来的穆斯林帝国主义建筑？</p>\n<footer><strong>P197</strong></footer></blockquote>\n<h3 id=\"第十二章-宗教的法则\"><a href=\"#第十二章-宗教的法则\" class=\"headerlink\" title=\"第十二章 宗教的法则\"></a>第十二章 宗教的法则</h3><blockquote><p>在金钱和帝国之外，宗教是第三种让人类统一的力量。</p>\n<footer><strong>P199</strong></footer></blockquote>\n<h3 id=\"第十三章-成功的秘密\"><a href=\"#第十三章-成功的秘密\" class=\"headerlink\" title=\"第十三章 成功的秘密\"></a>第十三章 成功的秘密</h3><p>历史是所谓的“二级”混沌系统。</p>\n<h2 id=\"第四部分-科学革命\"><a href=\"#第四部分-科学革命\" class=\"headerlink\" title=\"第四部分 科学革命\"></a>第四部分 科学革命</h2><h3 id=\"第十四章-发现自己的无知\"><a href=\"#第十四章-发现自己的无知\" class=\"headerlink\" title=\"第十四章 发现自己的无知\"></a>第十四章 发现自己的无知</h3><blockquote><p>现代科学的基础就是拉丁文前缀”ignoramus-“，意为”我们不知道“。从这种立场，我们承认了自己并非无所不知。更重要的是，我们也愿意在知识进展之后，承认过去相信的可能是错的。于是，再也没有什么概念、想法或理论是神圣不可挑战的。</p>\n<footer><strong>P236</strong></footer></blockquote>\n<h3 id=\"第十五章-科学与帝国的联姻\"><a href=\"#第十五章-科学与帝国的联姻\" class=\"headerlink\" title=\"第十五章 科学与帝国的联姻\"></a>第十五章 科学与帝国的联姻</h3><blockquote><p>欧洲帝国主义和先前的所有帝国完全不同。过去的帝国主义者都认为自己已经了解了整个世界，“征服世界”只是为了要利用和传播他们自己对于世界的看法。相较之下，欧洲帝国主义之所以要前往遥远的彼岸，除了为了新领土，也是为了新知识。</p>\n<footer><strong>P266~P267</strong></footer></blockquote>\n<h3 id=\"第十六章-资本主义教条\"><a href=\"#第十六章-资本主义教条\" class=\"headerlink\" title=\"第十六章 资本主义教条\"></a>第十六章 资本主义教条</h3><blockquote><p>在《国富论》的第一卷第八章，亚当·斯密提出了一下的创新论述：如果地主、织工或鞋匠赚得的利润高于养家糊口基本所需，就会雇佣更多助手，好进一步提高自己的利润。利润越高，能雇的助手也越多。由此可见，民间企业的获利正是社会整体财富和繁荣的基础。</p>\n<footer><strong>P293</strong></footer></blockquote>\n<blockquote><p>所谓的“资本主义”（Capitalism），认为“资本”（capital）与“财富”（wealth）有所不同。资本指的是投入生产的各种金钱、物品和资源。而财富指的则是那些埋在地下或者浪费在非生产性活动的金钱、物品和资源。</p>\n<footer><strong>P294</strong></footer></blockquote>\n<blockquote><p>资本主义的基本原则在于，因为不论是正义、自由甚至快乐都必须依赖于经济成长，所以可以说经济成长就是至善（或至少十分接近）。</p>\n<p>科学家总能每隔几年就取得另一项发现，提出另一项发明。</p>\n<p>印钞票的是银行和政府，但最后埋单的是科学家。</p>\n<p>如果实验室的脚步不敌泡沫破灭的速度，可以想见经济前景就会令人十分担忧。</p>\n<footer><strong>P296~P297</strong></footer></blockquote>\n<p>资本主义与帝国的紧密关系。-东印度公司、鸦片战争。</p>\n<blockquote><p>西方政府几乎就像是资本家的工会。</p>\n<footer><strong>P306</strong></footer></blockquote>\n<blockquote><p>如果组成国家和市场的是一个又一个孤单的个人，而不是关系紧密的家庭或社群，要干预个人生活也就容易得多。现代高楼公寓，所有人各自锁在自己家里，连每户该付多少清洁费都无法达成共识，又怎么可能一起站出来抵抗国家机器？</p>\n<p>国家、市场与个人之见的交易并不容易。国家和市场对于权力义务的划分意见不同，个人有抱怨这两者要得太多，又给得太少。很多时候，个人遭到市场的剥削，而国家不但不保护个人，反而还用军队、警察和官僚施加迫害。没人想得到，这种互动本身就有不少问题，更公然抵触过去世世代代的社会运作模式，竟然还是能够成功。经过数百万年的演化，人类的生活和思考方式都预设自己属于社群。但仅仅过了两个世纪，我们就成了互相疏远的个人。这可以说是文化力量的最佳证明。</p>\n<footer><strong>P339~P340</strong></footer></blockquote>\n<blockquote><p>现代所兴起的两大想象社群，就是“民族”和“消费大众”。所谓民族，是国家的想象社群。而所谓消费大众，则是市场的想象社群。</p>\n<p>消费主义和民族主义可说是夙夜匪解，努力说服我们自己和其他数百万人是一伙的，认为我们有共同的过去、共同的利益以及共同的未来。这并不是谎言，而是一场想象。</p>\n<footer><strong>P342</strong></footer></blockquote>\n<h3 id=\"第十七章-工业的巨轮\"><a href=\"#第十七章-工业的巨轮\" class=\"headerlink\" title=\"第十七章 工业的巨轮\"></a>第十七章 工业的巨轮</h3><h3 id=\"第十八章-一场永远的革命\"><a href=\"#第十八章-一场永远的革命\" class=\"headerlink\" title=\"第十八章 一场永远的革命\"></a>第十八章 一场永远的革命</h3><h3 id=\"第十九章-从此过着幸福快乐的日子\"><a href=\"#第十九章-从此过着幸福快乐的日子\" class=\"headerlink\" title=\"第十九章 从此过着幸福快乐的日子\"></a>第十九章 从此过着幸福快乐的日子</h3><h3 id=\"第二十章-智人末日\"><a href=\"#第二十章-智人末日\" class=\"headerlink\" title=\"第二十章 智人末日\"></a>第二十章 智人末日</h3><p>以上四章可供思辨的内容较多，就不再一一摘录。</p>\n"},{"title":"一些个人常用的网站集合","description":"<!--more-->","updated":"2018-04-23T16:00:00.000Z","date":"2018-04-23T16:00:00.000Z","photos":["/2018/04/24/website/website.png"],"_content":"\n### Google\n\n[Google 代码风格指南](https://google.github.io/styleguide/)\n\n[Google 开发文档风格指南](https://developers.google.cn/style/)\n\n[Google Noto Fonts](https://www.google.com/get/noto/#sans-hans)\n\n[Google 开发者中文博客](http://developers.googleblog.cn/)\n\n[Google 开源项目风格指南 (中文版)](https://github.com/zh-google-styleguide/zh-google-styleguide)\n\n[Google Samples](https://github.com/googlesamples/?utf8=%E2%9C%93&query=)\n\n### Python\n\n[Napoleon Python 文档风格](https://sphinxcontrib-napoleon.readthedocs.io/en/latest/)\n\n[SPHINX Python 文档转换工具](http://www.sphinx-doc.org/en/master/)\n\n### Android\n\n[Gradle](https://developer.android.com/studio/build/index.html)\n\n[Android Samples](https://developer.android.com/samples/index.html)\n\n[Android培训课程中文版](http://hukai.me/android-training-course-in-chinese/)\n\n### .NET\n\n[.NET Framework 源码](https://referencesource.microsoft.com/)\n\n[.NET 类在不同版本下的区别](https://apisof.net/catalog)\n\n[.NET Standard](https://docs.microsoft.com/zh-cn/dotnet/standard/net-standard)\n\n[.NET Core](https://github.com/dotnet/core)\n\n[nuget](https://www.nuget.org/)\n\n[.NET 在线编译器](https://dotnetfiddle.net/#)\n\n[BenchmarkDotNet](http://benchmarkdotnet.org/)\n\n### 图标\n\n[IcoMoon](https://icomoon.io/)\n\n[https://icons8.com/](https://icons8.com/)\n\n[Font Awesome](https://fontawesome.com/)\n\n### TensorFlow\n\n[从源代码安装 TensorFlow](https://www.tensorflow.org/install/install_sources)\n\n[Deep Learning 中文翻译](https://github.com/exacity/deeplearningbook-chinese)\n\n[TensorFlow 官方网址](https://www.tensorflow.org/)\n\n### 素材\n\n[https://pxhere.com/](https://pxhere.com/)\n\n### 其他\n\n[在线画图](https://go.gliffy.com/go/html5/launch)","source":"_posts/website.md","raw":"---\ntitle: 一些个人常用的网站集合\ndescription: <!--more-->\nupdated: 2018-04-24\ndate: 2018-04-24\nphotos:\n - /2018/04/24/website/website.png\n---\n\n### Google\n\n[Google 代码风格指南](https://google.github.io/styleguide/)\n\n[Google 开发文档风格指南](https://developers.google.cn/style/)\n\n[Google Noto Fonts](https://www.google.com/get/noto/#sans-hans)\n\n[Google 开发者中文博客](http://developers.googleblog.cn/)\n\n[Google 开源项目风格指南 (中文版)](https://github.com/zh-google-styleguide/zh-google-styleguide)\n\n[Google Samples](https://github.com/googlesamples/?utf8=%E2%9C%93&query=)\n\n### Python\n\n[Napoleon Python 文档风格](https://sphinxcontrib-napoleon.readthedocs.io/en/latest/)\n\n[SPHINX Python 文档转换工具](http://www.sphinx-doc.org/en/master/)\n\n### Android\n\n[Gradle](https://developer.android.com/studio/build/index.html)\n\n[Android Samples](https://developer.android.com/samples/index.html)\n\n[Android培训课程中文版](http://hukai.me/android-training-course-in-chinese/)\n\n### .NET\n\n[.NET Framework 源码](https://referencesource.microsoft.com/)\n\n[.NET 类在不同版本下的区别](https://apisof.net/catalog)\n\n[.NET Standard](https://docs.microsoft.com/zh-cn/dotnet/standard/net-standard)\n\n[.NET Core](https://github.com/dotnet/core)\n\n[nuget](https://www.nuget.org/)\n\n[.NET 在线编译器](https://dotnetfiddle.net/#)\n\n[BenchmarkDotNet](http://benchmarkdotnet.org/)\n\n### 图标\n\n[IcoMoon](https://icomoon.io/)\n\n[https://icons8.com/](https://icons8.com/)\n\n[Font Awesome](https://fontawesome.com/)\n\n### TensorFlow\n\n[从源代码安装 TensorFlow](https://www.tensorflow.org/install/install_sources)\n\n[Deep Learning 中文翻译](https://github.com/exacity/deeplearningbook-chinese)\n\n[TensorFlow 官方网址](https://www.tensorflow.org/)\n\n### 素材\n\n[https://pxhere.com/](https://pxhere.com/)\n\n### 其他\n\n[在线画图](https://go.gliffy.com/go/html5/launch)","slug":"website","published":1,"comments":1,"layout":"post","link":"","_id":"cjof51pk1000brguecpokmzws","content":"<h3 id=\"Google\"><a href=\"#Google\" class=\"headerlink\" title=\"Google\"></a>Google</h3><p><a href=\"https://google.github.io/styleguide/\" target=\"_blank\" rel=\"noopener\">Google 代码风格指南</a></p>\n<p><a href=\"https://developers.google.cn/style/\" target=\"_blank\" rel=\"noopener\">Google 开发文档风格指南</a></p>\n<p><a href=\"https://www.google.com/get/noto/#sans-hans\" target=\"_blank\" rel=\"noopener\">Google Noto Fonts</a></p>\n<p><a href=\"http://developers.googleblog.cn/\" target=\"_blank\" rel=\"noopener\">Google 开发者中文博客</a></p>\n<p><a href=\"https://github.com/zh-google-styleguide/zh-google-styleguide\" target=\"_blank\" rel=\"noopener\">Google 开源项目风格指南 (中文版)</a></p>\n<p><a href=\"https://github.com/googlesamples/?utf8=%E2%9C%93&amp;query=\" target=\"_blank\" rel=\"noopener\">Google Samples</a></p>\n<h3 id=\"Python\"><a href=\"#Python\" class=\"headerlink\" title=\"Python\"></a>Python</h3><p><a href=\"https://sphinxcontrib-napoleon.readthedocs.io/en/latest/\" target=\"_blank\" rel=\"noopener\">Napoleon Python 文档风格</a></p>\n<p><a href=\"http://www.sphinx-doc.org/en/master/\" target=\"_blank\" rel=\"noopener\">SPHINX Python 文档转换工具</a></p>\n<h3 id=\"Android\"><a href=\"#Android\" class=\"headerlink\" title=\"Android\"></a>Android</h3><p><a href=\"https://developer.android.com/studio/build/index.html\" target=\"_blank\" rel=\"noopener\">Gradle</a></p>\n<p><a href=\"https://developer.android.com/samples/index.html\" target=\"_blank\" rel=\"noopener\">Android Samples</a></p>\n<p><a href=\"http://hukai.me/android-training-course-in-chinese/\" target=\"_blank\" rel=\"noopener\">Android培训课程中文版</a></p>\n<h3 id=\"NET\"><a href=\"#NET\" class=\"headerlink\" title=\".NET\"></a>.NET</h3><p><a href=\"https://referencesource.microsoft.com/\" target=\"_blank\" rel=\"noopener\">.NET Framework 源码</a></p>\n<p><a href=\"https://apisof.net/catalog\" target=\"_blank\" rel=\"noopener\">.NET 类在不同版本下的区别</a></p>\n<p><a href=\"https://docs.microsoft.com/zh-cn/dotnet/standard/net-standard\" target=\"_blank\" rel=\"noopener\">.NET Standard</a></p>\n<p><a href=\"https://github.com/dotnet/core\" target=\"_blank\" rel=\"noopener\">.NET Core</a></p>\n<p><a href=\"https://www.nuget.org/\" target=\"_blank\" rel=\"noopener\">nuget</a></p>\n<p><a href=\"https://dotnetfiddle.net/#\" target=\"_blank\" rel=\"noopener\">.NET 在线编译器</a></p>\n<p><a href=\"http://benchmarkdotnet.org/\" target=\"_blank\" rel=\"noopener\">BenchmarkDotNet</a></p>\n<h3 id=\"图标\"><a href=\"#图标\" class=\"headerlink\" title=\"图标\"></a>图标</h3><p><a href=\"https://icomoon.io/\" target=\"_blank\" rel=\"noopener\">IcoMoon</a></p>\n<p><a href=\"https://icons8.com/\" target=\"_blank\" rel=\"noopener\">https://icons8.com/</a></p>\n<p><a href=\"https://fontawesome.com/\" target=\"_blank\" rel=\"noopener\">Font Awesome</a></p>\n<h3 id=\"TensorFlow\"><a href=\"#TensorFlow\" class=\"headerlink\" title=\"TensorFlow\"></a>TensorFlow</h3><p><a href=\"https://www.tensorflow.org/install/install_sources\" target=\"_blank\" rel=\"noopener\">从源代码安装 TensorFlow</a></p>\n<p><a href=\"https://github.com/exacity/deeplearningbook-chinese\" target=\"_blank\" rel=\"noopener\">Deep Learning 中文翻译</a></p>\n<p><a href=\"https://www.tensorflow.org/\" target=\"_blank\" rel=\"noopener\">TensorFlow 官方网址</a></p>\n<h3 id=\"素材\"><a href=\"#素材\" class=\"headerlink\" title=\"素材\"></a>素材</h3><p><a href=\"https://pxhere.com/\" target=\"_blank\" rel=\"noopener\">https://pxhere.com/</a></p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><p><a href=\"https://go.gliffy.com/go/html5/launch\" target=\"_blank\" rel=\"noopener\">在线画图</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Google\"><a href=\"#Google\" class=\"headerlink\" title=\"Google\"></a>Google</h3><p><a href=\"https://google.github.io/styleguide/\" target=\"_blank\" rel=\"noopener\">Google 代码风格指南</a></p>\n<p><a href=\"https://developers.google.cn/style/\" target=\"_blank\" rel=\"noopener\">Google 开发文档风格指南</a></p>\n<p><a href=\"https://www.google.com/get/noto/#sans-hans\" target=\"_blank\" rel=\"noopener\">Google Noto Fonts</a></p>\n<p><a href=\"http://developers.googleblog.cn/\" target=\"_blank\" rel=\"noopener\">Google 开发者中文博客</a></p>\n<p><a href=\"https://github.com/zh-google-styleguide/zh-google-styleguide\" target=\"_blank\" rel=\"noopener\">Google 开源项目风格指南 (中文版)</a></p>\n<p><a href=\"https://github.com/googlesamples/?utf8=%E2%9C%93&amp;query=\" target=\"_blank\" rel=\"noopener\">Google Samples</a></p>\n<h3 id=\"Python\"><a href=\"#Python\" class=\"headerlink\" title=\"Python\"></a>Python</h3><p><a href=\"https://sphinxcontrib-napoleon.readthedocs.io/en/latest/\" target=\"_blank\" rel=\"noopener\">Napoleon Python 文档风格</a></p>\n<p><a href=\"http://www.sphinx-doc.org/en/master/\" target=\"_blank\" rel=\"noopener\">SPHINX Python 文档转换工具</a></p>\n<h3 id=\"Android\"><a href=\"#Android\" class=\"headerlink\" title=\"Android\"></a>Android</h3><p><a href=\"https://developer.android.com/studio/build/index.html\" target=\"_blank\" rel=\"noopener\">Gradle</a></p>\n<p><a href=\"https://developer.android.com/samples/index.html\" target=\"_blank\" rel=\"noopener\">Android Samples</a></p>\n<p><a href=\"http://hukai.me/android-training-course-in-chinese/\" target=\"_blank\" rel=\"noopener\">Android培训课程中文版</a></p>\n<h3 id=\"NET\"><a href=\"#NET\" class=\"headerlink\" title=\".NET\"></a>.NET</h3><p><a href=\"https://referencesource.microsoft.com/\" target=\"_blank\" rel=\"noopener\">.NET Framework 源码</a></p>\n<p><a href=\"https://apisof.net/catalog\" target=\"_blank\" rel=\"noopener\">.NET 类在不同版本下的区别</a></p>\n<p><a href=\"https://docs.microsoft.com/zh-cn/dotnet/standard/net-standard\" target=\"_blank\" rel=\"noopener\">.NET Standard</a></p>\n<p><a href=\"https://github.com/dotnet/core\" target=\"_blank\" rel=\"noopener\">.NET Core</a></p>\n<p><a href=\"https://www.nuget.org/\" target=\"_blank\" rel=\"noopener\">nuget</a></p>\n<p><a href=\"https://dotnetfiddle.net/#\" target=\"_blank\" rel=\"noopener\">.NET 在线编译器</a></p>\n<p><a href=\"http://benchmarkdotnet.org/\" target=\"_blank\" rel=\"noopener\">BenchmarkDotNet</a></p>\n<h3 id=\"图标\"><a href=\"#图标\" class=\"headerlink\" title=\"图标\"></a>图标</h3><p><a href=\"https://icomoon.io/\" target=\"_blank\" rel=\"noopener\">IcoMoon</a></p>\n<p><a href=\"https://icons8.com/\" target=\"_blank\" rel=\"noopener\">https://icons8.com/</a></p>\n<p><a href=\"https://fontawesome.com/\" target=\"_blank\" rel=\"noopener\">Font Awesome</a></p>\n<h3 id=\"TensorFlow\"><a href=\"#TensorFlow\" class=\"headerlink\" title=\"TensorFlow\"></a>TensorFlow</h3><p><a href=\"https://www.tensorflow.org/install/install_sources\" target=\"_blank\" rel=\"noopener\">从源代码安装 TensorFlow</a></p>\n<p><a href=\"https://github.com/exacity/deeplearningbook-chinese\" target=\"_blank\" rel=\"noopener\">Deep Learning 中文翻译</a></p>\n<p><a href=\"https://www.tensorflow.org/\" target=\"_blank\" rel=\"noopener\">TensorFlow 官方网址</a></p>\n<h3 id=\"素材\"><a href=\"#素材\" class=\"headerlink\" title=\"素材\"></a>素材</h3><p><a href=\"https://pxhere.com/\" target=\"_blank\" rel=\"noopener\">https://pxhere.com/</a></p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><p><a href=\"https://go.gliffy.com/go/html5/launch\" target=\"_blank\" rel=\"noopener\">在线画图</a></p>\n"},{"title":"机器学习开放课程：三、分类、决策树和K近邻","date":"2018-10-22T06:07:13.000Z","updated":"2018-10-25T16:00:00.000Z","typora-root-url":"机器学习开放课程：三、分类、决策树和K近邻","mathjax":true,"description":"<!—more—->","_content":"\n### 三、分类、决策树和K近邻\n\n[机器学习开放课程：三、分类、决策树和K近邻](https://www.jqr.com/article/000139)\n\n#### 决策树\n\n##### [熵 (信息论)](https://zh.wikipedia.org/wiki/%E7%86%B5_(%E4%BF%A1%E6%81%AF%E8%AE%BA))\n\n**熵最好理解为不确定性的量度而不是确定性的量度，因为越随机的信源的熵越大。**\n\n**在信息论里面，熵是对不确定性的测量。但是在信息世界，熵越高，则能传输越多的信息，熵越低，则意味着传输的信息越少。熵的下降称为信息增益。**\n\n假如我在不知情的情况下问某一届世界杯冠军是谁，而知道的人不愿意直接告诉我，而是让我猜，猜一次一块钱。为了省钱可以为所有的参赛队伍编号1~32，然后提问：“冠军队伍在1~16号之间吗？“假如他告诉我猜对了，我就会接着问：”冠军队伍在1~8号之间吗？“假如他告诉我猜错了，我自然知道冠军队伍在9~16号之间。这样只需要5次，就知道哪支球队是冠军了。\n\n$$-\\log({1 \\over 32})=5$$\n\n当然，有可能也用不了5次，因为总有些热门球队的夺冠概率会比较高，所以只需要把夺冠概率高的分在一组，正常情况下就会用更少的次数猜出结果。\n\n$$H=-(P_{1}\\log(P_{1})+P_{2}\\log(P_{2})+ \\cdots +P_{32}\\log(P_{32}))$$\n\n其中$$P{1},P{2},\\cdots,P{32}$$分别是这32支球队的夺冠概率。\n\n对于任意一个随机变量$$X$$，它的熵定义如下：\n\n$$H_{s}=-\\sum_{i=1}^{n}P_{i}\\log\\left (P_{i} \\right )$$\n\n英语文本数据流的熵比较低，因为英语很容易读懂，也就是说很容易被预测。即便我们不知道下一段英语文字是什么内容，但是我们能很容易地预测，比如，字母e总是比字母z多，或者qu字母组合的可能性总是超过q与任何其它字母的组合。如果未经压缩，一段英文文本的每个字母需要8个比特来编码，但是实际上英文文本的熵大概只有4.7比特。\n\n如英语有26个字母，假如每个字母在文章中出现次数平均的话，每个字母的讯息量为：\n\n$$I_{e}=-\\log\\left (1\\over26 \\right )=4.7$$\n\nExcel公式：=$$-LOG(1/26,2)$$\n\n##### [C4.5算法](https://zh.wikipedia.org/wiki/C4.5%E7%AE%97%E6%B3%95)\n\nC4.5算法是由Ross Quinlan开发的用于产生决策树的算法。该算法是对Ross Quinlan之前开发的ID3算法的一个扩展。C4.5算法产生的决策树可以被用作分类目的，因此该算法也可以用于统计分类。\n\n是贪婪最大化信息增益：在每一步，算法选择能在分割后给出最大信息增益的变量。接着递归重复这一流程，直到熵为零（或者，为了避免过拟合，直到熵为某个较小的值）。\n\n##### [基尼不纯度](https://zh.wikipedia.org/wiki/%E5%86%B3%E7%AD%96%E6%A0%91%E5%AD%A6%E4%B9%A0#%E5%9F%BA%E5%B0%BC%E4%B8%8D%E7%BA%AF%E5%BA%A6%E6%8C%87%E6%A0%87)\n\n基尼不纯度表示一个随机选中的样本在子集中被分错的可能性。基尼不纯度为这个样本被选中的概率乘以它被分错的概率。当一个节点中所有样本都是一个类时，基尼不纯度为零。\n\n\n基尼不纯度的大概意思是**一个随机事件变成它的对立事件的概率**。\n\n**基尼不确定性和信息增益的效果差不多。**\n\n##### 决策树示例\n\n下面使用决策树分析患者的检查结果来分析心血管疾病(CVD)的存在是否有关系。\n\n数据来源：[mlbootcamp5_train.csv](mlbootcamp5_train.csv)\n\n相关类及方法：\n\n* [sklearn.tree.DecisionTreeClassifier](http://scikit-learn.org/stable/modules/generated/sklearn.tree.DecisionTreeClassifier.html#sklearn-tree-decisiontreeclassifier) 决策树分类器\n* [sklearn.tree.DecisionTreeClassifier.fit](http://scikit-learn.org/stable/modules/generated/sklearn.tree.DecisionTreeClassifier.html#sklearn.tree.DecisionTreeClassifier.fit) 使用数据填充决策树分类器\n* [sklearn.tree.DecisionTreeClassifier.predict](http://scikit-learn.org/stable/modules/generated/sklearn.tree.DecisionTreeClassifier.html#sklearn.tree.DecisionTreeClassifier.predict) 回归测试准确率\n* [sklearn.metrics.accuracy_score](http://scikit-learn.org/stable/modules/generated/sklearn.metrics.accuracy_score.html) 计算分类得分\n* [sklearn.tree.export_graphviz](http://scikit-learn.org/stable/modules/generated/sklearn.tree.export_graphviz.html)\n\n| 特征                                          |                    | 特征类型 | 列名        | 列数据类型                                       |\n| --------------------------------------------- | ------------------ | -------- | ----------- | ------------------------------------------------ |\n| Age                                           | 年龄               | 客观特征 | age         | int (days)                                       |\n| Height                                        | 身高               | 客观特征 | height      | int (cm)                                         |\n| Weight                                        | 体重               | 客观特征 | weight      | float (kg)                                       |\n| Gender                                        | 性别               | 客观特征 | gender      | categorical code （1 – woman, 2 – man）          |\n| Systolic blood pressure                       | 收缩压             | 检查特征 | ap_hi       | int                                              |\n| Diastolic blood pressure                      | 舒张压             | 检查特征 | ap_lo       | int                                              |\n| Cholesterol                                   | 胆固醇             | 检查特征 | cholesterol | 1: normal, 2: above normal, 3: well above normal |\n| Glucose                                       | 葡萄糖             | 检查特征 | gluc        | 1: normal, 2: above normal, 3: well above normal |\n| Smoking                                       | 是否吸烟           | 主观特征 | smoke       | binary                                           |\n| Alcohol intake                                | 是否喝酒           | 主观特征 | alco        | binary                                           |\n| Physical activity                             | 体力劳动           | 主观特征 | active      | binary                                           |\n| Presence or absence of cardiovascular disease | 是否存在心血管疾病 | 目标特征 | cardio      | binary                                           |\n\n> 以下代码需要：\n>\n> - pandas\n> - sklearn\n> - [graphviz](https://www.graphviz.org/) *对于windows环境来说，需要将安装目录中的bin目录添加至环境变量中。*\n> - pydotplus *先安装 graphviz*\n\n```python\nfrom io import BytesIO\nfrom io import StringIO\nimport pandas as pd\nimport pydotplus\nfrom PIL import Image\nfrom sklearn.metrics import accuracy_score\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.tree import export_graphviz\n\n\ndef S(X, Y, criterion='gini'):\n    \"\"\"显示决策树的决策过程的方法\n\n    :param X: 训练集。\n    :param Y: 结果集。\n    :param criterion: 衡量指标。与 `sklearn.tree.DecisionTreeClassifier` 一致。默认为 `gini`。 也可以使用 `entropy`。\n    :return:\n    \"\"\"\n    # 以深度为3层来创建决策树分类器\n    tree_model = DecisionTreeClassifier(criterion=criterion, max_depth=3)\n    # 从训练集（X，y）构建决策树分类器。\n    tree_model.fit(X, Y)\n    return tree_model\n\n\ndef showImg(tree, feature_names=None):\n    \"\"\"显示决策树\"\"\"\n    dot_data = StringIO()\n    # 导出决策树为 DOT 格式\n    export_graphviz(tree, feature_names=feature_names, out_file=dot_data, filled=True)\n    graph = pydotplus.graph_from_dot_data(dot_data.getvalue())\n    image = Image.open(BytesIO(graph.create_png()))\n    image.show()\n\nif __name__ == '__main__':\n    df = pd.read_csv('mlbootcamp5_train.csv', index_col='id', sep=';')\n\n    # # 使用sklearn.model_selection.train_test_split将数据拆分成训练集和测试集\n    # # 使用3/7比率\n    X_train, X_valid, Y_train, Y_valid = train_test_split(df.drop(columns=['cardio']), df['cardio'], test_size=0.3)\n\n    # 按照 基尼不纯度 分割的决策树\n    tree_gini = S(X_train, Y_train);\n    # 按照 信息熵 分割的决策树\n    tree_entropy = S(X_train, Y_train, 'entropy')\n\n    showImg(tree_gini, X_train.columns)\n    showImg(tree_entropy, X_train.columns)\n```\n\n* 按照基尼不纯度分割：\n\n![NZXca6g](NZXca6g.png)\n\n* 按照信息熵分割：\n\n![3VT+hGyI](3VT+hGyI.png)\n\n无论按照哪种方式分割，都可以看到，随着叶子节点的不断展开，基尼不纯度或者信息熵都会不断下降。\n\n计算分类回归准确率：\n\n```python\ndef V(tree, X, Y):\n    \"\"\"验证结果准确度\"\"\"\n    y_pred = tree.predict(X)\n    return accuracy_score(y_pred=y_pred, y_true=Y)\n    \n    \nif __name__ == '__main__':\n    print(V(tree_gini, X_valid, Y_valid))\n    print(V(tree_entropy, X_valid, Y_valid))\n```\n\n```\n0.7282857142857143\n0.7269047619047619\n```\n\n\n\n##### 过拟合\n\n最常见的应对过拟合决策树的方式为：\n\n- 人工限制深度或叶节点的最少样本数：达到限制时停止树的构造。\n- 对树进行剪枝。\n\n`sklearn.tree.DecisionTreeClassifier`类的主要参数为：\n\n- `max_depth` 树的最大深度；\n- `max_features` 搜索最佳分区时的最大特征数（特征很多时，设置这个参数很有必要，因为基于**所有**特征搜索分区会很“昂贵”）；\n- `min_samples_leaf` 叶节点的最少样本数。该参数防止创建任何叶节点只有很少成员的树。\n\n##### [最近邻居法](https://zh.wikipedia.org/wiki/%E6%9C%80%E8%BF%91%E9%84%B0%E5%B1%85%E6%B3%95)\n\n","source":"_posts/机器学习开放课程：三、分类、决策树和K近邻.md","raw":"---\ntitle: 机器学习开放课程：三、分类、决策树和K近邻\ndate: 2018-10-22 14:07:13\nupdated: 2018-10-26\ntags:\n - 编程\n - Python\n - 机器学习\n - 决策树\n - K近邻\n - 熵\ncategories:\n - 编程\n - Python\n - 机器学习\ntypora-root-url: 机器学习开放课程：三、分类、决策树和K近邻\nmathjax: true\ndescription: <!—more—->\n---\n\n### 三、分类、决策树和K近邻\n\n[机器学习开放课程：三、分类、决策树和K近邻](https://www.jqr.com/article/000139)\n\n#### 决策树\n\n##### [熵 (信息论)](https://zh.wikipedia.org/wiki/%E7%86%B5_(%E4%BF%A1%E6%81%AF%E8%AE%BA))\n\n**熵最好理解为不确定性的量度而不是确定性的量度，因为越随机的信源的熵越大。**\n\n**在信息论里面，熵是对不确定性的测量。但是在信息世界，熵越高，则能传输越多的信息，熵越低，则意味着传输的信息越少。熵的下降称为信息增益。**\n\n假如我在不知情的情况下问某一届世界杯冠军是谁，而知道的人不愿意直接告诉我，而是让我猜，猜一次一块钱。为了省钱可以为所有的参赛队伍编号1~32，然后提问：“冠军队伍在1~16号之间吗？“假如他告诉我猜对了，我就会接着问：”冠军队伍在1~8号之间吗？“假如他告诉我猜错了，我自然知道冠军队伍在9~16号之间。这样只需要5次，就知道哪支球队是冠军了。\n\n$$-\\log({1 \\over 32})=5$$\n\n当然，有可能也用不了5次，因为总有些热门球队的夺冠概率会比较高，所以只需要把夺冠概率高的分在一组，正常情况下就会用更少的次数猜出结果。\n\n$$H=-(P_{1}\\log(P_{1})+P_{2}\\log(P_{2})+ \\cdots +P_{32}\\log(P_{32}))$$\n\n其中$$P{1},P{2},\\cdots,P{32}$$分别是这32支球队的夺冠概率。\n\n对于任意一个随机变量$$X$$，它的熵定义如下：\n\n$$H_{s}=-\\sum_{i=1}^{n}P_{i}\\log\\left (P_{i} \\right )$$\n\n英语文本数据流的熵比较低，因为英语很容易读懂，也就是说很容易被预测。即便我们不知道下一段英语文字是什么内容，但是我们能很容易地预测，比如，字母e总是比字母z多，或者qu字母组合的可能性总是超过q与任何其它字母的组合。如果未经压缩，一段英文文本的每个字母需要8个比特来编码，但是实际上英文文本的熵大概只有4.7比特。\n\n如英语有26个字母，假如每个字母在文章中出现次数平均的话，每个字母的讯息量为：\n\n$$I_{e}=-\\log\\left (1\\over26 \\right )=4.7$$\n\nExcel公式：=$$-LOG(1/26,2)$$\n\n##### [C4.5算法](https://zh.wikipedia.org/wiki/C4.5%E7%AE%97%E6%B3%95)\n\nC4.5算法是由Ross Quinlan开发的用于产生决策树的算法。该算法是对Ross Quinlan之前开发的ID3算法的一个扩展。C4.5算法产生的决策树可以被用作分类目的，因此该算法也可以用于统计分类。\n\n是贪婪最大化信息增益：在每一步，算法选择能在分割后给出最大信息增益的变量。接着递归重复这一流程，直到熵为零（或者，为了避免过拟合，直到熵为某个较小的值）。\n\n##### [基尼不纯度](https://zh.wikipedia.org/wiki/%E5%86%B3%E7%AD%96%E6%A0%91%E5%AD%A6%E4%B9%A0#%E5%9F%BA%E5%B0%BC%E4%B8%8D%E7%BA%AF%E5%BA%A6%E6%8C%87%E6%A0%87)\n\n基尼不纯度表示一个随机选中的样本在子集中被分错的可能性。基尼不纯度为这个样本被选中的概率乘以它被分错的概率。当一个节点中所有样本都是一个类时，基尼不纯度为零。\n\n\n基尼不纯度的大概意思是**一个随机事件变成它的对立事件的概率**。\n\n**基尼不确定性和信息增益的效果差不多。**\n\n##### 决策树示例\n\n下面使用决策树分析患者的检查结果来分析心血管疾病(CVD)的存在是否有关系。\n\n数据来源：[mlbootcamp5_train.csv](mlbootcamp5_train.csv)\n\n相关类及方法：\n\n* [sklearn.tree.DecisionTreeClassifier](http://scikit-learn.org/stable/modules/generated/sklearn.tree.DecisionTreeClassifier.html#sklearn-tree-decisiontreeclassifier) 决策树分类器\n* [sklearn.tree.DecisionTreeClassifier.fit](http://scikit-learn.org/stable/modules/generated/sklearn.tree.DecisionTreeClassifier.html#sklearn.tree.DecisionTreeClassifier.fit) 使用数据填充决策树分类器\n* [sklearn.tree.DecisionTreeClassifier.predict](http://scikit-learn.org/stable/modules/generated/sklearn.tree.DecisionTreeClassifier.html#sklearn.tree.DecisionTreeClassifier.predict) 回归测试准确率\n* [sklearn.metrics.accuracy_score](http://scikit-learn.org/stable/modules/generated/sklearn.metrics.accuracy_score.html) 计算分类得分\n* [sklearn.tree.export_graphviz](http://scikit-learn.org/stable/modules/generated/sklearn.tree.export_graphviz.html)\n\n| 特征                                          |                    | 特征类型 | 列名        | 列数据类型                                       |\n| --------------------------------------------- | ------------------ | -------- | ----------- | ------------------------------------------------ |\n| Age                                           | 年龄               | 客观特征 | age         | int (days)                                       |\n| Height                                        | 身高               | 客观特征 | height      | int (cm)                                         |\n| Weight                                        | 体重               | 客观特征 | weight      | float (kg)                                       |\n| Gender                                        | 性别               | 客观特征 | gender      | categorical code （1 – woman, 2 – man）          |\n| Systolic blood pressure                       | 收缩压             | 检查特征 | ap_hi       | int                                              |\n| Diastolic blood pressure                      | 舒张压             | 检查特征 | ap_lo       | int                                              |\n| Cholesterol                                   | 胆固醇             | 检查特征 | cholesterol | 1: normal, 2: above normal, 3: well above normal |\n| Glucose                                       | 葡萄糖             | 检查特征 | gluc        | 1: normal, 2: above normal, 3: well above normal |\n| Smoking                                       | 是否吸烟           | 主观特征 | smoke       | binary                                           |\n| Alcohol intake                                | 是否喝酒           | 主观特征 | alco        | binary                                           |\n| Physical activity                             | 体力劳动           | 主观特征 | active      | binary                                           |\n| Presence or absence of cardiovascular disease | 是否存在心血管疾病 | 目标特征 | cardio      | binary                                           |\n\n> 以下代码需要：\n>\n> - pandas\n> - sklearn\n> - [graphviz](https://www.graphviz.org/) *对于windows环境来说，需要将安装目录中的bin目录添加至环境变量中。*\n> - pydotplus *先安装 graphviz*\n\n```python\nfrom io import BytesIO\nfrom io import StringIO\nimport pandas as pd\nimport pydotplus\nfrom PIL import Image\nfrom sklearn.metrics import accuracy_score\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.tree import export_graphviz\n\n\ndef S(X, Y, criterion='gini'):\n    \"\"\"显示决策树的决策过程的方法\n\n    :param X: 训练集。\n    :param Y: 结果集。\n    :param criterion: 衡量指标。与 `sklearn.tree.DecisionTreeClassifier` 一致。默认为 `gini`。 也可以使用 `entropy`。\n    :return:\n    \"\"\"\n    # 以深度为3层来创建决策树分类器\n    tree_model = DecisionTreeClassifier(criterion=criterion, max_depth=3)\n    # 从训练集（X，y）构建决策树分类器。\n    tree_model.fit(X, Y)\n    return tree_model\n\n\ndef showImg(tree, feature_names=None):\n    \"\"\"显示决策树\"\"\"\n    dot_data = StringIO()\n    # 导出决策树为 DOT 格式\n    export_graphviz(tree, feature_names=feature_names, out_file=dot_data, filled=True)\n    graph = pydotplus.graph_from_dot_data(dot_data.getvalue())\n    image = Image.open(BytesIO(graph.create_png()))\n    image.show()\n\nif __name__ == '__main__':\n    df = pd.read_csv('mlbootcamp5_train.csv', index_col='id', sep=';')\n\n    # # 使用sklearn.model_selection.train_test_split将数据拆分成训练集和测试集\n    # # 使用3/7比率\n    X_train, X_valid, Y_train, Y_valid = train_test_split(df.drop(columns=['cardio']), df['cardio'], test_size=0.3)\n\n    # 按照 基尼不纯度 分割的决策树\n    tree_gini = S(X_train, Y_train);\n    # 按照 信息熵 分割的决策树\n    tree_entropy = S(X_train, Y_train, 'entropy')\n\n    showImg(tree_gini, X_train.columns)\n    showImg(tree_entropy, X_train.columns)\n```\n\n* 按照基尼不纯度分割：\n\n![NZXca6g](NZXca6g.png)\n\n* 按照信息熵分割：\n\n![3VT+hGyI](3VT+hGyI.png)\n\n无论按照哪种方式分割，都可以看到，随着叶子节点的不断展开，基尼不纯度或者信息熵都会不断下降。\n\n计算分类回归准确率：\n\n```python\ndef V(tree, X, Y):\n    \"\"\"验证结果准确度\"\"\"\n    y_pred = tree.predict(X)\n    return accuracy_score(y_pred=y_pred, y_true=Y)\n    \n    \nif __name__ == '__main__':\n    print(V(tree_gini, X_valid, Y_valid))\n    print(V(tree_entropy, X_valid, Y_valid))\n```\n\n```\n0.7282857142857143\n0.7269047619047619\n```\n\n\n\n##### 过拟合\n\n最常见的应对过拟合决策树的方式为：\n\n- 人工限制深度或叶节点的最少样本数：达到限制时停止树的构造。\n- 对树进行剪枝。\n\n`sklearn.tree.DecisionTreeClassifier`类的主要参数为：\n\n- `max_depth` 树的最大深度；\n- `max_features` 搜索最佳分区时的最大特征数（特征很多时，设置这个参数很有必要，因为基于**所有**特征搜索分区会很“昂贵”）；\n- `min_samples_leaf` 叶节点的最少样本数。该参数防止创建任何叶节点只有很少成员的树。\n\n##### [最近邻居法](https://zh.wikipedia.org/wiki/%E6%9C%80%E8%BF%91%E9%84%B0%E5%B1%85%E6%B3%95)\n\n","slug":"机器学习开放课程：三、分类、决策树和K近邻","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cjof51pk3000crgueiz9o2yem","content":"<h3 id=\"三、分类、决策树和K近邻\"><a href=\"#三、分类、决策树和K近邻\" class=\"headerlink\" title=\"三、分类、决策树和K近邻\"></a>三、分类、决策树和K近邻</h3><p><a href=\"https://www.jqr.com/article/000139\" target=\"_blank\" rel=\"noopener\">机器学习开放课程：三、分类、决策树和K近邻</a></p>\n<h4 id=\"决策树\"><a href=\"#决策树\" class=\"headerlink\" title=\"决策树\"></a>决策树</h4><h5 id=\"熵-信息论\"><a href=\"#熵-信息论\" class=\"headerlink\" title=\"熵 (信息论))\"></a><a href=\"https://zh.wikipedia.org/wiki/%E7%86%B5_(%E4%BF%A1%E6%81%AF%E8%AE%BA\" target=\"_blank\" rel=\"noopener\">熵 (信息论)</a>)</h5><p><strong>熵最好理解为不确定性的量度而不是确定性的量度，因为越随机的信源的熵越大。</strong></p>\n<p><strong>在信息论里面，熵是对不确定性的测量。但是在信息世界，熵越高，则能传输越多的信息，熵越低，则意味着传输的信息越少。熵的下降称为信息增益。</strong></p>\n<p>假如我在不知情的情况下问某一届世界杯冠军是谁，而知道的人不愿意直接告诉我，而是让我猜，猜一次一块钱。为了省钱可以为所有的参赛队伍编号1~32，然后提问：“冠军队伍在1~16号之间吗？“假如他告诉我猜对了，我就会接着问：”冠军队伍在1~8号之间吗？“假如他告诉我猜错了，我自然知道冠军队伍在9~16号之间。这样只需要5次，就知道哪支球队是冠军了。</p>\n<p>$$-\\log({1 \\over 32})=5$$</p>\n<p>当然，有可能也用不了5次，因为总有些热门球队的夺冠概率会比较高，所以只需要把夺冠概率高的分在一组，正常情况下就会用更少的次数猜出结果。</p>\n<p>$$H=-(P_{1}\\log(P_{1})+P_{2}\\log(P_{2})+ \\cdots +P_{32}\\log(P_{32}))$$</p>\n<p>其中$$P{1},P{2},\\cdots,P{32}$$分别是这32支球队的夺冠概率。</p>\n<p>对于任意一个随机变量$$X$$，它的熵定义如下：</p>\n<p>$$H_{s}=-\\sum_{i=1}^{n}P_{i}\\log\\left (P_{i} \\right )$$</p>\n<p>英语文本数据流的熵比较低，因为英语很容易读懂，也就是说很容易被预测。即便我们不知道下一段英语文字是什么内容，但是我们能很容易地预测，比如，字母e总是比字母z多，或者qu字母组合的可能性总是超过q与任何其它字母的组合。如果未经压缩，一段英文文本的每个字母需要8个比特来编码，但是实际上英文文本的熵大概只有4.7比特。</p>\n<p>如英语有26个字母，假如每个字母在文章中出现次数平均的话，每个字母的讯息量为：</p>\n<p>$$I_{e}=-\\log\\left (1\\over26 \\right )=4.7$$</p>\n<p>Excel公式：=$$-LOG(1/26,2)$$</p>\n<h5 id=\"C4-5算法\"><a href=\"#C4-5算法\" class=\"headerlink\" title=\"C4.5算法\"></a><a href=\"https://zh.wikipedia.org/wiki/C4.5%E7%AE%97%E6%B3%95\" target=\"_blank\" rel=\"noopener\">C4.5算法</a></h5><p>C4.5算法是由Ross Quinlan开发的用于产生决策树的算法。该算法是对Ross Quinlan之前开发的ID3算法的一个扩展。C4.5算法产生的决策树可以被用作分类目的，因此该算法也可以用于统计分类。</p>\n<p>是贪婪最大化信息增益：在每一步，算法选择能在分割后给出最大信息增益的变量。接着递归重复这一流程，直到熵为零（或者，为了避免过拟合，直到熵为某个较小的值）。</p>\n<h5 id=\"基尼不纯度\"><a href=\"#基尼不纯度\" class=\"headerlink\" title=\"基尼不纯度\"></a><a href=\"https://zh.wikipedia.org/wiki/%E5%86%B3%E7%AD%96%E6%A0%91%E5%AD%A6%E4%B9%A0#%E5%9F%BA%E5%B0%BC%E4%B8%8D%E7%BA%AF%E5%BA%A6%E6%8C%87%E6%A0%87\" target=\"_blank\" rel=\"noopener\">基尼不纯度</a></h5><p>基尼不纯度表示一个随机选中的样本在子集中被分错的可能性。基尼不纯度为这个样本被选中的概率乘以它被分错的概率。当一个节点中所有样本都是一个类时，基尼不纯度为零。</p>\n<p>基尼不纯度的大概意思是<strong>一个随机事件变成它的对立事件的概率</strong>。</p>\n<p><strong>基尼不确定性和信息增益的效果差不多。</strong></p>\n<h5 id=\"决策树示例\"><a href=\"#决策树示例\" class=\"headerlink\" title=\"决策树示例\"></a>决策树示例</h5><p>下面使用决策树分析患者的检查结果来分析心血管疾病(CVD)的存在是否有关系。</p>\n<p>数据来源：<a href=\"mlbootcamp5_train.csv\">mlbootcamp5_train.csv</a></p>\n<p>相关类及方法：</p>\n<ul>\n<li><a href=\"http://scikit-learn.org/stable/modules/generated/sklearn.tree.DecisionTreeClassifier.html#sklearn-tree-decisiontreeclassifier\" target=\"_blank\" rel=\"noopener\">sklearn.tree.DecisionTreeClassifier</a> 决策树分类器</li>\n<li><a href=\"http://scikit-learn.org/stable/modules/generated/sklearn.tree.DecisionTreeClassifier.html#sklearn.tree.DecisionTreeClassifier.fit\" target=\"_blank\" rel=\"noopener\">sklearn.tree.DecisionTreeClassifier.fit</a> 使用数据填充决策树分类器</li>\n<li><a href=\"http://scikit-learn.org/stable/modules/generated/sklearn.tree.DecisionTreeClassifier.html#sklearn.tree.DecisionTreeClassifier.predict\" target=\"_blank\" rel=\"noopener\">sklearn.tree.DecisionTreeClassifier.predict</a> 回归测试准确率</li>\n<li><a href=\"http://scikit-learn.org/stable/modules/generated/sklearn.metrics.accuracy_score.html\" target=\"_blank\" rel=\"noopener\">sklearn.metrics.accuracy_score</a> 计算分类得分</li>\n<li><a href=\"http://scikit-learn.org/stable/modules/generated/sklearn.tree.export_graphviz.html\" target=\"_blank\" rel=\"noopener\">sklearn.tree.export_graphviz</a></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>特征</th>\n<th></th>\n<th>特征类型</th>\n<th>列名</th>\n<th>列数据类型</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Age</td>\n<td>年龄</td>\n<td>客观特征</td>\n<td>age</td>\n<td>int (days)</td>\n</tr>\n<tr>\n<td>Height</td>\n<td>身高</td>\n<td>客观特征</td>\n<td>height</td>\n<td>int (cm)</td>\n</tr>\n<tr>\n<td>Weight</td>\n<td>体重</td>\n<td>客观特征</td>\n<td>weight</td>\n<td>float (kg)</td>\n</tr>\n<tr>\n<td>Gender</td>\n<td>性别</td>\n<td>客观特征</td>\n<td>gender</td>\n<td>categorical code （1 – woman, 2 – man）</td>\n</tr>\n<tr>\n<td>Systolic blood pressure</td>\n<td>收缩压</td>\n<td>检查特征</td>\n<td>ap_hi</td>\n<td>int</td>\n</tr>\n<tr>\n<td>Diastolic blood pressure</td>\n<td>舒张压</td>\n<td>检查特征</td>\n<td>ap_lo</td>\n<td>int</td>\n</tr>\n<tr>\n<td>Cholesterol</td>\n<td>胆固醇</td>\n<td>检查特征</td>\n<td>cholesterol</td>\n<td>1: normal, 2: above normal, 3: well above normal</td>\n</tr>\n<tr>\n<td>Glucose</td>\n<td>葡萄糖</td>\n<td>检查特征</td>\n<td>gluc</td>\n<td>1: normal, 2: above normal, 3: well above normal</td>\n</tr>\n<tr>\n<td>Smoking</td>\n<td>是否吸烟</td>\n<td>主观特征</td>\n<td>smoke</td>\n<td>binary</td>\n</tr>\n<tr>\n<td>Alcohol intake</td>\n<td>是否喝酒</td>\n<td>主观特征</td>\n<td>alco</td>\n<td>binary</td>\n</tr>\n<tr>\n<td>Physical activity</td>\n<td>体力劳动</td>\n<td>主观特征</td>\n<td>active</td>\n<td>binary</td>\n</tr>\n<tr>\n<td>Presence or absence of cardiovascular disease</td>\n<td>是否存在心血管疾病</td>\n<td>目标特征</td>\n<td>cardio</td>\n<td>binary</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>以下代码需要：</p>\n<ul>\n<li>pandas</li>\n<li>sklearn</li>\n<li><a href=\"https://www.graphviz.org/\" target=\"_blank\" rel=\"noopener\">graphviz</a> <em>对于windows环境来说，需要将安装目录中的bin目录添加至环境变量中。</em></li>\n<li>pydotplus <em>先安装 graphviz</em></li>\n</ul>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> io <span class=\"keyword\">import</span> BytesIO</span><br><span class=\"line\"><span class=\"keyword\">from</span> io <span class=\"keyword\">import</span> StringIO</span><br><span class=\"line\"><span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd</span><br><span class=\"line\"><span class=\"keyword\">import</span> pydotplus</span><br><span class=\"line\"><span class=\"keyword\">from</span> PIL <span class=\"keyword\">import</span> Image</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn.metrics <span class=\"keyword\">import</span> accuracy_score</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn.model_selection <span class=\"keyword\">import</span> train_test_split</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn.tree <span class=\"keyword\">import</span> DecisionTreeClassifier</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn.tree <span class=\"keyword\">import</span> export_graphviz</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">S</span><span class=\"params\">(X, Y, criterion=<span class=\"string\">'gini'</span>)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"显示决策树的决策过程的方法</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    :param X: 训练集。</span></span><br><span class=\"line\"><span class=\"string\">    :param Y: 结果集。</span></span><br><span class=\"line\"><span class=\"string\">    :param criterion: 衡量指标。与 `sklearn.tree.DecisionTreeClassifier` 一致。默认为 `gini`。 也可以使用 `entropy`。</span></span><br><span class=\"line\"><span class=\"string\">    :return:</span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\">    <span class=\"comment\"># 以深度为3层来创建决策树分类器</span></span><br><span class=\"line\">    tree_model = DecisionTreeClassifier(criterion=criterion, max_depth=<span class=\"number\">3</span>)</span><br><span class=\"line\">    <span class=\"comment\"># 从训练集（X，y）构建决策树分类器。</span></span><br><span class=\"line\">    tree_model.fit(X, Y)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tree_model</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">showImg</span><span class=\"params\">(tree, feature_names=None)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"显示决策树\"\"\"</span></span><br><span class=\"line\">    dot_data = StringIO()</span><br><span class=\"line\">    <span class=\"comment\"># 导出决策树为 DOT 格式</span></span><br><span class=\"line\">    export_graphviz(tree, feature_names=feature_names, out_file=dot_data, filled=<span class=\"keyword\">True</span>)</span><br><span class=\"line\">    graph = pydotplus.graph_from_dot_data(dot_data.getvalue())</span><br><span class=\"line\">    image = Image.open(BytesIO(graph.create_png()))</span><br><span class=\"line\">    image.show()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    df = pd.read_csv(<span class=\"string\">'mlbootcamp5_train.csv'</span>, index_col=<span class=\"string\">'id'</span>, sep=<span class=\"string\">';'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># # 使用sklearn.model_selection.train_test_split将数据拆分成训练集和测试集</span></span><br><span class=\"line\">    <span class=\"comment\"># # 使用3/7比率</span></span><br><span class=\"line\">    X_train, X_valid, Y_train, Y_valid = train_test_split(df.drop(columns=[<span class=\"string\">'cardio'</span>]), df[<span class=\"string\">'cardio'</span>], test_size=<span class=\"number\">0.3</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 按照 基尼不纯度 分割的决策树</span></span><br><span class=\"line\">    tree_gini = S(X_train, Y_train);</span><br><span class=\"line\">    <span class=\"comment\"># 按照 信息熵 分割的决策树</span></span><br><span class=\"line\">    tree_entropy = S(X_train, Y_train, <span class=\"string\">'entropy'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    showImg(tree_gini, X_train.columns)</span><br><span class=\"line\">    showImg(tree_entropy, X_train.columns)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>按照基尼不纯度分割：</li>\n</ul>\n<p><img src=\"NZXca6g.png\" alt=\"NZXca6g\"></p>\n<ul>\n<li>按照信息熵分割：</li>\n</ul>\n<p><img src=\"3VT+hGyI.png\" alt=\"3VT+hGyI\"></p>\n<p>无论按照哪种方式分割，都可以看到，随着叶子节点的不断展开，基尼不纯度或者信息熵都会不断下降。</p>\n<p>计算分类回归准确率：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">V</span><span class=\"params\">(tree, X, Y)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"验证结果准确度\"\"\"</span></span><br><span class=\"line\">    y_pred = tree.predict(X)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> accuracy_score(y_pred=y_pred, y_true=Y)</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    print(V(tree_gini, X_valid, Y_valid))</span><br><span class=\"line\">    print(V(tree_entropy, X_valid, Y_valid))</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">0.7282857142857143</span><br><span class=\"line\">0.7269047619047619</span><br></pre></td></tr></table></figure>\n<h5 id=\"过拟合\"><a href=\"#过拟合\" class=\"headerlink\" title=\"过拟合\"></a>过拟合</h5><p>最常见的应对过拟合决策树的方式为：</p>\n<ul>\n<li>人工限制深度或叶节点的最少样本数：达到限制时停止树的构造。</li>\n<li>对树进行剪枝。</li>\n</ul>\n<p><code>sklearn.tree.DecisionTreeClassifier</code>类的主要参数为：</p>\n<ul>\n<li><code>max_depth</code> 树的最大深度；</li>\n<li><code>max_features</code> 搜索最佳分区时的最大特征数（特征很多时，设置这个参数很有必要，因为基于<strong>所有</strong>特征搜索分区会很“昂贵”）；</li>\n<li><code>min_samples_leaf</code> 叶节点的最少样本数。该参数防止创建任何叶节点只有很少成员的树。</li>\n</ul>\n<h5 id=\"最近邻居法\"><a href=\"#最近邻居法\" class=\"headerlink\" title=\"最近邻居法\"></a><a href=\"https://zh.wikipedia.org/wiki/%E6%9C%80%E8%BF%91%E9%84%B0%E5%B1%85%E6%B3%95\" target=\"_blank\" rel=\"noopener\">最近邻居法</a></h5>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"三、分类、决策树和K近邻\"><a href=\"#三、分类、决策树和K近邻\" class=\"headerlink\" title=\"三、分类、决策树和K近邻\"></a>三、分类、决策树和K近邻</h3><p><a href=\"https://www.jqr.com/article/000139\" target=\"_blank\" rel=\"noopener\">机器学习开放课程：三、分类、决策树和K近邻</a></p>\n<h4 id=\"决策树\"><a href=\"#决策树\" class=\"headerlink\" title=\"决策树\"></a>决策树</h4><h5 id=\"熵-信息论\"><a href=\"#熵-信息论\" class=\"headerlink\" title=\"熵 (信息论))\"></a><a href=\"https://zh.wikipedia.org/wiki/%E7%86%B5_(%E4%BF%A1%E6%81%AF%E8%AE%BA\" target=\"_blank\" rel=\"noopener\">熵 (信息论)</a>)</h5><p><strong>熵最好理解为不确定性的量度而不是确定性的量度，因为越随机的信源的熵越大。</strong></p>\n<p><strong>在信息论里面，熵是对不确定性的测量。但是在信息世界，熵越高，则能传输越多的信息，熵越低，则意味着传输的信息越少。熵的下降称为信息增益。</strong></p>\n<p>假如我在不知情的情况下问某一届世界杯冠军是谁，而知道的人不愿意直接告诉我，而是让我猜，猜一次一块钱。为了省钱可以为所有的参赛队伍编号1~32，然后提问：“冠军队伍在1~16号之间吗？“假如他告诉我猜对了，我就会接着问：”冠军队伍在1~8号之间吗？“假如他告诉我猜错了，我自然知道冠军队伍在9~16号之间。这样只需要5次，就知道哪支球队是冠军了。</p>\n<p>$$-\\log({1 \\over 32})=5$$</p>\n<p>当然，有可能也用不了5次，因为总有些热门球队的夺冠概率会比较高，所以只需要把夺冠概率高的分在一组，正常情况下就会用更少的次数猜出结果。</p>\n<p>$$H=-(P_{1}\\log(P_{1})+P_{2}\\log(P_{2})+ \\cdots +P_{32}\\log(P_{32}))$$</p>\n<p>其中$$P{1},P{2},\\cdots,P{32}$$分别是这32支球队的夺冠概率。</p>\n<p>对于任意一个随机变量$$X$$，它的熵定义如下：</p>\n<p>$$H_{s}=-\\sum_{i=1}^{n}P_{i}\\log\\left (P_{i} \\right )$$</p>\n<p>英语文本数据流的熵比较低，因为英语很容易读懂，也就是说很容易被预测。即便我们不知道下一段英语文字是什么内容，但是我们能很容易地预测，比如，字母e总是比字母z多，或者qu字母组合的可能性总是超过q与任何其它字母的组合。如果未经压缩，一段英文文本的每个字母需要8个比特来编码，但是实际上英文文本的熵大概只有4.7比特。</p>\n<p>如英语有26个字母，假如每个字母在文章中出现次数平均的话，每个字母的讯息量为：</p>\n<p>$$I_{e}=-\\log\\left (1\\over26 \\right )=4.7$$</p>\n<p>Excel公式：=$$-LOG(1/26,2)$$</p>\n<h5 id=\"C4-5算法\"><a href=\"#C4-5算法\" class=\"headerlink\" title=\"C4.5算法\"></a><a href=\"https://zh.wikipedia.org/wiki/C4.5%E7%AE%97%E6%B3%95\" target=\"_blank\" rel=\"noopener\">C4.5算法</a></h5><p>C4.5算法是由Ross Quinlan开发的用于产生决策树的算法。该算法是对Ross Quinlan之前开发的ID3算法的一个扩展。C4.5算法产生的决策树可以被用作分类目的，因此该算法也可以用于统计分类。</p>\n<p>是贪婪最大化信息增益：在每一步，算法选择能在分割后给出最大信息增益的变量。接着递归重复这一流程，直到熵为零（或者，为了避免过拟合，直到熵为某个较小的值）。</p>\n<h5 id=\"基尼不纯度\"><a href=\"#基尼不纯度\" class=\"headerlink\" title=\"基尼不纯度\"></a><a href=\"https://zh.wikipedia.org/wiki/%E5%86%B3%E7%AD%96%E6%A0%91%E5%AD%A6%E4%B9%A0#%E5%9F%BA%E5%B0%BC%E4%B8%8D%E7%BA%AF%E5%BA%A6%E6%8C%87%E6%A0%87\" target=\"_blank\" rel=\"noopener\">基尼不纯度</a></h5><p>基尼不纯度表示一个随机选中的样本在子集中被分错的可能性。基尼不纯度为这个样本被选中的概率乘以它被分错的概率。当一个节点中所有样本都是一个类时，基尼不纯度为零。</p>\n<p>基尼不纯度的大概意思是<strong>一个随机事件变成它的对立事件的概率</strong>。</p>\n<p><strong>基尼不确定性和信息增益的效果差不多。</strong></p>\n<h5 id=\"决策树示例\"><a href=\"#决策树示例\" class=\"headerlink\" title=\"决策树示例\"></a>决策树示例</h5><p>下面使用决策树分析患者的检查结果来分析心血管疾病(CVD)的存在是否有关系。</p>\n<p>数据来源：<a href=\"mlbootcamp5_train.csv\">mlbootcamp5_train.csv</a></p>\n<p>相关类及方法：</p>\n<ul>\n<li><a href=\"http://scikit-learn.org/stable/modules/generated/sklearn.tree.DecisionTreeClassifier.html#sklearn-tree-decisiontreeclassifier\" target=\"_blank\" rel=\"noopener\">sklearn.tree.DecisionTreeClassifier</a> 决策树分类器</li>\n<li><a href=\"http://scikit-learn.org/stable/modules/generated/sklearn.tree.DecisionTreeClassifier.html#sklearn.tree.DecisionTreeClassifier.fit\" target=\"_blank\" rel=\"noopener\">sklearn.tree.DecisionTreeClassifier.fit</a> 使用数据填充决策树分类器</li>\n<li><a href=\"http://scikit-learn.org/stable/modules/generated/sklearn.tree.DecisionTreeClassifier.html#sklearn.tree.DecisionTreeClassifier.predict\" target=\"_blank\" rel=\"noopener\">sklearn.tree.DecisionTreeClassifier.predict</a> 回归测试准确率</li>\n<li><a href=\"http://scikit-learn.org/stable/modules/generated/sklearn.metrics.accuracy_score.html\" target=\"_blank\" rel=\"noopener\">sklearn.metrics.accuracy_score</a> 计算分类得分</li>\n<li><a href=\"http://scikit-learn.org/stable/modules/generated/sklearn.tree.export_graphviz.html\" target=\"_blank\" rel=\"noopener\">sklearn.tree.export_graphviz</a></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>特征</th>\n<th></th>\n<th>特征类型</th>\n<th>列名</th>\n<th>列数据类型</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Age</td>\n<td>年龄</td>\n<td>客观特征</td>\n<td>age</td>\n<td>int (days)</td>\n</tr>\n<tr>\n<td>Height</td>\n<td>身高</td>\n<td>客观特征</td>\n<td>height</td>\n<td>int (cm)</td>\n</tr>\n<tr>\n<td>Weight</td>\n<td>体重</td>\n<td>客观特征</td>\n<td>weight</td>\n<td>float (kg)</td>\n</tr>\n<tr>\n<td>Gender</td>\n<td>性别</td>\n<td>客观特征</td>\n<td>gender</td>\n<td>categorical code （1 – woman, 2 – man）</td>\n</tr>\n<tr>\n<td>Systolic blood pressure</td>\n<td>收缩压</td>\n<td>检查特征</td>\n<td>ap_hi</td>\n<td>int</td>\n</tr>\n<tr>\n<td>Diastolic blood pressure</td>\n<td>舒张压</td>\n<td>检查特征</td>\n<td>ap_lo</td>\n<td>int</td>\n</tr>\n<tr>\n<td>Cholesterol</td>\n<td>胆固醇</td>\n<td>检查特征</td>\n<td>cholesterol</td>\n<td>1: normal, 2: above normal, 3: well above normal</td>\n</tr>\n<tr>\n<td>Glucose</td>\n<td>葡萄糖</td>\n<td>检查特征</td>\n<td>gluc</td>\n<td>1: normal, 2: above normal, 3: well above normal</td>\n</tr>\n<tr>\n<td>Smoking</td>\n<td>是否吸烟</td>\n<td>主观特征</td>\n<td>smoke</td>\n<td>binary</td>\n</tr>\n<tr>\n<td>Alcohol intake</td>\n<td>是否喝酒</td>\n<td>主观特征</td>\n<td>alco</td>\n<td>binary</td>\n</tr>\n<tr>\n<td>Physical activity</td>\n<td>体力劳动</td>\n<td>主观特征</td>\n<td>active</td>\n<td>binary</td>\n</tr>\n<tr>\n<td>Presence or absence of cardiovascular disease</td>\n<td>是否存在心血管疾病</td>\n<td>目标特征</td>\n<td>cardio</td>\n<td>binary</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>以下代码需要：</p>\n<ul>\n<li>pandas</li>\n<li>sklearn</li>\n<li><a href=\"https://www.graphviz.org/\" target=\"_blank\" rel=\"noopener\">graphviz</a> <em>对于windows环境来说，需要将安装目录中的bin目录添加至环境变量中。</em></li>\n<li>pydotplus <em>先安装 graphviz</em></li>\n</ul>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> io <span class=\"keyword\">import</span> BytesIO</span><br><span class=\"line\"><span class=\"keyword\">from</span> io <span class=\"keyword\">import</span> StringIO</span><br><span class=\"line\"><span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd</span><br><span class=\"line\"><span class=\"keyword\">import</span> pydotplus</span><br><span class=\"line\"><span class=\"keyword\">from</span> PIL <span class=\"keyword\">import</span> Image</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn.metrics <span class=\"keyword\">import</span> accuracy_score</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn.model_selection <span class=\"keyword\">import</span> train_test_split</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn.tree <span class=\"keyword\">import</span> DecisionTreeClassifier</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn.tree <span class=\"keyword\">import</span> export_graphviz</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">S</span><span class=\"params\">(X, Y, criterion=<span class=\"string\">'gini'</span>)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"显示决策树的决策过程的方法</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    :param X: 训练集。</span></span><br><span class=\"line\"><span class=\"string\">    :param Y: 结果集。</span></span><br><span class=\"line\"><span class=\"string\">    :param criterion: 衡量指标。与 `sklearn.tree.DecisionTreeClassifier` 一致。默认为 `gini`。 也可以使用 `entropy`。</span></span><br><span class=\"line\"><span class=\"string\">    :return:</span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\">    <span class=\"comment\"># 以深度为3层来创建决策树分类器</span></span><br><span class=\"line\">    tree_model = DecisionTreeClassifier(criterion=criterion, max_depth=<span class=\"number\">3</span>)</span><br><span class=\"line\">    <span class=\"comment\"># 从训练集（X，y）构建决策树分类器。</span></span><br><span class=\"line\">    tree_model.fit(X, Y)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tree_model</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">showImg</span><span class=\"params\">(tree, feature_names=None)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"显示决策树\"\"\"</span></span><br><span class=\"line\">    dot_data = StringIO()</span><br><span class=\"line\">    <span class=\"comment\"># 导出决策树为 DOT 格式</span></span><br><span class=\"line\">    export_graphviz(tree, feature_names=feature_names, out_file=dot_data, filled=<span class=\"keyword\">True</span>)</span><br><span class=\"line\">    graph = pydotplus.graph_from_dot_data(dot_data.getvalue())</span><br><span class=\"line\">    image = Image.open(BytesIO(graph.create_png()))</span><br><span class=\"line\">    image.show()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    df = pd.read_csv(<span class=\"string\">'mlbootcamp5_train.csv'</span>, index_col=<span class=\"string\">'id'</span>, sep=<span class=\"string\">';'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># # 使用sklearn.model_selection.train_test_split将数据拆分成训练集和测试集</span></span><br><span class=\"line\">    <span class=\"comment\"># # 使用3/7比率</span></span><br><span class=\"line\">    X_train, X_valid, Y_train, Y_valid = train_test_split(df.drop(columns=[<span class=\"string\">'cardio'</span>]), df[<span class=\"string\">'cardio'</span>], test_size=<span class=\"number\">0.3</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 按照 基尼不纯度 分割的决策树</span></span><br><span class=\"line\">    tree_gini = S(X_train, Y_train);</span><br><span class=\"line\">    <span class=\"comment\"># 按照 信息熵 分割的决策树</span></span><br><span class=\"line\">    tree_entropy = S(X_train, Y_train, <span class=\"string\">'entropy'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    showImg(tree_gini, X_train.columns)</span><br><span class=\"line\">    showImg(tree_entropy, X_train.columns)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>按照基尼不纯度分割：</li>\n</ul>\n<p><img src=\"NZXca6g.png\" alt=\"NZXca6g\"></p>\n<ul>\n<li>按照信息熵分割：</li>\n</ul>\n<p><img src=\"3VT+hGyI.png\" alt=\"3VT+hGyI\"></p>\n<p>无论按照哪种方式分割，都可以看到，随着叶子节点的不断展开，基尼不纯度或者信息熵都会不断下降。</p>\n<p>计算分类回归准确率：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">V</span><span class=\"params\">(tree, X, Y)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"验证结果准确度\"\"\"</span></span><br><span class=\"line\">    y_pred = tree.predict(X)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> accuracy_score(y_pred=y_pred, y_true=Y)</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    print(V(tree_gini, X_valid, Y_valid))</span><br><span class=\"line\">    print(V(tree_entropy, X_valid, Y_valid))</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">0.7282857142857143</span><br><span class=\"line\">0.7269047619047619</span><br></pre></td></tr></table></figure>\n<h5 id=\"过拟合\"><a href=\"#过拟合\" class=\"headerlink\" title=\"过拟合\"></a>过拟合</h5><p>最常见的应对过拟合决策树的方式为：</p>\n<ul>\n<li>人工限制深度或叶节点的最少样本数：达到限制时停止树的构造。</li>\n<li>对树进行剪枝。</li>\n</ul>\n<p><code>sklearn.tree.DecisionTreeClassifier</code>类的主要参数为：</p>\n<ul>\n<li><code>max_depth</code> 树的最大深度；</li>\n<li><code>max_features</code> 搜索最佳分区时的最大特征数（特征很多时，设置这个参数很有必要，因为基于<strong>所有</strong>特征搜索分区会很“昂贵”）；</li>\n<li><code>min_samples_leaf</code> 叶节点的最少样本数。该参数防止创建任何叶节点只有很少成员的树。</li>\n</ul>\n<h5 id=\"最近邻居法\"><a href=\"#最近邻居法\" class=\"headerlink\" title=\"最近邻居法\"></a><a href=\"https://zh.wikipedia.org/wiki/%E6%9C%80%E8%BF%91%E9%84%B0%E5%B1%85%E6%B3%95\" target=\"_blank\" rel=\"noopener\">最近邻居法</a></h5>"},{"title":"乌合之众-大众心理研究","ISBN":9787510407550,"updated":"2018-04-23T16:00:00.000Z","date":"2018-04-23T16:00:00.000Z","出版社":"新世界出版社","出版时间":"2011-07-31T16:00:00.000Z","版次":2,"photos":["/2018/04/24/wuhezhizhong/wuhezhizhong.png"],"_content":"","source":"_posts/wuhezhizhong.md","raw":"---\ntitle: 乌合之众-大众心理研究\nISBN: 9787510407550\nupdated: 2018-04-24\ndate: 2018-04-24\n出版社: 新世界出版社\n出版时间: 2011-08-01\n版次: 2\nphotos:\n - /2018/04/24/wuhezhizhong/wuhezhizhong.png\ntags:\n - 阅读\n - 心理学\ncategories:\n - 阅读\n---","slug":"wuhezhizhong","published":1,"comments":1,"layout":"post","link":"","_id":"cjof51pk6000frgueaf6t66l5","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"机器学习开放课程：五、Bagging与随机森林","date":"2018-11-08T01:41:51.000Z","updated":"2018-11-07T16:00:00.000Z","typora-root-url":"机器学习开放课程：五、Bagging与随机森林","mathjax":true,"description":"<!—more—->","_content":"\n### 集成\n\n#### [孔塞多陪审团定理](https://en.wikipedia.org/wiki/Condorcet%27s_jury_theorem)\n\n如果评审团的每个成员做出独立判断，并且每个陪审员做出正确决策的概率高于0.5，那么整个评审团做出正确的总体决策的概率随着陪审员数量的增加而增加，并趋向于一。另一方面，如果每个陪审员判断正确的概率小于0.5，那么整个陪审团做出正确的总体决策的概率随着陪审员数量的增加而减少，并趋向于零。\n\n$\\mu = \\sum_{i=m}^{M}\\binom{N}{i} p^{i}(1-p)^{(N-i)}$\n\n- **N**为陪审员总数；\n- **m**是构成多数的最小值，即**m** = (N+1)/2；\n- **p**为评审员做出正确决策的概率；\n- **μ**是整个评审团做出正确决策的概率。\n\n```python\nfrom scipy.special import comb\n\np = 0.8\nN = 7\nm = int((1 + N) / 2)\nscore = 0\nfor i in range(m, N + 1, 1):\n    score += ((p ** i) * ((1 - p) ** (N - i)) * comb(N, i))\n# 96.67%\nprint(\"{:.2%}\".format(score))\n```\n\n*机器学习领域采用类似的思路以降低误差。*\n\n> Condorcet陪审团定理也用于[机器学习](https://en.wikipedia.org/wiki/Machine_learning)领域的[集成](https://en.wikipedia.org/wiki/Ensemble_learning)[学习](https://en.wikipedia.org/wiki/Machine_learning)。集合方法通过多数表决来组合许多单独分类器的预测。假设每个单独的分类器预测准确度略高于50％，那么他们的预测集合将远远大于他们的个人预测分数。\n\n### Bootstraping（自助抽样法）/Bagging（装袋算法）\n\n{% blockquote https://zh.wikipedia.org/wiki/Bagging%E7%AE%97%E6%B3%95 Bagging算法 %}\n\n给定一个大小为 $n$ 的训练集$D$，Bagging算法从中均匀、有放回地（即使用[自助抽样法](https://zh.wikipedia.org/wiki/%E8%87%AA%E5%8A%A9%E6%B3%95)）选出 $m$ 个大小为  ${n}'$ 的子集 $D_{i}$，作为新的训练集。在这 $m$ 个训练集上使用分类、回归等算法，则可得到 $m$ 个模型，再通过取平均值、取多数票等方法，即可得到Bagging的结果。\n\nBagging算法可与其他[分类](https://zh.wikipedia.org/wiki/%E7%BB%9F%E8%AE%A1%E5%88%86%E7%B1%BB)、[回归](https://zh.wikipedia.org/wiki/%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90)算法结合，提高其准确率、稳定性的同时，通过降低结果的[方差](https://zh.wikipedia.org/wiki/%E6%96%B9%E5%B7%AE)，避免[过拟合](https://zh.wikipedia.org/wiki/%E8%BF%87%E6%8B%9F%E5%90%88)的发生。\n\n{% endblockquote %}\n\n### 袋外误差\n\n{% blockquote https://zh.wikipedia.org/wiki/%E8%87%AA%E5%8A%A9%E6%B3%95 .632自助法 %}\n\n最常用的一种是.632自助法，假设给定的数据集包含d个样本。该数据集有放回地抽样d次，产生d个样本的训练集。这样原数据样本中的某些样本很可能在该样本集中出现多次。没有进入该训练集的样本最终形成检验集（测试集）。 显然每个样本被选中的概率是1/d，因此未被选中的概率就是(1-1/d)，这样一个样本在训练集中没出现的概率就是d次都未被选中的概率，即(1-1/d)d。当d趋于无穷大时，这一概率就将趋近于e-1=0.368，所以留在训练集中的样本大概就占原来数据集的63.2%。\n\n{% endblockquote %}\n\n### 随机森林\n\n随机森林扩展了Bagging。随机森林在以决策树为基学习器构建Bagging集成的基础上，进一步在决策树的训练过程中引入了随机属性选择。\n\n> 传统决策树在选择划分属性时是在当前节点的属性集合（假定有 $d$ 个参数）中选择一个最优属性；\n>\n> 而在随即森林中，对基决策树的每个节点，先从该节点的属性几何中随机选择一个包含 $k$ 的属性的子集，然后再从这个自己种选择一个最优属性用于划分。\n>\n> 参数 $k$ 控制了随机性的引入程度：\n>\n> 若令 $k=d$ ，则基决策树的构建与传统决策树相同；\n>\n> 若令 $k=1$，则是随机选择一个属性用于划分；\n>\n> 一般情况下，推荐值 $k=\\log_{2}{d}$\n\n**随机森林和bagging的主要差别在于，在随机森林中，分割的最佳特征是从一个随机特征子空间中选取的，而在bagging中，分割时将考虑所有特征。**\n\n### 分类器\n\n* [`ensemble.RandomForestClassifier`](https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestClassifier.html#sklearn.ensemble.RandomForestClassifier)\n* [`ensemble.BaggingClassifier`](https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.BaggingClassifier.html#sklearn.ensemble.BaggingClassifier)\n* [`tree.DecisionTreeClassifier`](https://scikit-learn.org/stable/modules/generated/sklearn.tree.DecisionTreeClassifier.html#sklearn.tree.DecisionTreeClassifier)\n\n以下使用三种分类器，分别对数据进行分类预测。\n\n[credit_scoring_sample.csv](credit_scoring_sample.csv)\n\n**数据看起来像这样：**\n\n##### 目标变量\n\n* SeriousDlqin2yrs - 该人在2年内长期拖延付款;二进制变量\n\n##### 特征\n\n| 列名                                 | 说明                                                         | 数据类型 |\n| ------------------------------------ | ------------------------------------------------------------ | -------- |\n| age                                  | 借款人的年龄（全年数）                                       | integer  |\n| NumberOfTime30-59DaysPastDueNotWorse | 在过去两年中，一个人延迟偿还其他贷款超过30-59天（但不是更多）的次数 | integer  |\n| DebtRatio                            | 每月付款（贷款，赡养费等）除以每月总收入，百分比             | float    |\n| MonthlyIncome                        | 以美元计算的月收入                                           | float    |\n| NumberOfTimes90DaysLate              | 一个人延迟偿还其他贷款超过90天的次数                         | integer  |\n| NumberOfTime60-89DaysPastDueNotWorse | 在过去两年中，一个人延迟偿还其他贷款超过60-89天（但不是更多）的次数 | integer  |\n| NumberOfDependents                   | 借款人家庭中的人数                                           | integer  |\n\n```python\nimport pandas as pd\nfrom sklearn.ensemble import RandomForestClassifier, BaggingClassifier\nfrom sklearn.model_selection import cross_val_score\nfrom sklearn.tree import DecisionTreeClassifier\n\ndata = pd.read_csv('credit_scoring_sample.csv', sep=\";\")\n# 不包含目标值的列名集合\nindependent_columns_names = [x for x in data if x != 'SeriousDlqin2yrs']\n```\n\n```python\ndef impute_nan_with_median(table):\n    \"\"\"用表中每列的中位数替换NaN值\"\"\"\n    for col in table.columns:\n        table[col] = table[col].fillna(table[col].median())\n    return table\n\ntable = impute_nan_with_median(data)\n\nX = table[independent_columns_names]  # 数据（替换过NaN值）\ny = table['SeriousDlqin2yrs']  # 目标值\n\nn_estimators = 200  # 森林中树的数量\nrandom_state = 17\nscoring = 'roc_auc'\nclass_weight = 'balanced'\n\ndtc = DecisionTreeClassifier(class_weight=class_weight, random_state=random_state)\nresults = cross_val_score(dtc, X, y, scoring=scoring)\nprint(\"决策树交叉验证精确度评分： {:.2f}%\".format(results.mean() * 100))\n\nbc = BaggingClassifier(base_estimator=DecisionTreeClassifier(), n_estimators=n_estimators, random_state=random_state)\nresults = cross_val_score(bc, X, y, scoring=scoring)\nprint(\"Bagging交叉验证精确度评分： {:.2f}%\".format(results.mean() * 100))\n\nrfc = RandomForestClassifier(n_estimators=n_estimators, random_state=random_state, class_weight=class_weight)\nresults = cross_val_score(rfc, X, y, scoring=scoring)\nprint(\"随机森林交叉验证精确度评分： {:.2f}%\".format(results.mean() * 100))\n```\n\n```\n决策树交叉验证精确度评分： 65.21%\nBagging交叉验证精确度评分： 80.41%\n随机森林交叉验证精确度评分： 80.60%\n```\n\n","source":"_posts/机器学习开放课程：五、Bagging与随机森林.md","raw":"---\ntitle: 机器学习开放课程：五、Bagging与随机森林\ndate: 2018-11-08 09:41:51\nupdated: 2018-11-08\ntags:\n - 编程\n - Python\n - 机器学习\n - 随机森林\n - scipy.special.comb\n - 评审团定理\n - Bootstraping（自助抽样法）\n - Bagging（装袋算法）\n - 袋外误差\n - .632自助法\n - 分类\n - sklearn.model_selection.cross_val_score\n - sklearn.ensemble.RandomForestClassifier\n - sklearn.ensemble.BaggingClassifier\n - sklearn.tree.DecisionTreeClassifier\ncategories:\n - 编程\n - Python\n - 机器学习\ntypora-root-url: 机器学习开放课程：五、Bagging与随机森林\nmathjax: true\ndescription: <!—more—->\n---\n\n### 集成\n\n#### [孔塞多陪审团定理](https://en.wikipedia.org/wiki/Condorcet%27s_jury_theorem)\n\n如果评审团的每个成员做出独立判断，并且每个陪审员做出正确决策的概率高于0.5，那么整个评审团做出正确的总体决策的概率随着陪审员数量的增加而增加，并趋向于一。另一方面，如果每个陪审员判断正确的概率小于0.5，那么整个陪审团做出正确的总体决策的概率随着陪审员数量的增加而减少，并趋向于零。\n\n$\\mu = \\sum_{i=m}^{M}\\binom{N}{i} p^{i}(1-p)^{(N-i)}$\n\n- **N**为陪审员总数；\n- **m**是构成多数的最小值，即**m** = (N+1)/2；\n- **p**为评审员做出正确决策的概率；\n- **μ**是整个评审团做出正确决策的概率。\n\n```python\nfrom scipy.special import comb\n\np = 0.8\nN = 7\nm = int((1 + N) / 2)\nscore = 0\nfor i in range(m, N + 1, 1):\n    score += ((p ** i) * ((1 - p) ** (N - i)) * comb(N, i))\n# 96.67%\nprint(\"{:.2%}\".format(score))\n```\n\n*机器学习领域采用类似的思路以降低误差。*\n\n> Condorcet陪审团定理也用于[机器学习](https://en.wikipedia.org/wiki/Machine_learning)领域的[集成](https://en.wikipedia.org/wiki/Ensemble_learning)[学习](https://en.wikipedia.org/wiki/Machine_learning)。集合方法通过多数表决来组合许多单独分类器的预测。假设每个单独的分类器预测准确度略高于50％，那么他们的预测集合将远远大于他们的个人预测分数。\n\n### Bootstraping（自助抽样法）/Bagging（装袋算法）\n\n{% blockquote https://zh.wikipedia.org/wiki/Bagging%E7%AE%97%E6%B3%95 Bagging算法 %}\n\n给定一个大小为 $n$ 的训练集$D$，Bagging算法从中均匀、有放回地（即使用[自助抽样法](https://zh.wikipedia.org/wiki/%E8%87%AA%E5%8A%A9%E6%B3%95)）选出 $m$ 个大小为  ${n}'$ 的子集 $D_{i}$，作为新的训练集。在这 $m$ 个训练集上使用分类、回归等算法，则可得到 $m$ 个模型，再通过取平均值、取多数票等方法，即可得到Bagging的结果。\n\nBagging算法可与其他[分类](https://zh.wikipedia.org/wiki/%E7%BB%9F%E8%AE%A1%E5%88%86%E7%B1%BB)、[回归](https://zh.wikipedia.org/wiki/%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90)算法结合，提高其准确率、稳定性的同时，通过降低结果的[方差](https://zh.wikipedia.org/wiki/%E6%96%B9%E5%B7%AE)，避免[过拟合](https://zh.wikipedia.org/wiki/%E8%BF%87%E6%8B%9F%E5%90%88)的发生。\n\n{% endblockquote %}\n\n### 袋外误差\n\n{% blockquote https://zh.wikipedia.org/wiki/%E8%87%AA%E5%8A%A9%E6%B3%95 .632自助法 %}\n\n最常用的一种是.632自助法，假设给定的数据集包含d个样本。该数据集有放回地抽样d次，产生d个样本的训练集。这样原数据样本中的某些样本很可能在该样本集中出现多次。没有进入该训练集的样本最终形成检验集（测试集）。 显然每个样本被选中的概率是1/d，因此未被选中的概率就是(1-1/d)，这样一个样本在训练集中没出现的概率就是d次都未被选中的概率，即(1-1/d)d。当d趋于无穷大时，这一概率就将趋近于e-1=0.368，所以留在训练集中的样本大概就占原来数据集的63.2%。\n\n{% endblockquote %}\n\n### 随机森林\n\n随机森林扩展了Bagging。随机森林在以决策树为基学习器构建Bagging集成的基础上，进一步在决策树的训练过程中引入了随机属性选择。\n\n> 传统决策树在选择划分属性时是在当前节点的属性集合（假定有 $d$ 个参数）中选择一个最优属性；\n>\n> 而在随即森林中，对基决策树的每个节点，先从该节点的属性几何中随机选择一个包含 $k$ 的属性的子集，然后再从这个自己种选择一个最优属性用于划分。\n>\n> 参数 $k$ 控制了随机性的引入程度：\n>\n> 若令 $k=d$ ，则基决策树的构建与传统决策树相同；\n>\n> 若令 $k=1$，则是随机选择一个属性用于划分；\n>\n> 一般情况下，推荐值 $k=\\log_{2}{d}$\n\n**随机森林和bagging的主要差别在于，在随机森林中，分割的最佳特征是从一个随机特征子空间中选取的，而在bagging中，分割时将考虑所有特征。**\n\n### 分类器\n\n* [`ensemble.RandomForestClassifier`](https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestClassifier.html#sklearn.ensemble.RandomForestClassifier)\n* [`ensemble.BaggingClassifier`](https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.BaggingClassifier.html#sklearn.ensemble.BaggingClassifier)\n* [`tree.DecisionTreeClassifier`](https://scikit-learn.org/stable/modules/generated/sklearn.tree.DecisionTreeClassifier.html#sklearn.tree.DecisionTreeClassifier)\n\n以下使用三种分类器，分别对数据进行分类预测。\n\n[credit_scoring_sample.csv](credit_scoring_sample.csv)\n\n**数据看起来像这样：**\n\n##### 目标变量\n\n* SeriousDlqin2yrs - 该人在2年内长期拖延付款;二进制变量\n\n##### 特征\n\n| 列名                                 | 说明                                                         | 数据类型 |\n| ------------------------------------ | ------------------------------------------------------------ | -------- |\n| age                                  | 借款人的年龄（全年数）                                       | integer  |\n| NumberOfTime30-59DaysPastDueNotWorse | 在过去两年中，一个人延迟偿还其他贷款超过30-59天（但不是更多）的次数 | integer  |\n| DebtRatio                            | 每月付款（贷款，赡养费等）除以每月总收入，百分比             | float    |\n| MonthlyIncome                        | 以美元计算的月收入                                           | float    |\n| NumberOfTimes90DaysLate              | 一个人延迟偿还其他贷款超过90天的次数                         | integer  |\n| NumberOfTime60-89DaysPastDueNotWorse | 在过去两年中，一个人延迟偿还其他贷款超过60-89天（但不是更多）的次数 | integer  |\n| NumberOfDependents                   | 借款人家庭中的人数                                           | integer  |\n\n```python\nimport pandas as pd\nfrom sklearn.ensemble import RandomForestClassifier, BaggingClassifier\nfrom sklearn.model_selection import cross_val_score\nfrom sklearn.tree import DecisionTreeClassifier\n\ndata = pd.read_csv('credit_scoring_sample.csv', sep=\";\")\n# 不包含目标值的列名集合\nindependent_columns_names = [x for x in data if x != 'SeriousDlqin2yrs']\n```\n\n```python\ndef impute_nan_with_median(table):\n    \"\"\"用表中每列的中位数替换NaN值\"\"\"\n    for col in table.columns:\n        table[col] = table[col].fillna(table[col].median())\n    return table\n\ntable = impute_nan_with_median(data)\n\nX = table[independent_columns_names]  # 数据（替换过NaN值）\ny = table['SeriousDlqin2yrs']  # 目标值\n\nn_estimators = 200  # 森林中树的数量\nrandom_state = 17\nscoring = 'roc_auc'\nclass_weight = 'balanced'\n\ndtc = DecisionTreeClassifier(class_weight=class_weight, random_state=random_state)\nresults = cross_val_score(dtc, X, y, scoring=scoring)\nprint(\"决策树交叉验证精确度评分： {:.2f}%\".format(results.mean() * 100))\n\nbc = BaggingClassifier(base_estimator=DecisionTreeClassifier(), n_estimators=n_estimators, random_state=random_state)\nresults = cross_val_score(bc, X, y, scoring=scoring)\nprint(\"Bagging交叉验证精确度评分： {:.2f}%\".format(results.mean() * 100))\n\nrfc = RandomForestClassifier(n_estimators=n_estimators, random_state=random_state, class_weight=class_weight)\nresults = cross_val_score(rfc, X, y, scoring=scoring)\nprint(\"随机森林交叉验证精确度评分： {:.2f}%\".format(results.mean() * 100))\n```\n\n```\n决策树交叉验证精确度评分： 65.21%\nBagging交叉验证精确度评分： 80.41%\n随机森林交叉验证精确度评分： 80.60%\n```\n\n","slug":"机器学习开放课程：五、Bagging与随机森林","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cjof51pke000grgue45hf4ov1","content":"<h3 id=\"集成\"><a href=\"#集成\" class=\"headerlink\" title=\"集成\"></a>集成</h3><h4 id=\"孔塞多陪审团定理\"><a href=\"#孔塞多陪审团定理\" class=\"headerlink\" title=\"孔塞多陪审团定理\"></a><a href=\"https://en.wikipedia.org/wiki/Condorcet%27s_jury_theorem\" target=\"_blank\" rel=\"noopener\">孔塞多陪审团定理</a></h4><p>如果评审团的每个成员做出独立判断，并且每个陪审员做出正确决策的概率高于0.5，那么整个评审团做出正确的总体决策的概率随着陪审员数量的增加而增加，并趋向于一。另一方面，如果每个陪审员判断正确的概率小于0.5，那么整个陪审团做出正确的总体决策的概率随着陪审员数量的增加而减少，并趋向于零。</p>\n<p>$\\mu = \\sum_{i=m}^{M}\\binom{N}{i} p^{i}(1-p)^{(N-i)}$</p>\n<ul>\n<li><strong>N</strong>为陪审员总数；</li>\n<li><strong>m</strong>是构成多数的最小值，即<strong>m</strong> = (N+1)/2；</li>\n<li><strong>p</strong>为评审员做出正确决策的概率；</li>\n<li><strong>μ</strong>是整个评审团做出正确决策的概率。</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> scipy.special <span class=\"keyword\">import</span> comb</span><br><span class=\"line\"></span><br><span class=\"line\">p = <span class=\"number\">0.8</span></span><br><span class=\"line\">N = <span class=\"number\">7</span></span><br><span class=\"line\">m = int((<span class=\"number\">1</span> + N) / <span class=\"number\">2</span>)</span><br><span class=\"line\">score = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(m, N + <span class=\"number\">1</span>, <span class=\"number\">1</span>):</span><br><span class=\"line\">    score += ((p ** i) * ((<span class=\"number\">1</span> - p) ** (N - i)) * comb(N, i))</span><br><span class=\"line\"><span class=\"comment\"># 96.67%</span></span><br><span class=\"line\">print(<span class=\"string\">\"&#123;:.2%&#125;\"</span>.format(score))</span><br></pre></td></tr></table></figure>\n<p><em>机器学习领域采用类似的思路以降低误差。</em></p>\n<blockquote>\n<p>Condorcet陪审团定理也用于<a href=\"https://en.wikipedia.org/wiki/Machine_learning\" target=\"_blank\" rel=\"noopener\">机器学习</a>领域的<a href=\"https://en.wikipedia.org/wiki/Ensemble_learning\" target=\"_blank\" rel=\"noopener\">集成</a><a href=\"https://en.wikipedia.org/wiki/Machine_learning\" target=\"_blank\" rel=\"noopener\">学习</a>。集合方法通过多数表决来组合许多单独分类器的预测。假设每个单独的分类器预测准确度略高于50％，那么他们的预测集合将远远大于他们的个人预测分数。</p>\n</blockquote>\n<h3 id=\"Bootstraping（自助抽样法）-Bagging（装袋算法）\"><a href=\"#Bootstraping（自助抽样法）-Bagging（装袋算法）\" class=\"headerlink\" title=\"Bootstraping（自助抽样法）/Bagging（装袋算法）\"></a>Bootstraping（自助抽样法）/Bagging（装袋算法）</h3><blockquote><p>给定一个大小为 $n$ 的训练集$D$，Bagging算法从中均匀、有放回地（即使用<a href=\"https://zh.wikipedia.org/wiki/%E8%87%AA%E5%8A%A9%E6%B3%95\" target=\"_blank\" rel=\"noopener\">自助抽样法</a>）选出 $m$ 个大小为  ${n}’$ 的子集 $D_{i}$，作为新的训练集。在这 $m$ 个训练集上使用分类、回归等算法，则可得到 $m$ 个模型，再通过取平均值、取多数票等方法，即可得到Bagging的结果。</p>\n<p>Bagging算法可与其他<a href=\"https://zh.wikipedia.org/wiki/%E7%BB%9F%E8%AE%A1%E5%88%86%E7%B1%BB\" target=\"_blank\" rel=\"noopener\">分类</a>、<a href=\"https://zh.wikipedia.org/wiki/%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90\" target=\"_blank\" rel=\"noopener\">回归</a>算法结合，提高其准确率、稳定性的同时，通过降低结果的<a href=\"https://zh.wikipedia.org/wiki/%E6%96%B9%E5%B7%AE\" target=\"_blank\" rel=\"noopener\">方差</a>，避免<a href=\"https://zh.wikipedia.org/wiki/%E8%BF%87%E6%8B%9F%E5%90%88\" target=\"_blank\" rel=\"noopener\">过拟合</a>的发生。</p>\n<footer><cite><a href=\"https://zh.wikipedia.org/wiki/Bagging%E7%AE%97%E6%B3%95\" target=\"_blank\" rel=\"noopener\">Bagging算法</a></cite></footer></blockquote>\n<h3 id=\"袋外误差\"><a href=\"#袋外误差\" class=\"headerlink\" title=\"袋外误差\"></a>袋外误差</h3><blockquote><p>最常用的一种是.632自助法，假设给定的数据集包含d个样本。该数据集有放回地抽样d次，产生d个样本的训练集。这样原数据样本中的某些样本很可能在该样本集中出现多次。没有进入该训练集的样本最终形成检验集（测试集）。 显然每个样本被选中的概率是1/d，因此未被选中的概率就是(1-1/d)，这样一个样本在训练集中没出现的概率就是d次都未被选中的概率，即(1-1/d)d。当d趋于无穷大时，这一概率就将趋近于e-1=0.368，所以留在训练集中的样本大概就占原来数据集的63.2%。</p>\n<footer><cite><a href=\"https://zh.wikipedia.org/wiki/%E8%87%AA%E5%8A%A9%E6%B3%95\" target=\"_blank\" rel=\"noopener\">.632自助法</a></cite></footer></blockquote>\n<h3 id=\"随机森林\"><a href=\"#随机森林\" class=\"headerlink\" title=\"随机森林\"></a>随机森林</h3><p>随机森林扩展了Bagging。随机森林在以决策树为基学习器构建Bagging集成的基础上，进一步在决策树的训练过程中引入了随机属性选择。</p>\n<blockquote>\n<p>传统决策树在选择划分属性时是在当前节点的属性集合（假定有 $d$ 个参数）中选择一个最优属性；</p>\n<p>而在随即森林中，对基决策树的每个节点，先从该节点的属性几何中随机选择一个包含 $k$ 的属性的子集，然后再从这个自己种选择一个最优属性用于划分。</p>\n<p>参数 $k$ 控制了随机性的引入程度：</p>\n<p>若令 $k=d$ ，则基决策树的构建与传统决策树相同；</p>\n<p>若令 $k=1$，则是随机选择一个属性用于划分；</p>\n<p>一般情况下，推荐值 $k=\\log_{2}{d}$</p>\n</blockquote>\n<p><strong>随机森林和bagging的主要差别在于，在随机森林中，分割的最佳特征是从一个随机特征子空间中选取的，而在bagging中，分割时将考虑所有特征。</strong></p>\n<h3 id=\"分类器\"><a href=\"#分类器\" class=\"headerlink\" title=\"分类器\"></a>分类器</h3><ul>\n<li><a href=\"https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestClassifier.html#sklearn.ensemble.RandomForestClassifier\" target=\"_blank\" rel=\"noopener\"><code>ensemble.RandomForestClassifier</code></a></li>\n<li><a href=\"https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.BaggingClassifier.html#sklearn.ensemble.BaggingClassifier\" target=\"_blank\" rel=\"noopener\"><code>ensemble.BaggingClassifier</code></a></li>\n<li><a href=\"https://scikit-learn.org/stable/modules/generated/sklearn.tree.DecisionTreeClassifier.html#sklearn.tree.DecisionTreeClassifier\" target=\"_blank\" rel=\"noopener\"><code>tree.DecisionTreeClassifier</code></a></li>\n</ul>\n<p>以下使用三种分类器，分别对数据进行分类预测。</p>\n<p><a href=\"credit_scoring_sample.csv\">credit_scoring_sample.csv</a></p>\n<p><strong>数据看起来像这样：</strong></p>\n<h5 id=\"目标变量\"><a href=\"#目标变量\" class=\"headerlink\" title=\"目标变量\"></a>目标变量</h5><ul>\n<li>SeriousDlqin2yrs - 该人在2年内长期拖延付款;二进制变量</li>\n</ul>\n<h5 id=\"特征\"><a href=\"#特征\" class=\"headerlink\" title=\"特征\"></a>特征</h5><table>\n<thead>\n<tr>\n<th>列名</th>\n<th>说明</th>\n<th>数据类型</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>age</td>\n<td>借款人的年龄（全年数）</td>\n<td>integer</td>\n</tr>\n<tr>\n<td>NumberOfTime30-59DaysPastDueNotWorse</td>\n<td>在过去两年中，一个人延迟偿还其他贷款超过30-59天（但不是更多）的次数</td>\n<td>integer</td>\n</tr>\n<tr>\n<td>DebtRatio</td>\n<td>每月付款（贷款，赡养费等）除以每月总收入，百分比</td>\n<td>float</td>\n</tr>\n<tr>\n<td>MonthlyIncome</td>\n<td>以美元计算的月收入</td>\n<td>float</td>\n</tr>\n<tr>\n<td>NumberOfTimes90DaysLate</td>\n<td>一个人延迟偿还其他贷款超过90天的次数</td>\n<td>integer</td>\n</tr>\n<tr>\n<td>NumberOfTime60-89DaysPastDueNotWorse</td>\n<td>在过去两年中，一个人延迟偿还其他贷款超过60-89天（但不是更多）的次数</td>\n<td>integer</td>\n</tr>\n<tr>\n<td>NumberOfDependents</td>\n<td>借款人家庭中的人数</td>\n<td>integer</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn.ensemble <span class=\"keyword\">import</span> RandomForestClassifier, BaggingClassifier</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn.model_selection <span class=\"keyword\">import</span> cross_val_score</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn.tree <span class=\"keyword\">import</span> DecisionTreeClassifier</span><br><span class=\"line\"></span><br><span class=\"line\">data = pd.read_csv(<span class=\"string\">'credit_scoring_sample.csv'</span>, sep=<span class=\"string\">\";\"</span>)</span><br><span class=\"line\"><span class=\"comment\"># 不包含目标值的列名集合</span></span><br><span class=\"line\">independent_columns_names = [x <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> data <span class=\"keyword\">if</span> x != <span class=\"string\">'SeriousDlqin2yrs'</span>]</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">impute_nan_with_median</span><span class=\"params\">(table)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"用表中每列的中位数替换NaN值\"\"\"</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> col <span class=\"keyword\">in</span> table.columns:</span><br><span class=\"line\">        table[col] = table[col].fillna(table[col].median())</span><br><span class=\"line\">    <span class=\"keyword\">return</span> table</span><br><span class=\"line\"></span><br><span class=\"line\">table = impute_nan_with_median(data)</span><br><span class=\"line\"></span><br><span class=\"line\">X = table[independent_columns_names]  <span class=\"comment\"># 数据（替换过NaN值）</span></span><br><span class=\"line\">y = table[<span class=\"string\">'SeriousDlqin2yrs'</span>]  <span class=\"comment\"># 目标值</span></span><br><span class=\"line\"></span><br><span class=\"line\">n_estimators = <span class=\"number\">200</span>  <span class=\"comment\"># 森林中树的数量</span></span><br><span class=\"line\">random_state = <span class=\"number\">17</span></span><br><span class=\"line\">scoring = <span class=\"string\">'roc_auc'</span></span><br><span class=\"line\">class_weight = <span class=\"string\">'balanced'</span></span><br><span class=\"line\"></span><br><span class=\"line\">dtc = DecisionTreeClassifier(class_weight=class_weight, random_state=random_state)</span><br><span class=\"line\">results = cross_val_score(dtc, X, y, scoring=scoring)</span><br><span class=\"line\">print(<span class=\"string\">\"决策树交叉验证精确度评分： &#123;:.2f&#125;%\"</span>.format(results.mean() * <span class=\"number\">100</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">bc = BaggingClassifier(base_estimator=DecisionTreeClassifier(), n_estimators=n_estimators, random_state=random_state)</span><br><span class=\"line\">results = cross_val_score(bc, X, y, scoring=scoring)</span><br><span class=\"line\">print(<span class=\"string\">\"Bagging交叉验证精确度评分： &#123;:.2f&#125;%\"</span>.format(results.mean() * <span class=\"number\">100</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">rfc = RandomForestClassifier(n_estimators=n_estimators, random_state=random_state, class_weight=class_weight)</span><br><span class=\"line\">results = cross_val_score(rfc, X, y, scoring=scoring)</span><br><span class=\"line\">print(<span class=\"string\">\"随机森林交叉验证精确度评分： &#123;:.2f&#125;%\"</span>.format(results.mean() * <span class=\"number\">100</span>))</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">决策树交叉验证精确度评分： 65.21%</span><br><span class=\"line\">Bagging交叉验证精确度评分： 80.41%</span><br><span class=\"line\">随机森林交叉验证精确度评分： 80.60%</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"集成\"><a href=\"#集成\" class=\"headerlink\" title=\"集成\"></a>集成</h3><h4 id=\"孔塞多陪审团定理\"><a href=\"#孔塞多陪审团定理\" class=\"headerlink\" title=\"孔塞多陪审团定理\"></a><a href=\"https://en.wikipedia.org/wiki/Condorcet%27s_jury_theorem\" target=\"_blank\" rel=\"noopener\">孔塞多陪审团定理</a></h4><p>如果评审团的每个成员做出独立判断，并且每个陪审员做出正确决策的概率高于0.5，那么整个评审团做出正确的总体决策的概率随着陪审员数量的增加而增加，并趋向于一。另一方面，如果每个陪审员判断正确的概率小于0.5，那么整个陪审团做出正确的总体决策的概率随着陪审员数量的增加而减少，并趋向于零。</p>\n<p>$\\mu = \\sum_{i=m}^{M}\\binom{N}{i} p^{i}(1-p)^{(N-i)}$</p>\n<ul>\n<li><strong>N</strong>为陪审员总数；</li>\n<li><strong>m</strong>是构成多数的最小值，即<strong>m</strong> = (N+1)/2；</li>\n<li><strong>p</strong>为评审员做出正确决策的概率；</li>\n<li><strong>μ</strong>是整个评审团做出正确决策的概率。</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> scipy.special <span class=\"keyword\">import</span> comb</span><br><span class=\"line\"></span><br><span class=\"line\">p = <span class=\"number\">0.8</span></span><br><span class=\"line\">N = <span class=\"number\">7</span></span><br><span class=\"line\">m = int((<span class=\"number\">1</span> + N) / <span class=\"number\">2</span>)</span><br><span class=\"line\">score = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(m, N + <span class=\"number\">1</span>, <span class=\"number\">1</span>):</span><br><span class=\"line\">    score += ((p ** i) * ((<span class=\"number\">1</span> - p) ** (N - i)) * comb(N, i))</span><br><span class=\"line\"><span class=\"comment\"># 96.67%</span></span><br><span class=\"line\">print(<span class=\"string\">\"&#123;:.2%&#125;\"</span>.format(score))</span><br></pre></td></tr></table></figure>\n<p><em>机器学习领域采用类似的思路以降低误差。</em></p>\n<blockquote>\n<p>Condorcet陪审团定理也用于<a href=\"https://en.wikipedia.org/wiki/Machine_learning\" target=\"_blank\" rel=\"noopener\">机器学习</a>领域的<a href=\"https://en.wikipedia.org/wiki/Ensemble_learning\" target=\"_blank\" rel=\"noopener\">集成</a><a href=\"https://en.wikipedia.org/wiki/Machine_learning\" target=\"_blank\" rel=\"noopener\">学习</a>。集合方法通过多数表决来组合许多单独分类器的预测。假设每个单独的分类器预测准确度略高于50％，那么他们的预测集合将远远大于他们的个人预测分数。</p>\n</blockquote>\n<h3 id=\"Bootstraping（自助抽样法）-Bagging（装袋算法）\"><a href=\"#Bootstraping（自助抽样法）-Bagging（装袋算法）\" class=\"headerlink\" title=\"Bootstraping（自助抽样法）/Bagging（装袋算法）\"></a>Bootstraping（自助抽样法）/Bagging（装袋算法）</h3><blockquote><p>给定一个大小为 $n$ 的训练集$D$，Bagging算法从中均匀、有放回地（即使用<a href=\"https://zh.wikipedia.org/wiki/%E8%87%AA%E5%8A%A9%E6%B3%95\" target=\"_blank\" rel=\"noopener\">自助抽样法</a>）选出 $m$ 个大小为  ${n}’$ 的子集 $D_{i}$，作为新的训练集。在这 $m$ 个训练集上使用分类、回归等算法，则可得到 $m$ 个模型，再通过取平均值、取多数票等方法，即可得到Bagging的结果。</p>\n<p>Bagging算法可与其他<a href=\"https://zh.wikipedia.org/wiki/%E7%BB%9F%E8%AE%A1%E5%88%86%E7%B1%BB\" target=\"_blank\" rel=\"noopener\">分类</a>、<a href=\"https://zh.wikipedia.org/wiki/%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90\" target=\"_blank\" rel=\"noopener\">回归</a>算法结合，提高其准确率、稳定性的同时，通过降低结果的<a href=\"https://zh.wikipedia.org/wiki/%E6%96%B9%E5%B7%AE\" target=\"_blank\" rel=\"noopener\">方差</a>，避免<a href=\"https://zh.wikipedia.org/wiki/%E8%BF%87%E6%8B%9F%E5%90%88\" target=\"_blank\" rel=\"noopener\">过拟合</a>的发生。</p>\n<footer><cite><a href=\"https://zh.wikipedia.org/wiki/Bagging%E7%AE%97%E6%B3%95\" target=\"_blank\" rel=\"noopener\">Bagging算法</a></cite></footer></blockquote>\n<h3 id=\"袋外误差\"><a href=\"#袋外误差\" class=\"headerlink\" title=\"袋外误差\"></a>袋外误差</h3><blockquote><p>最常用的一种是.632自助法，假设给定的数据集包含d个样本。该数据集有放回地抽样d次，产生d个样本的训练集。这样原数据样本中的某些样本很可能在该样本集中出现多次。没有进入该训练集的样本最终形成检验集（测试集）。 显然每个样本被选中的概率是1/d，因此未被选中的概率就是(1-1/d)，这样一个样本在训练集中没出现的概率就是d次都未被选中的概率，即(1-1/d)d。当d趋于无穷大时，这一概率就将趋近于e-1=0.368，所以留在训练集中的样本大概就占原来数据集的63.2%。</p>\n<footer><cite><a href=\"https://zh.wikipedia.org/wiki/%E8%87%AA%E5%8A%A9%E6%B3%95\" target=\"_blank\" rel=\"noopener\">.632自助法</a></cite></footer></blockquote>\n<h3 id=\"随机森林\"><a href=\"#随机森林\" class=\"headerlink\" title=\"随机森林\"></a>随机森林</h3><p>随机森林扩展了Bagging。随机森林在以决策树为基学习器构建Bagging集成的基础上，进一步在决策树的训练过程中引入了随机属性选择。</p>\n<blockquote>\n<p>传统决策树在选择划分属性时是在当前节点的属性集合（假定有 $d$ 个参数）中选择一个最优属性；</p>\n<p>而在随即森林中，对基决策树的每个节点，先从该节点的属性几何中随机选择一个包含 $k$ 的属性的子集，然后再从这个自己种选择一个最优属性用于划分。</p>\n<p>参数 $k$ 控制了随机性的引入程度：</p>\n<p>若令 $k=d$ ，则基决策树的构建与传统决策树相同；</p>\n<p>若令 $k=1$，则是随机选择一个属性用于划分；</p>\n<p>一般情况下，推荐值 $k=\\log_{2}{d}$</p>\n</blockquote>\n<p><strong>随机森林和bagging的主要差别在于，在随机森林中，分割的最佳特征是从一个随机特征子空间中选取的，而在bagging中，分割时将考虑所有特征。</strong></p>\n<h3 id=\"分类器\"><a href=\"#分类器\" class=\"headerlink\" title=\"分类器\"></a>分类器</h3><ul>\n<li><a href=\"https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestClassifier.html#sklearn.ensemble.RandomForestClassifier\" target=\"_blank\" rel=\"noopener\"><code>ensemble.RandomForestClassifier</code></a></li>\n<li><a href=\"https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.BaggingClassifier.html#sklearn.ensemble.BaggingClassifier\" target=\"_blank\" rel=\"noopener\"><code>ensemble.BaggingClassifier</code></a></li>\n<li><a href=\"https://scikit-learn.org/stable/modules/generated/sklearn.tree.DecisionTreeClassifier.html#sklearn.tree.DecisionTreeClassifier\" target=\"_blank\" rel=\"noopener\"><code>tree.DecisionTreeClassifier</code></a></li>\n</ul>\n<p>以下使用三种分类器，分别对数据进行分类预测。</p>\n<p><a href=\"credit_scoring_sample.csv\">credit_scoring_sample.csv</a></p>\n<p><strong>数据看起来像这样：</strong></p>\n<h5 id=\"目标变量\"><a href=\"#目标变量\" class=\"headerlink\" title=\"目标变量\"></a>目标变量</h5><ul>\n<li>SeriousDlqin2yrs - 该人在2年内长期拖延付款;二进制变量</li>\n</ul>\n<h5 id=\"特征\"><a href=\"#特征\" class=\"headerlink\" title=\"特征\"></a>特征</h5><table>\n<thead>\n<tr>\n<th>列名</th>\n<th>说明</th>\n<th>数据类型</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>age</td>\n<td>借款人的年龄（全年数）</td>\n<td>integer</td>\n</tr>\n<tr>\n<td>NumberOfTime30-59DaysPastDueNotWorse</td>\n<td>在过去两年中，一个人延迟偿还其他贷款超过30-59天（但不是更多）的次数</td>\n<td>integer</td>\n</tr>\n<tr>\n<td>DebtRatio</td>\n<td>每月付款（贷款，赡养费等）除以每月总收入，百分比</td>\n<td>float</td>\n</tr>\n<tr>\n<td>MonthlyIncome</td>\n<td>以美元计算的月收入</td>\n<td>float</td>\n</tr>\n<tr>\n<td>NumberOfTimes90DaysLate</td>\n<td>一个人延迟偿还其他贷款超过90天的次数</td>\n<td>integer</td>\n</tr>\n<tr>\n<td>NumberOfTime60-89DaysPastDueNotWorse</td>\n<td>在过去两年中，一个人延迟偿还其他贷款超过60-89天（但不是更多）的次数</td>\n<td>integer</td>\n</tr>\n<tr>\n<td>NumberOfDependents</td>\n<td>借款人家庭中的人数</td>\n<td>integer</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn.ensemble <span class=\"keyword\">import</span> RandomForestClassifier, BaggingClassifier</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn.model_selection <span class=\"keyword\">import</span> cross_val_score</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn.tree <span class=\"keyword\">import</span> DecisionTreeClassifier</span><br><span class=\"line\"></span><br><span class=\"line\">data = pd.read_csv(<span class=\"string\">'credit_scoring_sample.csv'</span>, sep=<span class=\"string\">\";\"</span>)</span><br><span class=\"line\"><span class=\"comment\"># 不包含目标值的列名集合</span></span><br><span class=\"line\">independent_columns_names = [x <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> data <span class=\"keyword\">if</span> x != <span class=\"string\">'SeriousDlqin2yrs'</span>]</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">impute_nan_with_median</span><span class=\"params\">(table)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"用表中每列的中位数替换NaN值\"\"\"</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> col <span class=\"keyword\">in</span> table.columns:</span><br><span class=\"line\">        table[col] = table[col].fillna(table[col].median())</span><br><span class=\"line\">    <span class=\"keyword\">return</span> table</span><br><span class=\"line\"></span><br><span class=\"line\">table = impute_nan_with_median(data)</span><br><span class=\"line\"></span><br><span class=\"line\">X = table[independent_columns_names]  <span class=\"comment\"># 数据（替换过NaN值）</span></span><br><span class=\"line\">y = table[<span class=\"string\">'SeriousDlqin2yrs'</span>]  <span class=\"comment\"># 目标值</span></span><br><span class=\"line\"></span><br><span class=\"line\">n_estimators = <span class=\"number\">200</span>  <span class=\"comment\"># 森林中树的数量</span></span><br><span class=\"line\">random_state = <span class=\"number\">17</span></span><br><span class=\"line\">scoring = <span class=\"string\">'roc_auc'</span></span><br><span class=\"line\">class_weight = <span class=\"string\">'balanced'</span></span><br><span class=\"line\"></span><br><span class=\"line\">dtc = DecisionTreeClassifier(class_weight=class_weight, random_state=random_state)</span><br><span class=\"line\">results = cross_val_score(dtc, X, y, scoring=scoring)</span><br><span class=\"line\">print(<span class=\"string\">\"决策树交叉验证精确度评分： &#123;:.2f&#125;%\"</span>.format(results.mean() * <span class=\"number\">100</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">bc = BaggingClassifier(base_estimator=DecisionTreeClassifier(), n_estimators=n_estimators, random_state=random_state)</span><br><span class=\"line\">results = cross_val_score(bc, X, y, scoring=scoring)</span><br><span class=\"line\">print(<span class=\"string\">\"Bagging交叉验证精确度评分： &#123;:.2f&#125;%\"</span>.format(results.mean() * <span class=\"number\">100</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">rfc = RandomForestClassifier(n_estimators=n_estimators, random_state=random_state, class_weight=class_weight)</span><br><span class=\"line\">results = cross_val_score(rfc, X, y, scoring=scoring)</span><br><span class=\"line\">print(<span class=\"string\">\"随机森林交叉验证精确度评分： &#123;:.2f&#125;%\"</span>.format(results.mean() * <span class=\"number\">100</span>))</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">决策树交叉验证精确度评分： 65.21%</span><br><span class=\"line\">Bagging交叉验证精确度评分： 80.41%</span><br><span class=\"line\">随机森林交叉验证精确度评分： 80.60%</span><br></pre></td></tr></table></figure>\n"},{"title":"机器学习开放课程：六、特征工程和特征选取","date":"2018-11-12T00:12:47.000Z","updated":"2018-11-11T16:00:00.000Z","typora-root-url":"机器学习开放课程：六、特征工程和特征选取","mathjax":true,"description":"<!—more—->","_content":"\n### 特征提取\n\n#### 文本\n\n在处理文本之前，必须tokenzie文本，也就是将文本切分为单元（token）。在最简单的情形下，token不过是单词。**因为直接按照单次来切分可能会损失一些信息，所以现在切分时更多的会考虑语言的特性（也就是语义和语境）。**\n\n接下来需要正则化数据。对文本而言，这涉及词干提取（stemming）和词形还原（lemmatization）；这是用来处理同一单词的不同形式的类似过程。\n\n[信息检索导论.pdf](信息检索导论.pdf)\n\n{% blockquote 信息检索导论, Christopher D. Manning,Prabhakar Raghavan %}\n词干还原（stemming）和词形归并（lemmatization）这两个术语所代表的意义是不同的。\n\n前者通常指的是一个很粗略的去除单词两端词缀的启发式过程，并且希望大部分时间它都能达到这个正确目的，这个过程也常常包括去除派生词缀。\n\n而词形归并通常指利用词汇表和词形分析来去除屈折词缀，从而返回词的原形或词典中的词的过程，返回的结果称为词元（lemma）。\n\n假如给定词条 saw，词干还原过程可能仅返回 s，而词形归并过程将返回 see 或者 saw，当然具体返回哪个词**取决于在当前上下文**中 saw 到底是动词还是名词。\n\n{% endblockquote %}\n\n{% blockquote https://zh.wikipedia.org/wiki/%E8%AF%8D%E5%B9%B2%E6%8F%90%E5%8F%96 词干提取 %}\n\n一个面向英语的词干提取器，例如，要识别字符串“cats”、“catlike”和“catty”是基于词根“cat”；“stemmer”、“stemming”和“stemmed”是基于词根“stem”。一根词干提取算法可以简化词 “fishing”、“fished”、“fish”和“fisher” 为同一个词根“fish”。\n\n{% endblockquote %}\n\n{% blockquote https://en.wikipedia.org/wiki/Lemmatisation Lemmatisation %}\n\n在计算语言学中，lemmatisation是基于其预期含义确定单词的[引理](https://en.wikipedia.org/wiki/Lemma_(morphology))的算法过程。与[词干化](https://en.wikipedia.org/wiki/Stemming)不同，词汇化取决于正确识别句子中的预期[词性](https://en.wikipedia.org/wiki/Part_of_speech)和词语的含义，以及围绕该句子的较大语境，例如邻近句子甚至整个文档。\n\n{% endblockquote %}\n\n{% blockquote https://zh.wikipedia.org/wiki/%E8%AF%8D%E8%A2%8B%E6%A8%A1%E5%9E%8B 词袋模型 %}\n\n此模型下，一段文本（比如一个句子或是一个文档）可以用一个装着这些词的袋子来表示，这种表示方式不考虑文法以及词的顺序。\n\n1. John likes to watch movies. Mary likes movies too.\n2. John also likes to watch football games.\n\n基于以上两个文件，可以建构出下列清单:\n\n```\n[\n    \"John\",\n    \"likes00\",\n    \"to\",\n    \"watch\",\n    \"movies\",\n    \"also\",\n    \"football\",\n    \"games\",\n    \"Mary\",\n    \"too\"\n]\n```\n\n此处有10个不同的词，使用清单的索引表示长度为10的向量，分别对应上面的两段文本。\n\n1. `[1, 2, 1, 1, 2, 0, 0, 0, 1, 1]`\n2. `[1, 1, 1, 1, 0, 1, 1, 1, 0, 0]`\n\n每个向量的索引内容对应到清单中词出现的次数。\n\n此向量表示法不会保存原始句子中词的顺序。该表示法有许多成功的应用，像是邮件过滤。\n\n{% endblockquote %}\n\n当使用类似词袋的算法时，我们丢失了文本中的单词顺序信息，这意味着向量化之后，“i have no cows”（我没有牛）和“no, i have cows”（没，我有牛）会变得一样，尽管事实上它们的意思截然相反。为了避免这个问题，我们可以转用[N元语法](https://zh.wikipedia.org/wiki/N%E5%85%83%E8%AF%AD%E6%B3%95)。\n\n```python CountVectorizer示例 https://scikit-learn.org/stable/modules/generated/sklearn.feature_extraction.text.CountVectorizer.html sklearn.feature_extraction.text.CountVectorizer\n>>> from sklearn.feature_extraction.text import CountVectorizer\n>>> corpus = [\n...     'This is the first document.',\n...     'This document is the second document.',\n...     'And this is the third one.',\n...     'Is this the first document?',\n... ]\n>>> vectorizer = CountVectorizer()\n>>> X = vectorizer.fit_transform(corpus)\n>>> print(vectorizer.get_feature_names())\n['and', 'document', 'first', 'is', 'one', 'second', 'the', 'third', 'this']\n>>> print(vectorizer.vocabulary_)\n{'this': 8, 'is': 3, 'the': 6, 'first': 2, 'document': 1, 'second': 5, 'and': 0, 'third': 7, 'one': 4}\n>>> print(X.toarray())  \n[[0 1 1 1 0 0 1 0 1]\n [0 2 0 1 0 1 1 0 1]\n [1 0 0 1 1 0 1 1 1]\n [0 1 1 1 0 0 1 0 1]]\n```\n\n#### 图像\n\n{% blockquote https://zh.wikipedia.org/wiki/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C 卷积神经网络 %}\n\n卷积神经网络由一个或多个卷积层和顶端的全连通层（对应经典的神经网络）组成，同时也包括关联权重和[池化](https://zh.wikipedia.org/w/index.php?title=%E6%B1%A0%E5%8C%96&action=edit&redlink=1)层（pooling layer）。这一结构使得卷积神经网络能够利用输入数据的二维结构。与其他深度学习结构相比，卷积神经网络在图像和[语音识别](https://zh.wikipedia.org/wiki/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB)方面能够给出更好的结果。\n\n**卷积层**\n\n卷积层（Convolutional layer），卷积神经网上中每层卷积层由若干卷积单元组成，每个卷积单元的参数都是通过[反向传播算法](https://zh.wikipedia.org/wiki/%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95)最优化得到的。卷积运算的目的是提取输入的不同特征，第一层卷积层可能只能提取一些低级的特征如边缘、线条和角等层级，更多层的网路能从低级特征中迭代提取更复杂的特征。\n\n**池化层(Pooling Layer)**\n\n![img](314px-Max_pooling.png)\n\n每隔2个元素进行的2x2最大池化\n\n池化（Pooling）是卷积神经网络中另一个重要的概念，它实际上是一种形式的降采样。有多种不同形式的非线性池化函数，而其中**“最大池化（Max pooling）”**是最为常见的。它是将输入的图像划分为若干个矩形区域，对每个子区域输出最大值。\n\n直觉上，这种机制能够有效地原因在于，在发现一个特征之后，它的精确位置远不及它和其他特征的相对位置的关系重要。池化层会不断地减小数据的空间大小，因此参数的数量和计算量也会下降，这在一定程度上也控制了[过拟合](https://zh.wikipedia.org/wiki/%E8%BF%87%E6%8B%9F%E5%90%88)。通常来说，CNN的卷积层之间都会周期性地插入池化层。\n\n池化层通常会分别作用于每个输入的特征并减小其大小。目前最常用形式的池化层是每隔2个元素从图像划分出$2\\times2$的区块，然后对每个区块中的4个数取最大值。这将会减少75%的数据量。\n\n除了最大池化之外，池化层也可以使用其他池化函数，例如“平均池化”甚至“[L2-范数](https://zh.wikipedia.org/wiki/Lp%E7%A9%BA%E9%97%B4#.E9.95.BF.E5.BA.A6.E3.80.81.E8.B7.9D.E7.A6.BB.E4.B8.8E.E8.8C.83.E6.95.B0)池化”等。过去，平均池化的使用曾经较为广泛，但是最近由于最大池化在实践中的表现更好，平均池化已经不太常用。\n\n*由于池化层过快地减少了数据的大小，目前文献中的趋势是使用较小的池化滤镜，甚至不再使用池化层。*\n\n{% endblockquote %}\n\n[pytesseract](https://github.com/madmaze/pytesseract)是python的光学字符识别（OCR）工具。也就是说，它将识别并“读取”嵌入图像中的文本。\n\n#### 地理空间数据\n\n可以通过访问外部API（谷歌地图或OpenStreetMap）进行 *地理编码（由地址重建坐标点）*和*逆地理编码（由坐标点重建地址）*的互逆操作。很幸运，[geopy](https://github.com/geopy/geopy)之类的通用库封装了这些外部服务。\n\n>  处理地理编码时，别忘了地址可能包含错误，因此需要清洗数据。坐标的错误更少，但由于GPS噪声或特定地点（比如隧道、商业区）的低精确度，可能导致位置不正确。如果数据源是移动设备，地理位置可能并不是由GPS决定的，而是由该区域的WiFi网络决定的，这会导致空间中的空洞和远距离传送。\n>\n> 地点常常位于许多基础设施之间。因此，你可以充分发挥想象力，基于生活经验和领域知识发明特征：地点到地铁口的接近程度，建筑物中的商户数，到最近的商店的距离，周边的ATM数目，等等。就任何任务而言，你很容易想到几十个特征并从不同的外部资源中提取它们。就城市以外的问题而言，你可以考虑来自更专门的数据源的特征，比如海拔。\n>\n> 如果两个以上的地名相互连接，可能有必要基于地点之间的路由提取特征。比如，距离（直线距离和基于路由图计算得出的道路距离），转弯数（包括左转和右转的比例），红路灯数，交叉路口数，桥梁数。在我自己遇到的一个任务中，我生成了一个称为“道路复杂度”的特征，该特征计算基于图得出的距离除以最大公因数。\n\n#### 日期和时间\n\n> 一般而言，处理时序数据时，最好有一份包含公众节假日、异常天气情况及其他重要事件的日历。\n\n#### 时序，web，等等\n\n对于时序的处理可以参考：[tsfresh](https://github.com/blue-yonder/tsfresh) *基于可扩展假设检验的时间序列特征提取*\n\n对于 `user-agents` 的处理可以参考：[python-user-agents](https://github.com/selwin/python-user-agents)\n\n下一个有用的特征是IP地址，基于该数据可以提取国家，乃至城市、网络运营商、连接类型（是否为移动网络）。**但是代理和数据库过期导致该特征可能包含噪声。**\n\n> IP地址数据和`Accept-Language`是一对良好的组合：如果用户的IP地址显示在智利，而浏览器的本地化设为`ru_RU`（俄罗斯），该用户的所在地并不清晰，需要查看对应的特征栏`is_traveler_or_proxy_user`（是旅行者还是代理用户）。\n\n### 特征转换\n\n#### 正则化和改变分布\n\n##### 对数据做正态性检验\n\n**[零假设](https://zh.wikipedia.org/wiki/%E9%9B%B6%E5%81%87%E8%AE%BE)（$H_{0}$）**是普遍接受的事实。比如说抛硬币正反面出现的可能性均为50%。\n\n> 零假设可以被认为是*可归因的*假设。这意味着您可以使其无效或拒绝它。\n\n**替代假设（对立假设、[备择假设](https://zh.wikipedia.org/w/index.php?title=%E5%A4%87%E6%8B%A9%E5%81%87%E8%AE%BE&action=edit&redlink=1)）**。是零假设的替代。比如说你提出抛硬币正反面出现的可能性分别是30%和70%。那么你提出的这个观点就是替代假设。\n\n**拒绝零假设**：证明零假设是错误的，这时使用**替代假设**所替代。\n\n{% blockquote https://www.statisticshowto.datasciencecentral.com/support-or-reject-null-hypothesis/ What does it mean to reject the null hypothesis? %}\n\n例如，假设您认为某种药物可能导致一系列近期心脏病发作。该制药公司认为这种药物是安全的。零假设始终是公认的假设; 在这个例子中，药物在市场上，人们正在使用它，并且通常认为它是安全的。因此，零假设是药物是安全的。另一种假设 - 你想要取代零假设的假设，就是药物*不是*安全。在这种情况下拒绝零假设意味着您必须证明药物不安全。\n\n{% endblockquote %}\n\n###### p值定义\n\n在假设检验中使用 p值 来帮助支持或拒绝零假设。p值对于零假设来说是一个证据。**p值越小，拒绝零假设的证据就越强。**\n\np值表示为小数，但如果将它们转换为百分比，可能更容易理解它们是什么。\n\n> 例如，p值0.0254是2.54％。这意味着您的结果有可能是2.54％随机的（即偶然发生）。\n>\n> 另一方面，大的p值为.9（90％）意味着您的结果有90％的概率是完全随机的，而不是由于实验中的任何内容。\n>\n> 因此，p值越小，结果越重要（“显着”）。\n\n运行假设检验时，将测试中的p值与运行测试时选择的alpha值进行比较。alpha值也可以写为百分比。\n\n###### p值与alpha级别\n\nalpha级别由研究人员控制，并与置信水平相关。通过从100％减去置信度来获得alpha级别。\n\n> 例如，如果您希望对您的研究有98％的信心，那么α水平将为2％（100％ - 98％）。\n>\n> 当您运行假设检验时，测试将为您提供p的值。将该值与您选择的alpha级别进行比较。\n>\n> 例如，假设您选择了5％（0.05）的alpha级别。如果测试结果给你：\n>\n> * 小p（≤0.05）拒绝零假设。这是零假设无效的有力证据。\n> * 大p（> 0.05）表示备用假设很弱，因此您不会拒绝零假设。\n\n###### 如果我没有Alpha级别怎么办？\n\n在理想的世界中，你将拥有一个alpha级别。但是如果你没有的话，仍然可以使用以下粗略的指导方针来决定是否支持或拒绝原假设：\n\n- 如果`p>.10`→“不重要”\n- 如果`p≤.10`→“略显重要”\n- 如果`p≤0.55`→“显着”\n- 如果`p≤0.01`→“非常重要”。\n\n{% blockquote https://www.statisticshowto.datasciencecentral.com/what-is-an-alpha-level/#alphawhy Why is an Alpha Level of .05 commonly used? %}\n\n###### 为什么常用的alpha级别为.05？\n\n看到alpha级别是产生Type I错误的概率，我们认为这个区域尽可能小是合理的。例如，如果我们将alpha级别设置为10％，那么我们很可能会错误地拒绝原假设，而1％的alpha级别会使该区域变小。那么为什么不使用一个小区域而不是标准的5％呢？\n\nalpha级别越小，拒绝原假设的区域越小。因此，如果你有一个很小的区域，那么你有可能不会拒绝空位，实际上你应该这样做。这是Type II错误。\n\n换句话说，你尝试避免类型I错误的次数越多，第二类错误就越容易发生。科学家们发现5％的α水平是这两个问题之间的良好平衡。\n\n{% endblockquote %}\n\n{% blockquote https://zh.wikipedia.org/wiki/%E7%AC%AC%E4%B8%80%E5%9E%8B%E5%8F%8A%E7%AC%AC%E4%BA%8C%E5%9E%8B%E9%8C%AF%E8%AA%A4 第一型及第二型錯誤 %}\n\n* 若零假设事实上成立，但统计检验的结果不支持零假设（拒绝零假设），这种错误称为**第一型错误**。\n\n* 若零假设事实上不成立，但统计检验的结果支持零假设（接受零假设），这种错误称为**第二型错误**。\n\n以利用验孕棒验孕为例，此时未怀孕为零假设。\n\n若用验孕棒为一位未怀孕的女士验孕，结果是已怀孕，这是**第一型错误**。\n\n若用验孕棒为一位孕妇验孕，结果是未怀孕，这是**第二型错误**。\n\n{% endblockquote %}\n\n##### 正态性检验示例\n\n**[`scipy.stats.shapiro`](http://scipy.github.io/devdocs/generated/scipy.stats.shapiro.html)**\n\n> 对于N> 5000，W检验统计量是准确的，但p值可能不是。\n\n```python shapiro https://docs.scipy.org/doc/numpy-1.15.0/reference/generated/numpy.random.normal.html scipy.stats.shapiro\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom scipy.stats import shapiro\n\nnp.random.seed(17)\nmu, sigma = 0, 0.1\ns = np.random.normal(mu, sigma, 1000)\ncount, bins, ignored = plt.hist(s, 30, density=True)\nplt.plot(bins, 1 / (sigma * np.sqrt(2 * np.pi)) *\n         np.exp(- (bins - mu) ** 2 / (2 * sigma ** 2)),\n         linewidth=2, color='r')\nplt.show()\n\nprint(shapiro(s))\n```\n\n![1542007030968](1542007030968.png)\n\n```\n(0.9982456564903259, 0.401098370552063)\n```\n\n上述代码得到的 p值 已经远远大于 0.1 了，表示这个结果完全不用采纳。维持原有 零假设 也就是这是一个正态分布的假设。\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/机器学习开放课程：六、特征工程和特征选取.md","raw":"---\ntitle: 机器学习开放课程：六、特征工程和特征选取\ndate: 2018-11-12 08:12:47\nupdated: 2018-11-12\ntags:\n - 编程\n - Python\n - 机器学习\n - sklearn.feature_extraction.text.CountVectorizer\n - pytesseract\n - OCR tool for python\n - geopy\n - tsfresh\n - scipy.stats.shapiro\n - 零假设\n - p值\n - alpha级别\ncategories:\n - 编程\n - Python\n - 机器学习\ntypora-root-url: 机器学习开放课程：六、特征工程和特征选取\nmathjax: true\ndescription: <!—more—->\n---\n\n### 特征提取\n\n#### 文本\n\n在处理文本之前，必须tokenzie文本，也就是将文本切分为单元（token）。在最简单的情形下，token不过是单词。**因为直接按照单次来切分可能会损失一些信息，所以现在切分时更多的会考虑语言的特性（也就是语义和语境）。**\n\n接下来需要正则化数据。对文本而言，这涉及词干提取（stemming）和词形还原（lemmatization）；这是用来处理同一单词的不同形式的类似过程。\n\n[信息检索导论.pdf](信息检索导论.pdf)\n\n{% blockquote 信息检索导论, Christopher D. Manning,Prabhakar Raghavan %}\n词干还原（stemming）和词形归并（lemmatization）这两个术语所代表的意义是不同的。\n\n前者通常指的是一个很粗略的去除单词两端词缀的启发式过程，并且希望大部分时间它都能达到这个正确目的，这个过程也常常包括去除派生词缀。\n\n而词形归并通常指利用词汇表和词形分析来去除屈折词缀，从而返回词的原形或词典中的词的过程，返回的结果称为词元（lemma）。\n\n假如给定词条 saw，词干还原过程可能仅返回 s，而词形归并过程将返回 see 或者 saw，当然具体返回哪个词**取决于在当前上下文**中 saw 到底是动词还是名词。\n\n{% endblockquote %}\n\n{% blockquote https://zh.wikipedia.org/wiki/%E8%AF%8D%E5%B9%B2%E6%8F%90%E5%8F%96 词干提取 %}\n\n一个面向英语的词干提取器，例如，要识别字符串“cats”、“catlike”和“catty”是基于词根“cat”；“stemmer”、“stemming”和“stemmed”是基于词根“stem”。一根词干提取算法可以简化词 “fishing”、“fished”、“fish”和“fisher” 为同一个词根“fish”。\n\n{% endblockquote %}\n\n{% blockquote https://en.wikipedia.org/wiki/Lemmatisation Lemmatisation %}\n\n在计算语言学中，lemmatisation是基于其预期含义确定单词的[引理](https://en.wikipedia.org/wiki/Lemma_(morphology))的算法过程。与[词干化](https://en.wikipedia.org/wiki/Stemming)不同，词汇化取决于正确识别句子中的预期[词性](https://en.wikipedia.org/wiki/Part_of_speech)和词语的含义，以及围绕该句子的较大语境，例如邻近句子甚至整个文档。\n\n{% endblockquote %}\n\n{% blockquote https://zh.wikipedia.org/wiki/%E8%AF%8D%E8%A2%8B%E6%A8%A1%E5%9E%8B 词袋模型 %}\n\n此模型下，一段文本（比如一个句子或是一个文档）可以用一个装着这些词的袋子来表示，这种表示方式不考虑文法以及词的顺序。\n\n1. John likes to watch movies. Mary likes movies too.\n2. John also likes to watch football games.\n\n基于以上两个文件，可以建构出下列清单:\n\n```\n[\n    \"John\",\n    \"likes00\",\n    \"to\",\n    \"watch\",\n    \"movies\",\n    \"also\",\n    \"football\",\n    \"games\",\n    \"Mary\",\n    \"too\"\n]\n```\n\n此处有10个不同的词，使用清单的索引表示长度为10的向量，分别对应上面的两段文本。\n\n1. `[1, 2, 1, 1, 2, 0, 0, 0, 1, 1]`\n2. `[1, 1, 1, 1, 0, 1, 1, 1, 0, 0]`\n\n每个向量的索引内容对应到清单中词出现的次数。\n\n此向量表示法不会保存原始句子中词的顺序。该表示法有许多成功的应用，像是邮件过滤。\n\n{% endblockquote %}\n\n当使用类似词袋的算法时，我们丢失了文本中的单词顺序信息，这意味着向量化之后，“i have no cows”（我没有牛）和“no, i have cows”（没，我有牛）会变得一样，尽管事实上它们的意思截然相反。为了避免这个问题，我们可以转用[N元语法](https://zh.wikipedia.org/wiki/N%E5%85%83%E8%AF%AD%E6%B3%95)。\n\n```python CountVectorizer示例 https://scikit-learn.org/stable/modules/generated/sklearn.feature_extraction.text.CountVectorizer.html sklearn.feature_extraction.text.CountVectorizer\n>>> from sklearn.feature_extraction.text import CountVectorizer\n>>> corpus = [\n...     'This is the first document.',\n...     'This document is the second document.',\n...     'And this is the third one.',\n...     'Is this the first document?',\n... ]\n>>> vectorizer = CountVectorizer()\n>>> X = vectorizer.fit_transform(corpus)\n>>> print(vectorizer.get_feature_names())\n['and', 'document', 'first', 'is', 'one', 'second', 'the', 'third', 'this']\n>>> print(vectorizer.vocabulary_)\n{'this': 8, 'is': 3, 'the': 6, 'first': 2, 'document': 1, 'second': 5, 'and': 0, 'third': 7, 'one': 4}\n>>> print(X.toarray())  \n[[0 1 1 1 0 0 1 0 1]\n [0 2 0 1 0 1 1 0 1]\n [1 0 0 1 1 0 1 1 1]\n [0 1 1 1 0 0 1 0 1]]\n```\n\n#### 图像\n\n{% blockquote https://zh.wikipedia.org/wiki/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C 卷积神经网络 %}\n\n卷积神经网络由一个或多个卷积层和顶端的全连通层（对应经典的神经网络）组成，同时也包括关联权重和[池化](https://zh.wikipedia.org/w/index.php?title=%E6%B1%A0%E5%8C%96&action=edit&redlink=1)层（pooling layer）。这一结构使得卷积神经网络能够利用输入数据的二维结构。与其他深度学习结构相比，卷积神经网络在图像和[语音识别](https://zh.wikipedia.org/wiki/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB)方面能够给出更好的结果。\n\n**卷积层**\n\n卷积层（Convolutional layer），卷积神经网上中每层卷积层由若干卷积单元组成，每个卷积单元的参数都是通过[反向传播算法](https://zh.wikipedia.org/wiki/%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95)最优化得到的。卷积运算的目的是提取输入的不同特征，第一层卷积层可能只能提取一些低级的特征如边缘、线条和角等层级，更多层的网路能从低级特征中迭代提取更复杂的特征。\n\n**池化层(Pooling Layer)**\n\n![img](314px-Max_pooling.png)\n\n每隔2个元素进行的2x2最大池化\n\n池化（Pooling）是卷积神经网络中另一个重要的概念，它实际上是一种形式的降采样。有多种不同形式的非线性池化函数，而其中**“最大池化（Max pooling）”**是最为常见的。它是将输入的图像划分为若干个矩形区域，对每个子区域输出最大值。\n\n直觉上，这种机制能够有效地原因在于，在发现一个特征之后，它的精确位置远不及它和其他特征的相对位置的关系重要。池化层会不断地减小数据的空间大小，因此参数的数量和计算量也会下降，这在一定程度上也控制了[过拟合](https://zh.wikipedia.org/wiki/%E8%BF%87%E6%8B%9F%E5%90%88)。通常来说，CNN的卷积层之间都会周期性地插入池化层。\n\n池化层通常会分别作用于每个输入的特征并减小其大小。目前最常用形式的池化层是每隔2个元素从图像划分出$2\\times2$的区块，然后对每个区块中的4个数取最大值。这将会减少75%的数据量。\n\n除了最大池化之外，池化层也可以使用其他池化函数，例如“平均池化”甚至“[L2-范数](https://zh.wikipedia.org/wiki/Lp%E7%A9%BA%E9%97%B4#.E9.95.BF.E5.BA.A6.E3.80.81.E8.B7.9D.E7.A6.BB.E4.B8.8E.E8.8C.83.E6.95.B0)池化”等。过去，平均池化的使用曾经较为广泛，但是最近由于最大池化在实践中的表现更好，平均池化已经不太常用。\n\n*由于池化层过快地减少了数据的大小，目前文献中的趋势是使用较小的池化滤镜，甚至不再使用池化层。*\n\n{% endblockquote %}\n\n[pytesseract](https://github.com/madmaze/pytesseract)是python的光学字符识别（OCR）工具。也就是说，它将识别并“读取”嵌入图像中的文本。\n\n#### 地理空间数据\n\n可以通过访问外部API（谷歌地图或OpenStreetMap）进行 *地理编码（由地址重建坐标点）*和*逆地理编码（由坐标点重建地址）*的互逆操作。很幸运，[geopy](https://github.com/geopy/geopy)之类的通用库封装了这些外部服务。\n\n>  处理地理编码时，别忘了地址可能包含错误，因此需要清洗数据。坐标的错误更少，但由于GPS噪声或特定地点（比如隧道、商业区）的低精确度，可能导致位置不正确。如果数据源是移动设备，地理位置可能并不是由GPS决定的，而是由该区域的WiFi网络决定的，这会导致空间中的空洞和远距离传送。\n>\n> 地点常常位于许多基础设施之间。因此，你可以充分发挥想象力，基于生活经验和领域知识发明特征：地点到地铁口的接近程度，建筑物中的商户数，到最近的商店的距离，周边的ATM数目，等等。就任何任务而言，你很容易想到几十个特征并从不同的外部资源中提取它们。就城市以外的问题而言，你可以考虑来自更专门的数据源的特征，比如海拔。\n>\n> 如果两个以上的地名相互连接，可能有必要基于地点之间的路由提取特征。比如，距离（直线距离和基于路由图计算得出的道路距离），转弯数（包括左转和右转的比例），红路灯数，交叉路口数，桥梁数。在我自己遇到的一个任务中，我生成了一个称为“道路复杂度”的特征，该特征计算基于图得出的距离除以最大公因数。\n\n#### 日期和时间\n\n> 一般而言，处理时序数据时，最好有一份包含公众节假日、异常天气情况及其他重要事件的日历。\n\n#### 时序，web，等等\n\n对于时序的处理可以参考：[tsfresh](https://github.com/blue-yonder/tsfresh) *基于可扩展假设检验的时间序列特征提取*\n\n对于 `user-agents` 的处理可以参考：[python-user-agents](https://github.com/selwin/python-user-agents)\n\n下一个有用的特征是IP地址，基于该数据可以提取国家，乃至城市、网络运营商、连接类型（是否为移动网络）。**但是代理和数据库过期导致该特征可能包含噪声。**\n\n> IP地址数据和`Accept-Language`是一对良好的组合：如果用户的IP地址显示在智利，而浏览器的本地化设为`ru_RU`（俄罗斯），该用户的所在地并不清晰，需要查看对应的特征栏`is_traveler_or_proxy_user`（是旅行者还是代理用户）。\n\n### 特征转换\n\n#### 正则化和改变分布\n\n##### 对数据做正态性检验\n\n**[零假设](https://zh.wikipedia.org/wiki/%E9%9B%B6%E5%81%87%E8%AE%BE)（$H_{0}$）**是普遍接受的事实。比如说抛硬币正反面出现的可能性均为50%。\n\n> 零假设可以被认为是*可归因的*假设。这意味着您可以使其无效或拒绝它。\n\n**替代假设（对立假设、[备择假设](https://zh.wikipedia.org/w/index.php?title=%E5%A4%87%E6%8B%A9%E5%81%87%E8%AE%BE&action=edit&redlink=1)）**。是零假设的替代。比如说你提出抛硬币正反面出现的可能性分别是30%和70%。那么你提出的这个观点就是替代假设。\n\n**拒绝零假设**：证明零假设是错误的，这时使用**替代假设**所替代。\n\n{% blockquote https://www.statisticshowto.datasciencecentral.com/support-or-reject-null-hypothesis/ What does it mean to reject the null hypothesis? %}\n\n例如，假设您认为某种药物可能导致一系列近期心脏病发作。该制药公司认为这种药物是安全的。零假设始终是公认的假设; 在这个例子中，药物在市场上，人们正在使用它，并且通常认为它是安全的。因此，零假设是药物是安全的。另一种假设 - 你想要取代零假设的假设，就是药物*不是*安全。在这种情况下拒绝零假设意味着您必须证明药物不安全。\n\n{% endblockquote %}\n\n###### p值定义\n\n在假设检验中使用 p值 来帮助支持或拒绝零假设。p值对于零假设来说是一个证据。**p值越小，拒绝零假设的证据就越强。**\n\np值表示为小数，但如果将它们转换为百分比，可能更容易理解它们是什么。\n\n> 例如，p值0.0254是2.54％。这意味着您的结果有可能是2.54％随机的（即偶然发生）。\n>\n> 另一方面，大的p值为.9（90％）意味着您的结果有90％的概率是完全随机的，而不是由于实验中的任何内容。\n>\n> 因此，p值越小，结果越重要（“显着”）。\n\n运行假设检验时，将测试中的p值与运行测试时选择的alpha值进行比较。alpha值也可以写为百分比。\n\n###### p值与alpha级别\n\nalpha级别由研究人员控制，并与置信水平相关。通过从100％减去置信度来获得alpha级别。\n\n> 例如，如果您希望对您的研究有98％的信心，那么α水平将为2％（100％ - 98％）。\n>\n> 当您运行假设检验时，测试将为您提供p的值。将该值与您选择的alpha级别进行比较。\n>\n> 例如，假设您选择了5％（0.05）的alpha级别。如果测试结果给你：\n>\n> * 小p（≤0.05）拒绝零假设。这是零假设无效的有力证据。\n> * 大p（> 0.05）表示备用假设很弱，因此您不会拒绝零假设。\n\n###### 如果我没有Alpha级别怎么办？\n\n在理想的世界中，你将拥有一个alpha级别。但是如果你没有的话，仍然可以使用以下粗略的指导方针来决定是否支持或拒绝原假设：\n\n- 如果`p>.10`→“不重要”\n- 如果`p≤.10`→“略显重要”\n- 如果`p≤0.55`→“显着”\n- 如果`p≤0.01`→“非常重要”。\n\n{% blockquote https://www.statisticshowto.datasciencecentral.com/what-is-an-alpha-level/#alphawhy Why is an Alpha Level of .05 commonly used? %}\n\n###### 为什么常用的alpha级别为.05？\n\n看到alpha级别是产生Type I错误的概率，我们认为这个区域尽可能小是合理的。例如，如果我们将alpha级别设置为10％，那么我们很可能会错误地拒绝原假设，而1％的alpha级别会使该区域变小。那么为什么不使用一个小区域而不是标准的5％呢？\n\nalpha级别越小，拒绝原假设的区域越小。因此，如果你有一个很小的区域，那么你有可能不会拒绝空位，实际上你应该这样做。这是Type II错误。\n\n换句话说，你尝试避免类型I错误的次数越多，第二类错误就越容易发生。科学家们发现5％的α水平是这两个问题之间的良好平衡。\n\n{% endblockquote %}\n\n{% blockquote https://zh.wikipedia.org/wiki/%E7%AC%AC%E4%B8%80%E5%9E%8B%E5%8F%8A%E7%AC%AC%E4%BA%8C%E5%9E%8B%E9%8C%AF%E8%AA%A4 第一型及第二型錯誤 %}\n\n* 若零假设事实上成立，但统计检验的结果不支持零假设（拒绝零假设），这种错误称为**第一型错误**。\n\n* 若零假设事实上不成立，但统计检验的结果支持零假设（接受零假设），这种错误称为**第二型错误**。\n\n以利用验孕棒验孕为例，此时未怀孕为零假设。\n\n若用验孕棒为一位未怀孕的女士验孕，结果是已怀孕，这是**第一型错误**。\n\n若用验孕棒为一位孕妇验孕，结果是未怀孕，这是**第二型错误**。\n\n{% endblockquote %}\n\n##### 正态性检验示例\n\n**[`scipy.stats.shapiro`](http://scipy.github.io/devdocs/generated/scipy.stats.shapiro.html)**\n\n> 对于N> 5000，W检验统计量是准确的，但p值可能不是。\n\n```python shapiro https://docs.scipy.org/doc/numpy-1.15.0/reference/generated/numpy.random.normal.html scipy.stats.shapiro\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom scipy.stats import shapiro\n\nnp.random.seed(17)\nmu, sigma = 0, 0.1\ns = np.random.normal(mu, sigma, 1000)\ncount, bins, ignored = plt.hist(s, 30, density=True)\nplt.plot(bins, 1 / (sigma * np.sqrt(2 * np.pi)) *\n         np.exp(- (bins - mu) ** 2 / (2 * sigma ** 2)),\n         linewidth=2, color='r')\nplt.show()\n\nprint(shapiro(s))\n```\n\n![1542007030968](1542007030968.png)\n\n```\n(0.9982456564903259, 0.401098370552063)\n```\n\n上述代码得到的 p值 已经远远大于 0.1 了，表示这个结果完全不用采纳。维持原有 零假设 也就是这是一个正态分布的假设。\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"机器学习开放课程：六、特征工程和特征选取","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cjof51pki000jrguexvpf29ye","content":"<h3 id=\"特征提取\"><a href=\"#特征提取\" class=\"headerlink\" title=\"特征提取\"></a>特征提取</h3><h4 id=\"文本\"><a href=\"#文本\" class=\"headerlink\" title=\"文本\"></a>文本</h4><p>在处理文本之前，必须tokenzie文本，也就是将文本切分为单元（token）。在最简单的情形下，token不过是单词。<strong>因为直接按照单次来切分可能会损失一些信息，所以现在切分时更多的会考虑语言的特性（也就是语义和语境）。</strong></p>\n<p>接下来需要正则化数据。对文本而言，这涉及词干提取（stemming）和词形还原（lemmatization）；这是用来处理同一单词的不同形式的类似过程。</p>\n<p><a href=\"信息检索导论.pdf\">信息检索导论.pdf</a></p>\n<blockquote><p>词干还原（stemming）和词形归并（lemmatization）这两个术语所代表的意义是不同的。</p>\n<p>前者通常指的是一个很粗略的去除单词两端词缀的启发式过程，并且希望大部分时间它都能达到这个正确目的，这个过程也常常包括去除派生词缀。</p>\n<p>而词形归并通常指利用词汇表和词形分析来去除屈折词缀，从而返回词的原形或词典中的词的过程，返回的结果称为词元（lemma）。</p>\n<p>假如给定词条 saw，词干还原过程可能仅返回 s，而词形归并过程将返回 see 或者 saw，当然具体返回哪个词<strong>取决于在当前上下文</strong>中 saw 到底是动词还是名词。</p>\n<footer><strong>信息检索导论</strong><cite>Christopher D. Manning</cite></footer></blockquote>\n<blockquote><p>一个面向英语的词干提取器，例如，要识别字符串“cats”、“catlike”和“catty”是基于词根“cat”；“stemmer”、“stemming”和“stemmed”是基于词根“stem”。一根词干提取算法可以简化词 “fishing”、“fished”、“fish”和“fisher” 为同一个词根“fish”。</p>\n<footer><cite><a href=\"https://zh.wikipedia.org/wiki/%E8%AF%8D%E5%B9%B2%E6%8F%90%E5%8F%96\" target=\"_blank\" rel=\"noopener\">词干提取</a></cite></footer></blockquote>\n<blockquote><p>在计算语言学中，lemmatisation是基于其预期含义确定单词的<a href=\"https://en.wikipedia.org/wiki/Lemma_(morphology\" target=\"_blank\" rel=\"noopener\">引理</a>)的算法过程。与<a href=\"https://en.wikipedia.org/wiki/Stemming\" target=\"_blank\" rel=\"noopener\">词干化</a>不同，词汇化取决于正确识别句子中的预期<a href=\"https://en.wikipedia.org/wiki/Part_of_speech\" target=\"_blank\" rel=\"noopener\">词性</a>和词语的含义，以及围绕该句子的较大语境，例如邻近句子甚至整个文档。</p>\n<footer><cite><a href=\"https://en.wikipedia.org/wiki/Lemmatisation\" target=\"_blank\" rel=\"noopener\">Lemmatisation</a></cite></footer></blockquote>\n<blockquote><p>此模型下，一段文本（比如一个句子或是一个文档）可以用一个装着这些词的袋子来表示，这种表示方式不考虑文法以及词的顺序。</p>\n<ol>\n<li>John likes to watch movies. Mary likes movies too.</li>\n<li>John also likes to watch football games.</li>\n</ol>\n<p>基于以上两个文件，可以建构出下列清单:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">    &quot;John&quot;,</span><br><span class=\"line\">    &quot;likes00&quot;,</span><br><span class=\"line\">    &quot;to&quot;,</span><br><span class=\"line\">    &quot;watch&quot;,</span><br><span class=\"line\">    &quot;movies&quot;,</span><br><span class=\"line\">    &quot;also&quot;,</span><br><span class=\"line\">    &quot;football&quot;,</span><br><span class=\"line\">    &quot;games&quot;,</span><br><span class=\"line\">    &quot;Mary&quot;,</span><br><span class=\"line\">    &quot;too&quot;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>此处有10个不同的词，使用清单的索引表示长度为10的向量，分别对应上面的两段文本。</p>\n<ol>\n<li><code>[1, 2, 1, 1, 2, 0, 0, 0, 1, 1]</code></li>\n<li><code>[1, 1, 1, 1, 0, 1, 1, 1, 0, 0]</code></li>\n</ol>\n<p>每个向量的索引内容对应到清单中词出现的次数。</p>\n<p>此向量表示法不会保存原始句子中词的顺序。该表示法有许多成功的应用，像是邮件过滤。</p>\n<footer><cite><a href=\"https://zh.wikipedia.org/wiki/%E8%AF%8D%E8%A2%8B%E6%A8%A1%E5%9E%8B\" target=\"_blank\" rel=\"noopener\">词袋模型</a></cite></footer></blockquote>\n<p>当使用类似词袋的算法时，我们丢失了文本中的单词顺序信息，这意味着向量化之后，“i have no cows”（我没有牛）和“no, i have cows”（没，我有牛）会变得一样，尽管事实上它们的意思截然相反。为了避免这个问题，我们可以转用<a href=\"https://zh.wikipedia.org/wiki/N%E5%85%83%E8%AF%AD%E6%B3%95\" target=\"_blank\" rel=\"noopener\">N元语法</a>。</p>\n<figure class=\"highlight python\"><figcaption><span>CountVectorizer示例</span><a href=\"https://scikit-learn.org/stable/modules/generated/sklearn.feature_extraction.text.CountVectorizer.html\" target=\"_blank\" rel=\"noopener\">sklearn.feature_extraction.text.CountVectorizer</a></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> sklearn.feature_extraction.text <span class=\"keyword\">import</span> CountVectorizer</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>corpus = [</span><br><span class=\"line\"><span class=\"meta\">... </span>    <span class=\"string\">'This is the first document.'</span>,</span><br><span class=\"line\"><span class=\"meta\">... </span>    <span class=\"string\">'This document is the second document.'</span>,</span><br><span class=\"line\"><span class=\"meta\">... </span>    <span class=\"string\">'And this is the third one.'</span>,</span><br><span class=\"line\"><span class=\"meta\">... </span>    <span class=\"string\">'Is this the first document?'</span>,</span><br><span class=\"line\"><span class=\"meta\">... </span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>vectorizer = CountVectorizer()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>X = vectorizer.fit_transform(corpus)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(vectorizer.get_feature_names())</span><br><span class=\"line\">[<span class=\"string\">'and'</span>, <span class=\"string\">'document'</span>, <span class=\"string\">'first'</span>, <span class=\"string\">'is'</span>, <span class=\"string\">'one'</span>, <span class=\"string\">'second'</span>, <span class=\"string\">'the'</span>, <span class=\"string\">'third'</span>, <span class=\"string\">'this'</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(vectorizer.vocabulary_)</span><br><span class=\"line\">&#123;<span class=\"string\">'this'</span>: <span class=\"number\">8</span>, <span class=\"string\">'is'</span>: <span class=\"number\">3</span>, <span class=\"string\">'the'</span>: <span class=\"number\">6</span>, <span class=\"string\">'first'</span>: <span class=\"number\">2</span>, <span class=\"string\">'document'</span>: <span class=\"number\">1</span>, <span class=\"string\">'second'</span>: <span class=\"number\">5</span>, <span class=\"string\">'and'</span>: <span class=\"number\">0</span>, <span class=\"string\">'third'</span>: <span class=\"number\">7</span>, <span class=\"string\">'one'</span>: <span class=\"number\">4</span>&#125;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(X.toarray())  </span><br><span class=\"line\">[[<span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">1</span> <span class=\"number\">1</span> <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">0</span> <span class=\"number\">1</span>]</span><br><span class=\"line\"> [<span class=\"number\">0</span> <span class=\"number\">2</span> <span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">1</span> <span class=\"number\">0</span> <span class=\"number\">1</span>]</span><br><span class=\"line\"> [<span class=\"number\">1</span> <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">1</span> <span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">1</span> <span class=\"number\">1</span>]</span><br><span class=\"line\"> [<span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">1</span> <span class=\"number\">1</span> <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">0</span> <span class=\"number\">1</span>]]</span><br></pre></td></tr></table></figure>\n<h4 id=\"图像\"><a href=\"#图像\" class=\"headerlink\" title=\"图像\"></a>图像</h4><blockquote><p>卷积神经网络由一个或多个卷积层和顶端的全连通层（对应经典的神经网络）组成，同时也包括关联权重和<a href=\"https://zh.wikipedia.org/w/index.php?title=%E6%B1%A0%E5%8C%96&amp;action=edit&amp;redlink=1\" target=\"_blank\" rel=\"noopener\">池化</a>层（pooling layer）。这一结构使得卷积神经网络能够利用输入数据的二维结构。与其他深度学习结构相比，卷积神经网络在图像和<a href=\"https://zh.wikipedia.org/wiki/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB\" target=\"_blank\" rel=\"noopener\">语音识别</a>方面能够给出更好的结果。</p>\n<p><strong>卷积层</strong></p>\n<p>卷积层（Convolutional layer），卷积神经网上中每层卷积层由若干卷积单元组成，每个卷积单元的参数都是通过<a href=\"https://zh.wikipedia.org/wiki/%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95\" target=\"_blank\" rel=\"noopener\">反向传播算法</a>最优化得到的。卷积运算的目的是提取输入的不同特征，第一层卷积层可能只能提取一些低级的特征如边缘、线条和角等层级，更多层的网路能从低级特征中迭代提取更复杂的特征。</p>\n<p><strong>池化层(Pooling Layer)</strong></p>\n<p><img src=\"314px-Max_pooling.png\" alt=\"img\"></p>\n<p>每隔2个元素进行的2x2最大池化</p>\n<p>池化（Pooling）是卷积神经网络中另一个重要的概念，它实际上是一种形式的降采样。有多种不同形式的非线性池化函数，而其中<strong>“最大池化（Max pooling）”</strong>是最为常见的。它是将输入的图像划分为若干个矩形区域，对每个子区域输出最大值。</p>\n<p>直觉上，这种机制能够有效地原因在于，在发现一个特征之后，它的精确位置远不及它和其他特征的相对位置的关系重要。池化层会不断地减小数据的空间大小，因此参数的数量和计算量也会下降，这在一定程度上也控制了<a href=\"https://zh.wikipedia.org/wiki/%E8%BF%87%E6%8B%9F%E5%90%88\" target=\"_blank\" rel=\"noopener\">过拟合</a>。通常来说，CNN的卷积层之间都会周期性地插入池化层。</p>\n<p>池化层通常会分别作用于每个输入的特征并减小其大小。目前最常用形式的池化层是每隔2个元素从图像划分出$2\\times2$的区块，然后对每个区块中的4个数取最大值。这将会减少75%的数据量。</p>\n<p>除了最大池化之外，池化层也可以使用其他池化函数，例如“平均池化”甚至“<a href=\"https://zh.wikipedia.org/wiki/Lp%E7%A9%BA%E9%97%B4#.E9.95.BF.E5.BA.A6.E3.80.81.E8.B7.9D.E7.A6.BB.E4.B8.8E.E8.8C.83.E6.95.B0\" target=\"_blank\" rel=\"noopener\">L2-范数</a>池化”等。过去，平均池化的使用曾经较为广泛，但是最近由于最大池化在实践中的表现更好，平均池化已经不太常用。</p>\n<p><em>由于池化层过快地减少了数据的大小，目前文献中的趋势是使用较小的池化滤镜，甚至不再使用池化层。</em></p>\n<footer><cite><a href=\"https://zh.wikipedia.org/wiki/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C\" target=\"_blank\" rel=\"noopener\">卷积神经网络</a></cite></footer></blockquote>\n<p><a href=\"https://github.com/madmaze/pytesseract\" target=\"_blank\" rel=\"noopener\">pytesseract</a>是python的光学字符识别（OCR）工具。也就是说，它将识别并“读取”嵌入图像中的文本。</p>\n<h4 id=\"地理空间数据\"><a href=\"#地理空间数据\" class=\"headerlink\" title=\"地理空间数据\"></a>地理空间数据</h4><p>可以通过访问外部API（谷歌地图或OpenStreetMap）进行 <em>地理编码（由地址重建坐标点）</em>和<em>逆地理编码（由坐标点重建地址）</em>的互逆操作。很幸运，<a href=\"https://github.com/geopy/geopy\" target=\"_blank\" rel=\"noopener\">geopy</a>之类的通用库封装了这些外部服务。</p>\n<blockquote>\n<p> 处理地理编码时，别忘了地址可能包含错误，因此需要清洗数据。坐标的错误更少，但由于GPS噪声或特定地点（比如隧道、商业区）的低精确度，可能导致位置不正确。如果数据源是移动设备，地理位置可能并不是由GPS决定的，而是由该区域的WiFi网络决定的，这会导致空间中的空洞和远距离传送。</p>\n<p>地点常常位于许多基础设施之间。因此，你可以充分发挥想象力，基于生活经验和领域知识发明特征：地点到地铁口的接近程度，建筑物中的商户数，到最近的商店的距离，周边的ATM数目，等等。就任何任务而言，你很容易想到几十个特征并从不同的外部资源中提取它们。就城市以外的问题而言，你可以考虑来自更专门的数据源的特征，比如海拔。</p>\n<p>如果两个以上的地名相互连接，可能有必要基于地点之间的路由提取特征。比如，距离（直线距离和基于路由图计算得出的道路距离），转弯数（包括左转和右转的比例），红路灯数，交叉路口数，桥梁数。在我自己遇到的一个任务中，我生成了一个称为“道路复杂度”的特征，该特征计算基于图得出的距离除以最大公因数。</p>\n</blockquote>\n<h4 id=\"日期和时间\"><a href=\"#日期和时间\" class=\"headerlink\" title=\"日期和时间\"></a>日期和时间</h4><blockquote>\n<p>一般而言，处理时序数据时，最好有一份包含公众节假日、异常天气情况及其他重要事件的日历。</p>\n</blockquote>\n<h4 id=\"时序，web，等等\"><a href=\"#时序，web，等等\" class=\"headerlink\" title=\"时序，web，等等\"></a>时序，web，等等</h4><p>对于时序的处理可以参考：<a href=\"https://github.com/blue-yonder/tsfresh\" target=\"_blank\" rel=\"noopener\">tsfresh</a> <em>基于可扩展假设检验的时间序列特征提取</em></p>\n<p>对于 <code>user-agents</code> 的处理可以参考：<a href=\"https://github.com/selwin/python-user-agents\" target=\"_blank\" rel=\"noopener\">python-user-agents</a></p>\n<p>下一个有用的特征是IP地址，基于该数据可以提取国家，乃至城市、网络运营商、连接类型（是否为移动网络）。<strong>但是代理和数据库过期导致该特征可能包含噪声。</strong></p>\n<blockquote>\n<p>IP地址数据和<code>Accept-Language</code>是一对良好的组合：如果用户的IP地址显示在智利，而浏览器的本地化设为<code>ru_RU</code>（俄罗斯），该用户的所在地并不清晰，需要查看对应的特征栏<code>is_traveler_or_proxy_user</code>（是旅行者还是代理用户）。</p>\n</blockquote>\n<h3 id=\"特征转换\"><a href=\"#特征转换\" class=\"headerlink\" title=\"特征转换\"></a>特征转换</h3><h4 id=\"正则化和改变分布\"><a href=\"#正则化和改变分布\" class=\"headerlink\" title=\"正则化和改变分布\"></a>正则化和改变分布</h4><h5 id=\"对数据做正态性检验\"><a href=\"#对数据做正态性检验\" class=\"headerlink\" title=\"对数据做正态性检验\"></a>对数据做正态性检验</h5><p><strong><a href=\"https://zh.wikipedia.org/wiki/%E9%9B%B6%E5%81%87%E8%AE%BE\" target=\"_blank\" rel=\"noopener\">零假设</a>（$H_{0}$）</strong>是普遍接受的事实。比如说抛硬币正反面出现的可能性均为50%。</p>\n<blockquote>\n<p>零假设可以被认为是<em>可归因的</em>假设。这意味着您可以使其无效或拒绝它。</p>\n</blockquote>\n<p><strong>替代假设（对立假设、<a href=\"https://zh.wikipedia.org/w/index.php?title=%E5%A4%87%E6%8B%A9%E5%81%87%E8%AE%BE&amp;action=edit&amp;redlink=1\" target=\"_blank\" rel=\"noopener\">备择假设</a>）</strong>。是零假设的替代。比如说你提出抛硬币正反面出现的可能性分别是30%和70%。那么你提出的这个观点就是替代假设。</p>\n<p><strong>拒绝零假设</strong>：证明零假设是错误的，这时使用<strong>替代假设</strong>所替代。</p>\n<blockquote><p>例如，假设您认为某种药物可能导致一系列近期心脏病发作。该制药公司认为这种药物是安全的。零假设始终是公认的假设; 在这个例子中，药物在市场上，人们正在使用它，并且通常认为它是安全的。因此，零假设是药物是安全的。另一种假设 - 你想要取代零假设的假设，就是药物<em>不是</em>安全。在这种情况下拒绝零假设意味着您必须证明药物不安全。</p>\n<footer><cite><a href=\"https://www.statisticshowto.datasciencecentral.com/support-or-reject-null-hypothesis/\" target=\"_blank\" rel=\"noopener\">What does it mean to reject the null hypothesis?</a></cite></footer></blockquote>\n<h6 id=\"p值定义\"><a href=\"#p值定义\" class=\"headerlink\" title=\"p值定义\"></a>p值定义</h6><p>在假设检验中使用 p值 来帮助支持或拒绝零假设。p值对于零假设来说是一个证据。<strong>p值越小，拒绝零假设的证据就越强。</strong></p>\n<p>p值表示为小数，但如果将它们转换为百分比，可能更容易理解它们是什么。</p>\n<blockquote>\n<p>例如，p值0.0254是2.54％。这意味着您的结果有可能是2.54％随机的（即偶然发生）。</p>\n<p>另一方面，大的p值为.9（90％）意味着您的结果有90％的概率是完全随机的，而不是由于实验中的任何内容。</p>\n<p>因此，p值越小，结果越重要（“显着”）。</p>\n</blockquote>\n<p>运行假设检验时，将测试中的p值与运行测试时选择的alpha值进行比较。alpha值也可以写为百分比。</p>\n<h6 id=\"p值与alpha级别\"><a href=\"#p值与alpha级别\" class=\"headerlink\" title=\"p值与alpha级别\"></a>p值与alpha级别</h6><p>alpha级别由研究人员控制，并与置信水平相关。通过从100％减去置信度来获得alpha级别。</p>\n<blockquote>\n<p>例如，如果您希望对您的研究有98％的信心，那么α水平将为2％（100％ - 98％）。</p>\n<p>当您运行假设检验时，测试将为您提供p的值。将该值与您选择的alpha级别进行比较。</p>\n<p>例如，假设您选择了5％（0.05）的alpha级别。如果测试结果给你：</p>\n<ul>\n<li>小p（≤0.05）拒绝零假设。这是零假设无效的有力证据。</li>\n<li>大p（&gt; 0.05）表示备用假设很弱，因此您不会拒绝零假设。</li>\n</ul>\n</blockquote>\n<h6 id=\"如果我没有Alpha级别怎么办？\"><a href=\"#如果我没有Alpha级别怎么办？\" class=\"headerlink\" title=\"如果我没有Alpha级别怎么办？\"></a>如果我没有Alpha级别怎么办？</h6><p>在理想的世界中，你将拥有一个alpha级别。但是如果你没有的话，仍然可以使用以下粗略的指导方针来决定是否支持或拒绝原假设：</p>\n<ul>\n<li>如果<code>p&gt;.10</code>→“不重要”</li>\n<li>如果<code>p≤.10</code>→“略显重要”</li>\n<li>如果<code>p≤0.55</code>→“显着”</li>\n<li>如果<code>p≤0.01</code>→“非常重要”。</li>\n</ul>\n<blockquote><h6 id=\"为什么常用的alpha级别为-05？\"><a href=\"#为什么常用的alpha级别为-05？\" class=\"headerlink\" title=\"为什么常用的alpha级别为.05？\"></a>为什么常用的alpha级别为.05？</h6><p>看到alpha级别是产生Type I错误的概率，我们认为这个区域尽可能小是合理的。例如，如果我们将alpha级别设置为10％，那么我们很可能会错误地拒绝原假设，而1％的alpha级别会使该区域变小。那么为什么不使用一个小区域而不是标准的5％呢？</p>\n<p>alpha级别越小，拒绝原假设的区域越小。因此，如果你有一个很小的区域，那么你有可能不会拒绝空位，实际上你应该这样做。这是Type II错误。</p>\n<p>换句话说，你尝试避免类型I错误的次数越多，第二类错误就越容易发生。科学家们发现5％的α水平是这两个问题之间的良好平衡。</p>\n<footer><cite><a href=\"https://www.statisticshowto.datasciencecentral.com/what-is-an-alpha-level/#alphawhy\" target=\"_blank\" rel=\"noopener\">Why is an Alpha Level of .05 commonly used?</a></cite></footer></blockquote>\n<blockquote><ul>\n<li><p>若零假设事实上成立，但统计检验的结果不支持零假设（拒绝零假设），这种错误称为<strong>第一型错误</strong>。</p>\n</li>\n<li><p>若零假设事实上不成立，但统计检验的结果支持零假设（接受零假设），这种错误称为<strong>第二型错误</strong>。</p>\n</li>\n</ul>\n<p>以利用验孕棒验孕为例，此时未怀孕为零假设。</p>\n<p>若用验孕棒为一位未怀孕的女士验孕，结果是已怀孕，这是<strong>第一型错误</strong>。</p>\n<p>若用验孕棒为一位孕妇验孕，结果是未怀孕，这是<strong>第二型错误</strong>。</p>\n<footer><cite><a href=\"https://zh.wikipedia.org/wiki/%E7%AC%AC%E4%B8%80%E5%9E%8B%E5%8F%8A%E7%AC%AC%E4%BA%8C%E5%9E%8B%E9%8C%AF%E8%AA%A4\" target=\"_blank\" rel=\"noopener\">第一型及第二型錯誤</a></cite></footer></blockquote>\n<h5 id=\"正态性检验示例\"><a href=\"#正态性检验示例\" class=\"headerlink\" title=\"正态性检验示例\"></a>正态性检验示例</h5><p><strong><a href=\"http://scipy.github.io/devdocs/generated/scipy.stats.shapiro.html\" target=\"_blank\" rel=\"noopener\"><code>scipy.stats.shapiro</code></a></strong></p>\n<blockquote>\n<p>对于N&gt; 5000，W检验统计量是准确的，但p值可能不是。</p>\n</blockquote>\n<figure class=\"highlight python\"><figcaption><span>shapiro</span><a href=\"https://docs.scipy.org/doc/numpy-1.15.0/reference/generated/numpy.random.normal.html\" target=\"_blank\" rel=\"noopener\">scipy.stats.shapiro</a></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">from</span> scipy.stats <span class=\"keyword\">import</span> shapiro</span><br><span class=\"line\"></span><br><span class=\"line\">np.random.seed(<span class=\"number\">17</span>)</span><br><span class=\"line\">mu, sigma = <span class=\"number\">0</span>, <span class=\"number\">0.1</span></span><br><span class=\"line\">s = np.random.normal(mu, sigma, <span class=\"number\">1000</span>)</span><br><span class=\"line\">count, bins, ignored = plt.hist(s, <span class=\"number\">30</span>, density=<span class=\"keyword\">True</span>)</span><br><span class=\"line\">plt.plot(bins, <span class=\"number\">1</span> / (sigma * np.sqrt(<span class=\"number\">2</span> * np.pi)) *</span><br><span class=\"line\">         np.exp(- (bins - mu) ** <span class=\"number\">2</span> / (<span class=\"number\">2</span> * sigma ** <span class=\"number\">2</span>)),</span><br><span class=\"line\">         linewidth=<span class=\"number\">2</span>, color=<span class=\"string\">'r'</span>)</span><br><span class=\"line\">plt.show()</span><br><span class=\"line\"></span><br><span class=\"line\">print(shapiro(s))</span><br></pre></td></tr></table></figure>\n<p><img src=\"1542007030968.png\" alt=\"1542007030968\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">(0.9982456564903259, 0.401098370552063)</span><br></pre></td></tr></table></figure>\n<p>上述代码得到的 p值 已经远远大于 0.1 了，表示这个结果完全不用采纳。维持原有 零假设 也就是这是一个正态分布的假设。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"特征提取\"><a href=\"#特征提取\" class=\"headerlink\" title=\"特征提取\"></a>特征提取</h3><h4 id=\"文本\"><a href=\"#文本\" class=\"headerlink\" title=\"文本\"></a>文本</h4><p>在处理文本之前，必须tokenzie文本，也就是将文本切分为单元（token）。在最简单的情形下，token不过是单词。<strong>因为直接按照单次来切分可能会损失一些信息，所以现在切分时更多的会考虑语言的特性（也就是语义和语境）。</strong></p>\n<p>接下来需要正则化数据。对文本而言，这涉及词干提取（stemming）和词形还原（lemmatization）；这是用来处理同一单词的不同形式的类似过程。</p>\n<p><a href=\"信息检索导论.pdf\">信息检索导论.pdf</a></p>\n<blockquote><p>词干还原（stemming）和词形归并（lemmatization）这两个术语所代表的意义是不同的。</p>\n<p>前者通常指的是一个很粗略的去除单词两端词缀的启发式过程，并且希望大部分时间它都能达到这个正确目的，这个过程也常常包括去除派生词缀。</p>\n<p>而词形归并通常指利用词汇表和词形分析来去除屈折词缀，从而返回词的原形或词典中的词的过程，返回的结果称为词元（lemma）。</p>\n<p>假如给定词条 saw，词干还原过程可能仅返回 s，而词形归并过程将返回 see 或者 saw，当然具体返回哪个词<strong>取决于在当前上下文</strong>中 saw 到底是动词还是名词。</p>\n<footer><strong>信息检索导论</strong><cite>Christopher D. Manning</cite></footer></blockquote>\n<blockquote><p>一个面向英语的词干提取器，例如，要识别字符串“cats”、“catlike”和“catty”是基于词根“cat”；“stemmer”、“stemming”和“stemmed”是基于词根“stem”。一根词干提取算法可以简化词 “fishing”、“fished”、“fish”和“fisher” 为同一个词根“fish”。</p>\n<footer><cite><a href=\"https://zh.wikipedia.org/wiki/%E8%AF%8D%E5%B9%B2%E6%8F%90%E5%8F%96\" target=\"_blank\" rel=\"noopener\">词干提取</a></cite></footer></blockquote>\n<blockquote><p>在计算语言学中，lemmatisation是基于其预期含义确定单词的<a href=\"https://en.wikipedia.org/wiki/Lemma_(morphology\" target=\"_blank\" rel=\"noopener\">引理</a>)的算法过程。与<a href=\"https://en.wikipedia.org/wiki/Stemming\" target=\"_blank\" rel=\"noopener\">词干化</a>不同，词汇化取决于正确识别句子中的预期<a href=\"https://en.wikipedia.org/wiki/Part_of_speech\" target=\"_blank\" rel=\"noopener\">词性</a>和词语的含义，以及围绕该句子的较大语境，例如邻近句子甚至整个文档。</p>\n<footer><cite><a href=\"https://en.wikipedia.org/wiki/Lemmatisation\" target=\"_blank\" rel=\"noopener\">Lemmatisation</a></cite></footer></blockquote>\n<blockquote><p>此模型下，一段文本（比如一个句子或是一个文档）可以用一个装着这些词的袋子来表示，这种表示方式不考虑文法以及词的顺序。</p>\n<ol>\n<li>John likes to watch movies. Mary likes movies too.</li>\n<li>John also likes to watch football games.</li>\n</ol>\n<p>基于以上两个文件，可以建构出下列清单:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">    &quot;John&quot;,</span><br><span class=\"line\">    &quot;likes00&quot;,</span><br><span class=\"line\">    &quot;to&quot;,</span><br><span class=\"line\">    &quot;watch&quot;,</span><br><span class=\"line\">    &quot;movies&quot;,</span><br><span class=\"line\">    &quot;also&quot;,</span><br><span class=\"line\">    &quot;football&quot;,</span><br><span class=\"line\">    &quot;games&quot;,</span><br><span class=\"line\">    &quot;Mary&quot;,</span><br><span class=\"line\">    &quot;too&quot;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>此处有10个不同的词，使用清单的索引表示长度为10的向量，分别对应上面的两段文本。</p>\n<ol>\n<li><code>[1, 2, 1, 1, 2, 0, 0, 0, 1, 1]</code></li>\n<li><code>[1, 1, 1, 1, 0, 1, 1, 1, 0, 0]</code></li>\n</ol>\n<p>每个向量的索引内容对应到清单中词出现的次数。</p>\n<p>此向量表示法不会保存原始句子中词的顺序。该表示法有许多成功的应用，像是邮件过滤。</p>\n<footer><cite><a href=\"https://zh.wikipedia.org/wiki/%E8%AF%8D%E8%A2%8B%E6%A8%A1%E5%9E%8B\" target=\"_blank\" rel=\"noopener\">词袋模型</a></cite></footer></blockquote>\n<p>当使用类似词袋的算法时，我们丢失了文本中的单词顺序信息，这意味着向量化之后，“i have no cows”（我没有牛）和“no, i have cows”（没，我有牛）会变得一样，尽管事实上它们的意思截然相反。为了避免这个问题，我们可以转用<a href=\"https://zh.wikipedia.org/wiki/N%E5%85%83%E8%AF%AD%E6%B3%95\" target=\"_blank\" rel=\"noopener\">N元语法</a>。</p>\n<figure class=\"highlight python\"><figcaption><span>CountVectorizer示例</span><a href=\"https://scikit-learn.org/stable/modules/generated/sklearn.feature_extraction.text.CountVectorizer.html\" target=\"_blank\" rel=\"noopener\">sklearn.feature_extraction.text.CountVectorizer</a></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> sklearn.feature_extraction.text <span class=\"keyword\">import</span> CountVectorizer</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>corpus = [</span><br><span class=\"line\"><span class=\"meta\">... </span>    <span class=\"string\">'This is the first document.'</span>,</span><br><span class=\"line\"><span class=\"meta\">... </span>    <span class=\"string\">'This document is the second document.'</span>,</span><br><span class=\"line\"><span class=\"meta\">... </span>    <span class=\"string\">'And this is the third one.'</span>,</span><br><span class=\"line\"><span class=\"meta\">... </span>    <span class=\"string\">'Is this the first document?'</span>,</span><br><span class=\"line\"><span class=\"meta\">... </span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>vectorizer = CountVectorizer()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>X = vectorizer.fit_transform(corpus)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(vectorizer.get_feature_names())</span><br><span class=\"line\">[<span class=\"string\">'and'</span>, <span class=\"string\">'document'</span>, <span class=\"string\">'first'</span>, <span class=\"string\">'is'</span>, <span class=\"string\">'one'</span>, <span class=\"string\">'second'</span>, <span class=\"string\">'the'</span>, <span class=\"string\">'third'</span>, <span class=\"string\">'this'</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(vectorizer.vocabulary_)</span><br><span class=\"line\">&#123;<span class=\"string\">'this'</span>: <span class=\"number\">8</span>, <span class=\"string\">'is'</span>: <span class=\"number\">3</span>, <span class=\"string\">'the'</span>: <span class=\"number\">6</span>, <span class=\"string\">'first'</span>: <span class=\"number\">2</span>, <span class=\"string\">'document'</span>: <span class=\"number\">1</span>, <span class=\"string\">'second'</span>: <span class=\"number\">5</span>, <span class=\"string\">'and'</span>: <span class=\"number\">0</span>, <span class=\"string\">'third'</span>: <span class=\"number\">7</span>, <span class=\"string\">'one'</span>: <span class=\"number\">4</span>&#125;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(X.toarray())  </span><br><span class=\"line\">[[<span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">1</span> <span class=\"number\">1</span> <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">0</span> <span class=\"number\">1</span>]</span><br><span class=\"line\"> [<span class=\"number\">0</span> <span class=\"number\">2</span> <span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">1</span> <span class=\"number\">0</span> <span class=\"number\">1</span>]</span><br><span class=\"line\"> [<span class=\"number\">1</span> <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">1</span> <span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">1</span> <span class=\"number\">1</span>]</span><br><span class=\"line\"> [<span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">1</span> <span class=\"number\">1</span> <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">0</span> <span class=\"number\">1</span>]]</span><br></pre></td></tr></table></figure>\n<h4 id=\"图像\"><a href=\"#图像\" class=\"headerlink\" title=\"图像\"></a>图像</h4><blockquote><p>卷积神经网络由一个或多个卷积层和顶端的全连通层（对应经典的神经网络）组成，同时也包括关联权重和<a href=\"https://zh.wikipedia.org/w/index.php?title=%E6%B1%A0%E5%8C%96&amp;action=edit&amp;redlink=1\" target=\"_blank\" rel=\"noopener\">池化</a>层（pooling layer）。这一结构使得卷积神经网络能够利用输入数据的二维结构。与其他深度学习结构相比，卷积神经网络在图像和<a href=\"https://zh.wikipedia.org/wiki/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB\" target=\"_blank\" rel=\"noopener\">语音识别</a>方面能够给出更好的结果。</p>\n<p><strong>卷积层</strong></p>\n<p>卷积层（Convolutional layer），卷积神经网上中每层卷积层由若干卷积单元组成，每个卷积单元的参数都是通过<a href=\"https://zh.wikipedia.org/wiki/%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95\" target=\"_blank\" rel=\"noopener\">反向传播算法</a>最优化得到的。卷积运算的目的是提取输入的不同特征，第一层卷积层可能只能提取一些低级的特征如边缘、线条和角等层级，更多层的网路能从低级特征中迭代提取更复杂的特征。</p>\n<p><strong>池化层(Pooling Layer)</strong></p>\n<p><img src=\"314px-Max_pooling.png\" alt=\"img\"></p>\n<p>每隔2个元素进行的2x2最大池化</p>\n<p>池化（Pooling）是卷积神经网络中另一个重要的概念，它实际上是一种形式的降采样。有多种不同形式的非线性池化函数，而其中<strong>“最大池化（Max pooling）”</strong>是最为常见的。它是将输入的图像划分为若干个矩形区域，对每个子区域输出最大值。</p>\n<p>直觉上，这种机制能够有效地原因在于，在发现一个特征之后，它的精确位置远不及它和其他特征的相对位置的关系重要。池化层会不断地减小数据的空间大小，因此参数的数量和计算量也会下降，这在一定程度上也控制了<a href=\"https://zh.wikipedia.org/wiki/%E8%BF%87%E6%8B%9F%E5%90%88\" target=\"_blank\" rel=\"noopener\">过拟合</a>。通常来说，CNN的卷积层之间都会周期性地插入池化层。</p>\n<p>池化层通常会分别作用于每个输入的特征并减小其大小。目前最常用形式的池化层是每隔2个元素从图像划分出$2\\times2$的区块，然后对每个区块中的4个数取最大值。这将会减少75%的数据量。</p>\n<p>除了最大池化之外，池化层也可以使用其他池化函数，例如“平均池化”甚至“<a href=\"https://zh.wikipedia.org/wiki/Lp%E7%A9%BA%E9%97%B4#.E9.95.BF.E5.BA.A6.E3.80.81.E8.B7.9D.E7.A6.BB.E4.B8.8E.E8.8C.83.E6.95.B0\" target=\"_blank\" rel=\"noopener\">L2-范数</a>池化”等。过去，平均池化的使用曾经较为广泛，但是最近由于最大池化在实践中的表现更好，平均池化已经不太常用。</p>\n<p><em>由于池化层过快地减少了数据的大小，目前文献中的趋势是使用较小的池化滤镜，甚至不再使用池化层。</em></p>\n<footer><cite><a href=\"https://zh.wikipedia.org/wiki/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C\" target=\"_blank\" rel=\"noopener\">卷积神经网络</a></cite></footer></blockquote>\n<p><a href=\"https://github.com/madmaze/pytesseract\" target=\"_blank\" rel=\"noopener\">pytesseract</a>是python的光学字符识别（OCR）工具。也就是说，它将识别并“读取”嵌入图像中的文本。</p>\n<h4 id=\"地理空间数据\"><a href=\"#地理空间数据\" class=\"headerlink\" title=\"地理空间数据\"></a>地理空间数据</h4><p>可以通过访问外部API（谷歌地图或OpenStreetMap）进行 <em>地理编码（由地址重建坐标点）</em>和<em>逆地理编码（由坐标点重建地址）</em>的互逆操作。很幸运，<a href=\"https://github.com/geopy/geopy\" target=\"_blank\" rel=\"noopener\">geopy</a>之类的通用库封装了这些外部服务。</p>\n<blockquote>\n<p> 处理地理编码时，别忘了地址可能包含错误，因此需要清洗数据。坐标的错误更少，但由于GPS噪声或特定地点（比如隧道、商业区）的低精确度，可能导致位置不正确。如果数据源是移动设备，地理位置可能并不是由GPS决定的，而是由该区域的WiFi网络决定的，这会导致空间中的空洞和远距离传送。</p>\n<p>地点常常位于许多基础设施之间。因此，你可以充分发挥想象力，基于生活经验和领域知识发明特征：地点到地铁口的接近程度，建筑物中的商户数，到最近的商店的距离，周边的ATM数目，等等。就任何任务而言，你很容易想到几十个特征并从不同的外部资源中提取它们。就城市以外的问题而言，你可以考虑来自更专门的数据源的特征，比如海拔。</p>\n<p>如果两个以上的地名相互连接，可能有必要基于地点之间的路由提取特征。比如，距离（直线距离和基于路由图计算得出的道路距离），转弯数（包括左转和右转的比例），红路灯数，交叉路口数，桥梁数。在我自己遇到的一个任务中，我生成了一个称为“道路复杂度”的特征，该特征计算基于图得出的距离除以最大公因数。</p>\n</blockquote>\n<h4 id=\"日期和时间\"><a href=\"#日期和时间\" class=\"headerlink\" title=\"日期和时间\"></a>日期和时间</h4><blockquote>\n<p>一般而言，处理时序数据时，最好有一份包含公众节假日、异常天气情况及其他重要事件的日历。</p>\n</blockquote>\n<h4 id=\"时序，web，等等\"><a href=\"#时序，web，等等\" class=\"headerlink\" title=\"时序，web，等等\"></a>时序，web，等等</h4><p>对于时序的处理可以参考：<a href=\"https://github.com/blue-yonder/tsfresh\" target=\"_blank\" rel=\"noopener\">tsfresh</a> <em>基于可扩展假设检验的时间序列特征提取</em></p>\n<p>对于 <code>user-agents</code> 的处理可以参考：<a href=\"https://github.com/selwin/python-user-agents\" target=\"_blank\" rel=\"noopener\">python-user-agents</a></p>\n<p>下一个有用的特征是IP地址，基于该数据可以提取国家，乃至城市、网络运营商、连接类型（是否为移动网络）。<strong>但是代理和数据库过期导致该特征可能包含噪声。</strong></p>\n<blockquote>\n<p>IP地址数据和<code>Accept-Language</code>是一对良好的组合：如果用户的IP地址显示在智利，而浏览器的本地化设为<code>ru_RU</code>（俄罗斯），该用户的所在地并不清晰，需要查看对应的特征栏<code>is_traveler_or_proxy_user</code>（是旅行者还是代理用户）。</p>\n</blockquote>\n<h3 id=\"特征转换\"><a href=\"#特征转换\" class=\"headerlink\" title=\"特征转换\"></a>特征转换</h3><h4 id=\"正则化和改变分布\"><a href=\"#正则化和改变分布\" class=\"headerlink\" title=\"正则化和改变分布\"></a>正则化和改变分布</h4><h5 id=\"对数据做正态性检验\"><a href=\"#对数据做正态性检验\" class=\"headerlink\" title=\"对数据做正态性检验\"></a>对数据做正态性检验</h5><p><strong><a href=\"https://zh.wikipedia.org/wiki/%E9%9B%B6%E5%81%87%E8%AE%BE\" target=\"_blank\" rel=\"noopener\">零假设</a>（$H_{0}$）</strong>是普遍接受的事实。比如说抛硬币正反面出现的可能性均为50%。</p>\n<blockquote>\n<p>零假设可以被认为是<em>可归因的</em>假设。这意味着您可以使其无效或拒绝它。</p>\n</blockquote>\n<p><strong>替代假设（对立假设、<a href=\"https://zh.wikipedia.org/w/index.php?title=%E5%A4%87%E6%8B%A9%E5%81%87%E8%AE%BE&amp;action=edit&amp;redlink=1\" target=\"_blank\" rel=\"noopener\">备择假设</a>）</strong>。是零假设的替代。比如说你提出抛硬币正反面出现的可能性分别是30%和70%。那么你提出的这个观点就是替代假设。</p>\n<p><strong>拒绝零假设</strong>：证明零假设是错误的，这时使用<strong>替代假设</strong>所替代。</p>\n<blockquote><p>例如，假设您认为某种药物可能导致一系列近期心脏病发作。该制药公司认为这种药物是安全的。零假设始终是公认的假设; 在这个例子中，药物在市场上，人们正在使用它，并且通常认为它是安全的。因此，零假设是药物是安全的。另一种假设 - 你想要取代零假设的假设，就是药物<em>不是</em>安全。在这种情况下拒绝零假设意味着您必须证明药物不安全。</p>\n<footer><cite><a href=\"https://www.statisticshowto.datasciencecentral.com/support-or-reject-null-hypothesis/\" target=\"_blank\" rel=\"noopener\">What does it mean to reject the null hypothesis?</a></cite></footer></blockquote>\n<h6 id=\"p值定义\"><a href=\"#p值定义\" class=\"headerlink\" title=\"p值定义\"></a>p值定义</h6><p>在假设检验中使用 p值 来帮助支持或拒绝零假设。p值对于零假设来说是一个证据。<strong>p值越小，拒绝零假设的证据就越强。</strong></p>\n<p>p值表示为小数，但如果将它们转换为百分比，可能更容易理解它们是什么。</p>\n<blockquote>\n<p>例如，p值0.0254是2.54％。这意味着您的结果有可能是2.54％随机的（即偶然发生）。</p>\n<p>另一方面，大的p值为.9（90％）意味着您的结果有90％的概率是完全随机的，而不是由于实验中的任何内容。</p>\n<p>因此，p值越小，结果越重要（“显着”）。</p>\n</blockquote>\n<p>运行假设检验时，将测试中的p值与运行测试时选择的alpha值进行比较。alpha值也可以写为百分比。</p>\n<h6 id=\"p值与alpha级别\"><a href=\"#p值与alpha级别\" class=\"headerlink\" title=\"p值与alpha级别\"></a>p值与alpha级别</h6><p>alpha级别由研究人员控制，并与置信水平相关。通过从100％减去置信度来获得alpha级别。</p>\n<blockquote>\n<p>例如，如果您希望对您的研究有98％的信心，那么α水平将为2％（100％ - 98％）。</p>\n<p>当您运行假设检验时，测试将为您提供p的值。将该值与您选择的alpha级别进行比较。</p>\n<p>例如，假设您选择了5％（0.05）的alpha级别。如果测试结果给你：</p>\n<ul>\n<li>小p（≤0.05）拒绝零假设。这是零假设无效的有力证据。</li>\n<li>大p（&gt; 0.05）表示备用假设很弱，因此您不会拒绝零假设。</li>\n</ul>\n</blockquote>\n<h6 id=\"如果我没有Alpha级别怎么办？\"><a href=\"#如果我没有Alpha级别怎么办？\" class=\"headerlink\" title=\"如果我没有Alpha级别怎么办？\"></a>如果我没有Alpha级别怎么办？</h6><p>在理想的世界中，你将拥有一个alpha级别。但是如果你没有的话，仍然可以使用以下粗略的指导方针来决定是否支持或拒绝原假设：</p>\n<ul>\n<li>如果<code>p&gt;.10</code>→“不重要”</li>\n<li>如果<code>p≤.10</code>→“略显重要”</li>\n<li>如果<code>p≤0.55</code>→“显着”</li>\n<li>如果<code>p≤0.01</code>→“非常重要”。</li>\n</ul>\n<blockquote><h6 id=\"为什么常用的alpha级别为-05？\"><a href=\"#为什么常用的alpha级别为-05？\" class=\"headerlink\" title=\"为什么常用的alpha级别为.05？\"></a>为什么常用的alpha级别为.05？</h6><p>看到alpha级别是产生Type I错误的概率，我们认为这个区域尽可能小是合理的。例如，如果我们将alpha级别设置为10％，那么我们很可能会错误地拒绝原假设，而1％的alpha级别会使该区域变小。那么为什么不使用一个小区域而不是标准的5％呢？</p>\n<p>alpha级别越小，拒绝原假设的区域越小。因此，如果你有一个很小的区域，那么你有可能不会拒绝空位，实际上你应该这样做。这是Type II错误。</p>\n<p>换句话说，你尝试避免类型I错误的次数越多，第二类错误就越容易发生。科学家们发现5％的α水平是这两个问题之间的良好平衡。</p>\n<footer><cite><a href=\"https://www.statisticshowto.datasciencecentral.com/what-is-an-alpha-level/#alphawhy\" target=\"_blank\" rel=\"noopener\">Why is an Alpha Level of .05 commonly used?</a></cite></footer></blockquote>\n<blockquote><ul>\n<li><p>若零假设事实上成立，但统计检验的结果不支持零假设（拒绝零假设），这种错误称为<strong>第一型错误</strong>。</p>\n</li>\n<li><p>若零假设事实上不成立，但统计检验的结果支持零假设（接受零假设），这种错误称为<strong>第二型错误</strong>。</p>\n</li>\n</ul>\n<p>以利用验孕棒验孕为例，此时未怀孕为零假设。</p>\n<p>若用验孕棒为一位未怀孕的女士验孕，结果是已怀孕，这是<strong>第一型错误</strong>。</p>\n<p>若用验孕棒为一位孕妇验孕，结果是未怀孕，这是<strong>第二型错误</strong>。</p>\n<footer><cite><a href=\"https://zh.wikipedia.org/wiki/%E7%AC%AC%E4%B8%80%E5%9E%8B%E5%8F%8A%E7%AC%AC%E4%BA%8C%E5%9E%8B%E9%8C%AF%E8%AA%A4\" target=\"_blank\" rel=\"noopener\">第一型及第二型錯誤</a></cite></footer></blockquote>\n<h5 id=\"正态性检验示例\"><a href=\"#正态性检验示例\" class=\"headerlink\" title=\"正态性检验示例\"></a>正态性检验示例</h5><p><strong><a href=\"http://scipy.github.io/devdocs/generated/scipy.stats.shapiro.html\" target=\"_blank\" rel=\"noopener\"><code>scipy.stats.shapiro</code></a></strong></p>\n<blockquote>\n<p>对于N&gt; 5000，W检验统计量是准确的，但p值可能不是。</p>\n</blockquote>\n<figure class=\"highlight python\"><figcaption><span>shapiro</span><a href=\"https://docs.scipy.org/doc/numpy-1.15.0/reference/generated/numpy.random.normal.html\" target=\"_blank\" rel=\"noopener\">scipy.stats.shapiro</a></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">from</span> scipy.stats <span class=\"keyword\">import</span> shapiro</span><br><span class=\"line\"></span><br><span class=\"line\">np.random.seed(<span class=\"number\">17</span>)</span><br><span class=\"line\">mu, sigma = <span class=\"number\">0</span>, <span class=\"number\">0.1</span></span><br><span class=\"line\">s = np.random.normal(mu, sigma, <span class=\"number\">1000</span>)</span><br><span class=\"line\">count, bins, ignored = plt.hist(s, <span class=\"number\">30</span>, density=<span class=\"keyword\">True</span>)</span><br><span class=\"line\">plt.plot(bins, <span class=\"number\">1</span> / (sigma * np.sqrt(<span class=\"number\">2</span> * np.pi)) *</span><br><span class=\"line\">         np.exp(- (bins - mu) ** <span class=\"number\">2</span> / (<span class=\"number\">2</span> * sigma ** <span class=\"number\">2</span>)),</span><br><span class=\"line\">         linewidth=<span class=\"number\">2</span>, color=<span class=\"string\">'r'</span>)</span><br><span class=\"line\">plt.show()</span><br><span class=\"line\"></span><br><span class=\"line\">print(shapiro(s))</span><br></pre></td></tr></table></figure>\n<p><img src=\"1542007030968.png\" alt=\"1542007030968\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">(0.9982456564903259, 0.401098370552063)</span><br></pre></td></tr></table></figure>\n<p>上述代码得到的 p值 已经远远大于 0.1 了，表示这个结果完全不用采纳。维持原有 零假设 也就是这是一个正态分布的假设。</p>\n"},{"title":"机器学习开放课程：四、线性分类与线性回归","date":"2018-10-29T00:38:25.000Z","updated":"2018-10-25T16:00:00.000Z","typora-root-url":"机器学习开放课程：四、线性分类与线性回归","mathjax":true,"description":"<!—more—->","_content":"\n##### [稀疏/稠密矩阵](https://zh.wikipedia.org/wiki/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5)\n\n{% blockquote 稀疏矩阵 https://zh.wikipedia.org/wiki/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5 %}\n\n在数值分析中，**稀疏**矩阵（Sparse matrix），是其元素大部分为零的矩阵。反之，如果大部分元素都非零，则这个矩阵是**稠密**的。在科学与工程领域中求解线性模型时经常出现大型的稀疏矩阵。\n\n在使用计算机存储和操作稀疏矩阵时，经常需要修改标准算法以利用矩阵的稀疏结构。由于其自身的稀疏特性，通过压缩可以大大节省稀疏矩阵的内存代价。更为重要的是，由于过大的尺寸，标准的算法经常无法操作这些稀疏矩阵。\n\n{% endblockquote %}\n\n###### [scipy.sparse.csr_matrix](https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.html)\n\n```python\n>>> indptr = np.array([0, 2, 3, 6])\n>>> indices = np.array([0, 2, 2, 0, 1, 2])\n>>> data = np.array([1, 2, 3, 4, 5, 6])\n>>> csr_matrix((data, indices, indptr), shape=(3, 3)).toarray()\narray([[1, 0, 2],\n       [0, 0, 3],\n       [4, 5, 6]])\n```\n\n网上找了好久终于理解了是如何计算的...\n\n![](TIM20181031095548.png)\n\n```python\n>>> row = np.array([0, 0, 1, 2, 2, 2])\n>>> col = np.array([0, 2, 2, 0, 1, 2])\n>>> data = np.array([1, 2, 3, 4, 5, 6])\n>>> csr_matrix((data, (row, col)), shape=(3, 3)).toarray()\narray([[1, 0, 2],\n       [0, 0, 3],\n       [4, 5, 6]])\n```\n\n这个方法更好理解一些。直接根据对应的行列带入就好了。\n\n>  比如说 `data[2]=3`对应 `col[2]=2,row[2]=1` 说明了它的位置应该在第1行的第2列（数组从0开始）。\n\n![](TIM20181031100050.png)\n\n\n\n矩阵的稀疏性可以用一个得分来量化，也就是矩阵中零值的个数除以矩阵中元素的总个数。\n\n$$ 稀疏性 = \\frac{0元素总数}{元素总数}$$\n\n```python\nfrom scipy.sparse import csr_matrix\nfrom numpy import count_nonzero\n\n# 创建一维数据，包含9个数据\ndata = [1] * 9\nindices = [1, 0, 0, 1, 3, 1, 2, 3, 4]\nindptr = [0, 3, 6, 9]\n# 压缩稀疏行矩阵\n# indices[1]和indices[2]均指向第0行的第0列，所以矩阵中结果为2。第1行第1列也是一样\n# [[2 1 0 0 0]\n#  [0 2 0 1 0]\n#  [0 0 1 1 1]]\nsmall_example = csr_matrix((data, indices, indptr)).toarray()\n# 将矩阵转换为一维\n# [2 1 0 0 0 0 2 0 1 0 0 0 1 1 1]\nsmall_example_flatten = small_example.flatten()\n# 元素总数\n# 15\ntotal = small_example_flatten.shape[0]\n# 0元素数量\n# 7\nnone_count = count_nonzero(small_example_flatten)\n# 矩阵的稀疏性\n# 0.5333333333333333\nsparsity = 1.0 - none_count / total\n\n```\n\n使用 `numpy` 在 **稀疏矩阵** 和 **稠密矩阵** 间转换。\n\n```python\nfrom scipy.sparse import csr_matrix\n\narr = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n# 创建稠密矩阵\n# (0, 0)\t1\n# (1, 1)\t1\n# (2, 2)\t1\nmatrix = csr_matrix(arr)\n# 返回此矩阵的密集ndarray表示\n# [[1 0 0]\n# [0 1 0]\n# [0 0 1]]\nmatrix.toarray()\n\n```\n\n###### \n\n\n\n# 待处理\n\n- [] 逻辑回归\n- [] StandardScalers数据预处理\n- [] Matrix的Sum\n- [] np.logspace\n- [] tqdm\n- [] np.argmax\n- [] LogisticRegression\n- [] plt.axhline\n- [] hstack\n- [] 学习如何使用稀疏矩阵，训练逻辑回归模型，创建新特征并选择最佳特征","source":"_posts/机器学习开放课程：四、线性分类与线性回归.md","raw":"---\ntitle: 机器学习开放课程：四、线性分类与线性回归\ndate: 2018-10-29 08:38:25\nupdated: 2018-10-26\ntags:\n - 编程\n - Python\n - 机器学习\n - 稀疏矩阵\ncategories:\n - 编程\n - Python\n - 机器学习\ntypora-root-url: 机器学习开放课程：四、线性分类与线性回归\nmathjax: true\ndescription: <!—more—->\n---\n\n##### [稀疏/稠密矩阵](https://zh.wikipedia.org/wiki/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5)\n\n{% blockquote 稀疏矩阵 https://zh.wikipedia.org/wiki/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5 %}\n\n在数值分析中，**稀疏**矩阵（Sparse matrix），是其元素大部分为零的矩阵。反之，如果大部分元素都非零，则这个矩阵是**稠密**的。在科学与工程领域中求解线性模型时经常出现大型的稀疏矩阵。\n\n在使用计算机存储和操作稀疏矩阵时，经常需要修改标准算法以利用矩阵的稀疏结构。由于其自身的稀疏特性，通过压缩可以大大节省稀疏矩阵的内存代价。更为重要的是，由于过大的尺寸，标准的算法经常无法操作这些稀疏矩阵。\n\n{% endblockquote %}\n\n###### [scipy.sparse.csr_matrix](https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.html)\n\n```python\n>>> indptr = np.array([0, 2, 3, 6])\n>>> indices = np.array([0, 2, 2, 0, 1, 2])\n>>> data = np.array([1, 2, 3, 4, 5, 6])\n>>> csr_matrix((data, indices, indptr), shape=(3, 3)).toarray()\narray([[1, 0, 2],\n       [0, 0, 3],\n       [4, 5, 6]])\n```\n\n网上找了好久终于理解了是如何计算的...\n\n![](TIM20181031095548.png)\n\n```python\n>>> row = np.array([0, 0, 1, 2, 2, 2])\n>>> col = np.array([0, 2, 2, 0, 1, 2])\n>>> data = np.array([1, 2, 3, 4, 5, 6])\n>>> csr_matrix((data, (row, col)), shape=(3, 3)).toarray()\narray([[1, 0, 2],\n       [0, 0, 3],\n       [4, 5, 6]])\n```\n\n这个方法更好理解一些。直接根据对应的行列带入就好了。\n\n>  比如说 `data[2]=3`对应 `col[2]=2,row[2]=1` 说明了它的位置应该在第1行的第2列（数组从0开始）。\n\n![](TIM20181031100050.png)\n\n\n\n矩阵的稀疏性可以用一个得分来量化，也就是矩阵中零值的个数除以矩阵中元素的总个数。\n\n$$ 稀疏性 = \\frac{0元素总数}{元素总数}$$\n\n```python\nfrom scipy.sparse import csr_matrix\nfrom numpy import count_nonzero\n\n# 创建一维数据，包含9个数据\ndata = [1] * 9\nindices = [1, 0, 0, 1, 3, 1, 2, 3, 4]\nindptr = [0, 3, 6, 9]\n# 压缩稀疏行矩阵\n# indices[1]和indices[2]均指向第0行的第0列，所以矩阵中结果为2。第1行第1列也是一样\n# [[2 1 0 0 0]\n#  [0 2 0 1 0]\n#  [0 0 1 1 1]]\nsmall_example = csr_matrix((data, indices, indptr)).toarray()\n# 将矩阵转换为一维\n# [2 1 0 0 0 0 2 0 1 0 0 0 1 1 1]\nsmall_example_flatten = small_example.flatten()\n# 元素总数\n# 15\ntotal = small_example_flatten.shape[0]\n# 0元素数量\n# 7\nnone_count = count_nonzero(small_example_flatten)\n# 矩阵的稀疏性\n# 0.5333333333333333\nsparsity = 1.0 - none_count / total\n\n```\n\n使用 `numpy` 在 **稀疏矩阵** 和 **稠密矩阵** 间转换。\n\n```python\nfrom scipy.sparse import csr_matrix\n\narr = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n# 创建稠密矩阵\n# (0, 0)\t1\n# (1, 1)\t1\n# (2, 2)\t1\nmatrix = csr_matrix(arr)\n# 返回此矩阵的密集ndarray表示\n# [[1 0 0]\n# [0 1 0]\n# [0 0 1]]\nmatrix.toarray()\n\n```\n\n###### \n\n\n\n# 待处理\n\n- [] 逻辑回归\n- [] StandardScalers数据预处理\n- [] Matrix的Sum\n- [] np.logspace\n- [] tqdm\n- [] np.argmax\n- [] LogisticRegression\n- [] plt.axhline\n- [] hstack\n- [] 学习如何使用稀疏矩阵，训练逻辑回归模型，创建新特征并选择最佳特征","slug":"机器学习开放课程：四、线性分类与线性回归","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cjof51pkr000krguedgqkh3gs","content":"<h5 id=\"稀疏-稠密矩阵\"><a href=\"#稀疏-稠密矩阵\" class=\"headerlink\" title=\"稀疏/稠密矩阵\"></a><a href=\"https://zh.wikipedia.org/wiki/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5\" target=\"_blank\" rel=\"noopener\">稀疏/稠密矩阵</a></h5><blockquote><p>在数值分析中，<strong>稀疏</strong>矩阵（Sparse matrix），是其元素大部分为零的矩阵。反之，如果大部分元素都非零，则这个矩阵是<strong>稠密</strong>的。在科学与工程领域中求解线性模型时经常出现大型的稀疏矩阵。</p>\n<p>在使用计算机存储和操作稀疏矩阵时，经常需要修改标准算法以利用矩阵的稀疏结构。由于其自身的稀疏特性，通过压缩可以大大节省稀疏矩阵的内存代价。更为重要的是，由于过大的尺寸，标准的算法经常无法操作这些稀疏矩阵。</p>\n<footer><strong>稀疏矩阵</strong><cite><a href=\"https://zh.wikipedia.org/wiki/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5\" target=\"_blank\" rel=\"noopener\">zh.wikipedia.org/wiki/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5</a></cite></footer></blockquote>\n<h6 id=\"scipy-sparse-csr-matrix\"><a href=\"#scipy-sparse-csr-matrix\" class=\"headerlink\" title=\"scipy.sparse.csr_matrix\"></a><a href=\"https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.html\" target=\"_blank\" rel=\"noopener\">scipy.sparse.csr_matrix</a></h6><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>indptr = np.array([<span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">6</span>])</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>indices = np.array([<span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>])</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>data = np.array([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>])</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>csr_matrix((data, indices, indptr), shape=(<span class=\"number\">3</span>, <span class=\"number\">3</span>)).toarray()</span><br><span class=\"line\">array([[<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>],</span><br><span class=\"line\">       [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">3</span>],</span><br><span class=\"line\">       [<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>]])</span><br></pre></td></tr></table></figure>\n<p>网上找了好久终于理解了是如何计算的…</p>\n<p><img src=\"TIM20181031095548.png\" alt=\"\"></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>row = np.array([<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>])</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>col = np.array([<span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>])</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>data = np.array([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>])</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>csr_matrix((data, (row, col)), shape=(<span class=\"number\">3</span>, <span class=\"number\">3</span>)).toarray()</span><br><span class=\"line\">array([[<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>],</span><br><span class=\"line\">       [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">3</span>],</span><br><span class=\"line\">       [<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>]])</span><br></pre></td></tr></table></figure>\n<p>这个方法更好理解一些。直接根据对应的行列带入就好了。</p>\n<blockquote>\n<p> 比如说 <code>data[2]=3</code>对应 <code>col[2]=2,row[2]=1</code> 说明了它的位置应该在第1行的第2列（数组从0开始）。</p>\n</blockquote>\n<p><img src=\"TIM20181031100050.png\" alt=\"\"></p>\n<p>矩阵的稀疏性可以用一个得分来量化，也就是矩阵中零值的个数除以矩阵中元素的总个数。</p>\n<p>$$ 稀疏性 = \\frac{0元素总数}{元素总数}$$</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> scipy.sparse <span class=\"keyword\">import</span> csr_matrix</span><br><span class=\"line\"><span class=\"keyword\">from</span> numpy <span class=\"keyword\">import</span> count_nonzero</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建一维数据，包含9个数据</span></span><br><span class=\"line\">data = [<span class=\"number\">1</span>] * <span class=\"number\">9</span></span><br><span class=\"line\">indices = [<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\">indptr = [<span class=\"number\">0</span>, <span class=\"number\">3</span>, <span class=\"number\">6</span>, <span class=\"number\">9</span>]</span><br><span class=\"line\"><span class=\"comment\"># 压缩稀疏行矩阵</span></span><br><span class=\"line\"><span class=\"comment\"># indices[1]和indices[2]均指向第0行的第0列，所以矩阵中结果为2。第1行第1列也是一样</span></span><br><span class=\"line\"><span class=\"comment\"># [[2 1 0 0 0]</span></span><br><span class=\"line\"><span class=\"comment\">#  [0 2 0 1 0]</span></span><br><span class=\"line\"><span class=\"comment\">#  [0 0 1 1 1]]</span></span><br><span class=\"line\">small_example = csr_matrix((data, indices, indptr)).toarray()</span><br><span class=\"line\"><span class=\"comment\"># 将矩阵转换为一维</span></span><br><span class=\"line\"><span class=\"comment\"># [2 1 0 0 0 0 2 0 1 0 0 0 1 1 1]</span></span><br><span class=\"line\">small_example_flatten = small_example.flatten()</span><br><span class=\"line\"><span class=\"comment\"># 元素总数</span></span><br><span class=\"line\"><span class=\"comment\"># 15</span></span><br><span class=\"line\">total = small_example_flatten.shape[<span class=\"number\">0</span>]</span><br><span class=\"line\"><span class=\"comment\"># 0元素数量</span></span><br><span class=\"line\"><span class=\"comment\"># 7</span></span><br><span class=\"line\">none_count = count_nonzero(small_example_flatten)</span><br><span class=\"line\"><span class=\"comment\"># 矩阵的稀疏性</span></span><br><span class=\"line\"><span class=\"comment\"># 0.5333333333333333</span></span><br><span class=\"line\">sparsity = <span class=\"number\">1.0</span> - none_count / total</span><br></pre></td></tr></table></figure>\n<p>使用 <code>numpy</code> 在 <strong>稀疏矩阵</strong> 和 <strong>稠密矩阵</strong> 间转换。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> scipy.sparse <span class=\"keyword\">import</span> csr_matrix</span><br><span class=\"line\"></span><br><span class=\"line\">arr = [[<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>], [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>], [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>]]</span><br><span class=\"line\"><span class=\"comment\"># 创建稠密矩阵</span></span><br><span class=\"line\"><span class=\"comment\"># (0, 0)\t1</span></span><br><span class=\"line\"><span class=\"comment\"># (1, 1)\t1</span></span><br><span class=\"line\"><span class=\"comment\"># (2, 2)\t1</span></span><br><span class=\"line\">matrix = csr_matrix(arr)</span><br><span class=\"line\"><span class=\"comment\"># 返回此矩阵的密集ndarray表示</span></span><br><span class=\"line\"><span class=\"comment\"># [[1 0 0]</span></span><br><span class=\"line\"><span class=\"comment\"># [0 1 0]</span></span><br><span class=\"line\"><span class=\"comment\"># [0 0 1]]</span></span><br><span class=\"line\">matrix.toarray()</span><br></pre></td></tr></table></figure>\n<p>###### </p>\n<h1 id=\"待处理\"><a href=\"#待处理\" class=\"headerlink\" title=\"待处理\"></a>待处理</h1><ul>\n<li>[] 逻辑回归</li>\n<li>[] StandardScalers数据预处理</li>\n<li>[] Matrix的Sum</li>\n<li>[] np.logspace</li>\n<li>[] tqdm</li>\n<li>[] np.argmax</li>\n<li>[] LogisticRegression</li>\n<li>[] plt.axhline</li>\n<li>[] hstack</li>\n<li>[] 学习如何使用稀疏矩阵，训练逻辑回归模型，创建新特征并选择最佳特征</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h5 id=\"稀疏-稠密矩阵\"><a href=\"#稀疏-稠密矩阵\" class=\"headerlink\" title=\"稀疏/稠密矩阵\"></a><a href=\"https://zh.wikipedia.org/wiki/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5\" target=\"_blank\" rel=\"noopener\">稀疏/稠密矩阵</a></h5><blockquote><p>在数值分析中，<strong>稀疏</strong>矩阵（Sparse matrix），是其元素大部分为零的矩阵。反之，如果大部分元素都非零，则这个矩阵是<strong>稠密</strong>的。在科学与工程领域中求解线性模型时经常出现大型的稀疏矩阵。</p>\n<p>在使用计算机存储和操作稀疏矩阵时，经常需要修改标准算法以利用矩阵的稀疏结构。由于其自身的稀疏特性，通过压缩可以大大节省稀疏矩阵的内存代价。更为重要的是，由于过大的尺寸，标准的算法经常无法操作这些稀疏矩阵。</p>\n<footer><strong>稀疏矩阵</strong><cite><a href=\"https://zh.wikipedia.org/wiki/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5\" target=\"_blank\" rel=\"noopener\">zh.wikipedia.org/wiki/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5</a></cite></footer></blockquote>\n<h6 id=\"scipy-sparse-csr-matrix\"><a href=\"#scipy-sparse-csr-matrix\" class=\"headerlink\" title=\"scipy.sparse.csr_matrix\"></a><a href=\"https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.html\" target=\"_blank\" rel=\"noopener\">scipy.sparse.csr_matrix</a></h6><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>indptr = np.array([<span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">6</span>])</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>indices = np.array([<span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>])</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>data = np.array([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>])</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>csr_matrix((data, indices, indptr), shape=(<span class=\"number\">3</span>, <span class=\"number\">3</span>)).toarray()</span><br><span class=\"line\">array([[<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>],</span><br><span class=\"line\">       [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">3</span>],</span><br><span class=\"line\">       [<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>]])</span><br></pre></td></tr></table></figure>\n<p>网上找了好久终于理解了是如何计算的…</p>\n<p><img src=\"TIM20181031095548.png\" alt=\"\"></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>row = np.array([<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>])</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>col = np.array([<span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>])</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>data = np.array([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>])</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>csr_matrix((data, (row, col)), shape=(<span class=\"number\">3</span>, <span class=\"number\">3</span>)).toarray()</span><br><span class=\"line\">array([[<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>],</span><br><span class=\"line\">       [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">3</span>],</span><br><span class=\"line\">       [<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>]])</span><br></pre></td></tr></table></figure>\n<p>这个方法更好理解一些。直接根据对应的行列带入就好了。</p>\n<blockquote>\n<p> 比如说 <code>data[2]=3</code>对应 <code>col[2]=2,row[2]=1</code> 说明了它的位置应该在第1行的第2列（数组从0开始）。</p>\n</blockquote>\n<p><img src=\"TIM20181031100050.png\" alt=\"\"></p>\n<p>矩阵的稀疏性可以用一个得分来量化，也就是矩阵中零值的个数除以矩阵中元素的总个数。</p>\n<p>$$ 稀疏性 = \\frac{0元素总数}{元素总数}$$</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> scipy.sparse <span class=\"keyword\">import</span> csr_matrix</span><br><span class=\"line\"><span class=\"keyword\">from</span> numpy <span class=\"keyword\">import</span> count_nonzero</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建一维数据，包含9个数据</span></span><br><span class=\"line\">data = [<span class=\"number\">1</span>] * <span class=\"number\">9</span></span><br><span class=\"line\">indices = [<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\">indptr = [<span class=\"number\">0</span>, <span class=\"number\">3</span>, <span class=\"number\">6</span>, <span class=\"number\">9</span>]</span><br><span class=\"line\"><span class=\"comment\"># 压缩稀疏行矩阵</span></span><br><span class=\"line\"><span class=\"comment\"># indices[1]和indices[2]均指向第0行的第0列，所以矩阵中结果为2。第1行第1列也是一样</span></span><br><span class=\"line\"><span class=\"comment\"># [[2 1 0 0 0]</span></span><br><span class=\"line\"><span class=\"comment\">#  [0 2 0 1 0]</span></span><br><span class=\"line\"><span class=\"comment\">#  [0 0 1 1 1]]</span></span><br><span class=\"line\">small_example = csr_matrix((data, indices, indptr)).toarray()</span><br><span class=\"line\"><span class=\"comment\"># 将矩阵转换为一维</span></span><br><span class=\"line\"><span class=\"comment\"># [2 1 0 0 0 0 2 0 1 0 0 0 1 1 1]</span></span><br><span class=\"line\">small_example_flatten = small_example.flatten()</span><br><span class=\"line\"><span class=\"comment\"># 元素总数</span></span><br><span class=\"line\"><span class=\"comment\"># 15</span></span><br><span class=\"line\">total = small_example_flatten.shape[<span class=\"number\">0</span>]</span><br><span class=\"line\"><span class=\"comment\"># 0元素数量</span></span><br><span class=\"line\"><span class=\"comment\"># 7</span></span><br><span class=\"line\">none_count = count_nonzero(small_example_flatten)</span><br><span class=\"line\"><span class=\"comment\"># 矩阵的稀疏性</span></span><br><span class=\"line\"><span class=\"comment\"># 0.5333333333333333</span></span><br><span class=\"line\">sparsity = <span class=\"number\">1.0</span> - none_count / total</span><br></pre></td></tr></table></figure>\n<p>使用 <code>numpy</code> 在 <strong>稀疏矩阵</strong> 和 <strong>稠密矩阵</strong> 间转换。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> scipy.sparse <span class=\"keyword\">import</span> csr_matrix</span><br><span class=\"line\"></span><br><span class=\"line\">arr = [[<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>], [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>], [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>]]</span><br><span class=\"line\"><span class=\"comment\"># 创建稠密矩阵</span></span><br><span class=\"line\"><span class=\"comment\"># (0, 0)\t1</span></span><br><span class=\"line\"><span class=\"comment\"># (1, 1)\t1</span></span><br><span class=\"line\"><span class=\"comment\"># (2, 2)\t1</span></span><br><span class=\"line\">matrix = csr_matrix(arr)</span><br><span class=\"line\"><span class=\"comment\"># 返回此矩阵的密集ndarray表示</span></span><br><span class=\"line\"><span class=\"comment\"># [[1 0 0]</span></span><br><span class=\"line\"><span class=\"comment\"># [0 1 0]</span></span><br><span class=\"line\"><span class=\"comment\"># [0 0 1]]</span></span><br><span class=\"line\">matrix.toarray()</span><br></pre></td></tr></table></figure>\n<p>###### </p>\n<h1 id=\"待处理\"><a href=\"#待处理\" class=\"headerlink\" title=\"待处理\"></a>待处理</h1><ul>\n<li>[] 逻辑回归</li>\n<li>[] StandardScalers数据预处理</li>\n<li>[] Matrix的Sum</li>\n<li>[] np.logspace</li>\n<li>[] tqdm</li>\n<li>[] np.argmax</li>\n<li>[] LogisticRegression</li>\n<li>[] plt.axhline</li>\n<li>[] hstack</li>\n<li>[] 学习如何使用稀疏矩阵，训练逻辑回归模型，创建新特征并选择最佳特征</li>\n</ul>\n"},{"title":"机器学习手记","date":"2018-11-09T00:27:54.000Z","updated":"2018-11-11T16:00:00.000Z","typora-root-url":"机器学习手记","mathjax":true,"description":"<!—more—->","_content":"\n### 机器学习的分类\n\n{% blockquote http://sklearn.apachecn.org/cn/0.19.0/tutorial/basic/tutorial.html 机器学习：问题设置 %}\n\n- [监督学习](https://en.wikipedia.org/wiki/Supervised_learning) , 其中数据带有一个附加属性，即我们想要预测的结果值（ [点击此处](http://sklearn.apachecn.org/cn/0.19.0/supervised_learning.html#supervised-learning) 转到 scikit-learn 监督学习页面）。这个问题可以是:\n\n  - [分类](https://en.wikipedia.org/wiki/Classification_in_machine_learning) : 样本属于两个或更多个类，我们想从已经标记的数据中学习如何预测未标记数据的类别。 分类问题的一个例子是手写数字识别，其目的是将每个输入向量分配给有限数目的离散类别之一。 我们通常把分类视作监督学习的一个离散形式（区别于连续形式），从有限的类别中，给每个样本贴上正确的标签。\n  - [回归](https://en.wikipedia.org/wiki/Regression_analysis) : 如果期望的输出由一个或多个连续变量组成，则该任务称为 *回归* 。 回归问题的一个例子是利用历史数据判断未来天气温度数据。\n\n- [无监督学习](https://en.wikipedia.org/wiki/Unsupervised_learning), 其中训练数据由没有任何相应目标值的一组输入向量x组成。这种问题的目标可能是在数据中发现彼此类似的示例所聚成的组，这种问题称为 [聚类](https://en.wikipedia.org/wiki/Cluster_analysis) , 或者，确定输入空间内的数据分布，称为 [密度估计](https://en.wikipedia.org/wiki/Density_estimation) ，又或从高维数据投影数据空间缩小到二维或三维以进行 *可视化* （[点击此处](http://sklearn.apachecn.org/cn/0.19.0/unsupervised_learning.html#unsupervised-learning) 转到 scikit-learn 无监督学习页面）。\n\n{% endblockquote %}\n\n### [选择正确的评估器(estimator)](http://sklearn.apachecn.org/cn/0.19.0/tutorial/machine_learning_map/index.html#)\n\n### 垃圾进——垃圾出\n\n{% blockquote https://zh.wikipedia.org/wiki/%E5%9E%83%E5%9C%BE%E8%BF%9B%EF%BC%8C%E5%9E%83%E5%9C%BE%E5%87%BA 垃圾进，垃圾出 %}\n\n著名的“垃圾进——垃圾出”概念100%适用于机器学习的任何任务。在高质量数据上训练的简单模型，表现优于在未清理的数据上训练的复杂多模型集成。\n\n{% endblockquote %}\n\n### 特征缩放\n\n网上中文资料对于 *归一化*，*标准化* 的解释比较混乱。[Feature scaling](https://en.wikipedia.org/wiki/Feature_scaling) 看英文版本较好。下面是我自己整理的解释。\n\n首先是个人对于这两个定义的理解：\n\n* 归一化首先确定最大最小的范围，使得数据在范围内缩放。\n* 标准化首先确定中间值，然后向两侧发散。\n\n#### 正则化/归一化（Normalization）\n\n##### Rescaling (min-max normalization) 重新缩放（min-max 正则化）\n\n把数据变为（0，1）之间的小数。主要是为了方便数据处理，因为**将数据映射到0～1范围之内**，可以使处理过程更加便捷、快速。\n\n${x}'=\\frac{x-min\\left ( x \\right )}{max\\left ( x \\right )-min\\left ( x \\right )}$\n\n```python MinMaxScaler https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.MinMaxScaler.html sklearn.preprocessing.MinMaxScaler\n>>> from sklearn.preprocessing import MinMaxScaler\n>>>\n>>> data = [[-1, 2], [-0.5, 6], [0, 10], [1, 18]]\n>>> scaler = MinMaxScaler()\n>>> print(scaler.fit(data))\nMinMaxScaler(copy=True, feature_range=(0, 1))\n>>> print(scaler.data_max_)\n[ 1. 18.]\n>>> print(scaler.transform(data))\n[[0.   0.  ]\n [0.25 0.25]\n [0.5  0.5 ]\n [1.   1.  ]]\n>>> print(scaler.transform([[2, 2]]))\n[[1.5 0. ]]\n```\n\n##### Mean normalization 均值归一化\n\n${x}'=\\frac{x-average\\left ( x \\right )}{max\\left ( x \\right )-min\\left ( x \\right )}$\n\n#### 标准化（Standardization）\n\n特征标准化使得数据中每个特征的值具有**零均值**（当减去分子中的平均值时）和**单位方差**。\n\n> 使得不同度量之间的特征具有可比性。同时不改变原始数据的分布。\n\n${x}'=\\frac{x - \\bar{x}}{\\sigma}$\n\n其中 $\\bar {x}={\\text{average}}(x)$， $\\sigma$ 是标准差。\n\n```python StandardScaler https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.StandardScaler.html#sklearn.preprocessing.StandardScaler sklearn.preprocessing.StandardScaler\n>>> from sklearn.preprocessing import StandardScaler\n>>> data = [[0, 0], [0, 0], [1, 1], [1, 1]]\n>>> scaler = StandardScaler()\n>>> print(scaler.fit(data))\nStandardScaler(copy=True, with_mean=True, with_std=True)\n>>> print(scaler.mean_)\n[0.5 0.5]\n>>> print(scaler.transform(data))\n[[-1. -1.]\n [-1. -1.]\n [ 1.  1.]\n [ 1.  1.]]\n>>> print(scaler.transform([[2, 2]]))\n[[3. 3.]]\n```\n\n","source":"_posts/机器学习手记.md","raw":"---\ntitle: 机器学习手记\ndate: 2018-11-09 08:27:54\nupdated: 2018-11-12\ntags:\n - 编程\n - Python\n - 机器学习\n - sklearn.preprocessing.MinMaxScaler\n - sklearn.preprocessing.StandardScaler\ncategories:\n - 编程\n - Python\n - 机器学习\ntypora-root-url: 机器学习手记\nmathjax: true\ndescription: <!—more—->\n---\n\n### 机器学习的分类\n\n{% blockquote http://sklearn.apachecn.org/cn/0.19.0/tutorial/basic/tutorial.html 机器学习：问题设置 %}\n\n- [监督学习](https://en.wikipedia.org/wiki/Supervised_learning) , 其中数据带有一个附加属性，即我们想要预测的结果值（ [点击此处](http://sklearn.apachecn.org/cn/0.19.0/supervised_learning.html#supervised-learning) 转到 scikit-learn 监督学习页面）。这个问题可以是:\n\n  - [分类](https://en.wikipedia.org/wiki/Classification_in_machine_learning) : 样本属于两个或更多个类，我们想从已经标记的数据中学习如何预测未标记数据的类别。 分类问题的一个例子是手写数字识别，其目的是将每个输入向量分配给有限数目的离散类别之一。 我们通常把分类视作监督学习的一个离散形式（区别于连续形式），从有限的类别中，给每个样本贴上正确的标签。\n  - [回归](https://en.wikipedia.org/wiki/Regression_analysis) : 如果期望的输出由一个或多个连续变量组成，则该任务称为 *回归* 。 回归问题的一个例子是利用历史数据判断未来天气温度数据。\n\n- [无监督学习](https://en.wikipedia.org/wiki/Unsupervised_learning), 其中训练数据由没有任何相应目标值的一组输入向量x组成。这种问题的目标可能是在数据中发现彼此类似的示例所聚成的组，这种问题称为 [聚类](https://en.wikipedia.org/wiki/Cluster_analysis) , 或者，确定输入空间内的数据分布，称为 [密度估计](https://en.wikipedia.org/wiki/Density_estimation) ，又或从高维数据投影数据空间缩小到二维或三维以进行 *可视化* （[点击此处](http://sklearn.apachecn.org/cn/0.19.0/unsupervised_learning.html#unsupervised-learning) 转到 scikit-learn 无监督学习页面）。\n\n{% endblockquote %}\n\n### [选择正确的评估器(estimator)](http://sklearn.apachecn.org/cn/0.19.0/tutorial/machine_learning_map/index.html#)\n\n### 垃圾进——垃圾出\n\n{% blockquote https://zh.wikipedia.org/wiki/%E5%9E%83%E5%9C%BE%E8%BF%9B%EF%BC%8C%E5%9E%83%E5%9C%BE%E5%87%BA 垃圾进，垃圾出 %}\n\n著名的“垃圾进——垃圾出”概念100%适用于机器学习的任何任务。在高质量数据上训练的简单模型，表现优于在未清理的数据上训练的复杂多模型集成。\n\n{% endblockquote %}\n\n### 特征缩放\n\n网上中文资料对于 *归一化*，*标准化* 的解释比较混乱。[Feature scaling](https://en.wikipedia.org/wiki/Feature_scaling) 看英文版本较好。下面是我自己整理的解释。\n\n首先是个人对于这两个定义的理解：\n\n* 归一化首先确定最大最小的范围，使得数据在范围内缩放。\n* 标准化首先确定中间值，然后向两侧发散。\n\n#### 正则化/归一化（Normalization）\n\n##### Rescaling (min-max normalization) 重新缩放（min-max 正则化）\n\n把数据变为（0，1）之间的小数。主要是为了方便数据处理，因为**将数据映射到0～1范围之内**，可以使处理过程更加便捷、快速。\n\n${x}'=\\frac{x-min\\left ( x \\right )}{max\\left ( x \\right )-min\\left ( x \\right )}$\n\n```python MinMaxScaler https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.MinMaxScaler.html sklearn.preprocessing.MinMaxScaler\n>>> from sklearn.preprocessing import MinMaxScaler\n>>>\n>>> data = [[-1, 2], [-0.5, 6], [0, 10], [1, 18]]\n>>> scaler = MinMaxScaler()\n>>> print(scaler.fit(data))\nMinMaxScaler(copy=True, feature_range=(0, 1))\n>>> print(scaler.data_max_)\n[ 1. 18.]\n>>> print(scaler.transform(data))\n[[0.   0.  ]\n [0.25 0.25]\n [0.5  0.5 ]\n [1.   1.  ]]\n>>> print(scaler.transform([[2, 2]]))\n[[1.5 0. ]]\n```\n\n##### Mean normalization 均值归一化\n\n${x}'=\\frac{x-average\\left ( x \\right )}{max\\left ( x \\right )-min\\left ( x \\right )}$\n\n#### 标准化（Standardization）\n\n特征标准化使得数据中每个特征的值具有**零均值**（当减去分子中的平均值时）和**单位方差**。\n\n> 使得不同度量之间的特征具有可比性。同时不改变原始数据的分布。\n\n${x}'=\\frac{x - \\bar{x}}{\\sigma}$\n\n其中 $\\bar {x}={\\text{average}}(x)$， $\\sigma$ 是标准差。\n\n```python StandardScaler https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.StandardScaler.html#sklearn.preprocessing.StandardScaler sklearn.preprocessing.StandardScaler\n>>> from sklearn.preprocessing import StandardScaler\n>>> data = [[0, 0], [0, 0], [1, 1], [1, 1]]\n>>> scaler = StandardScaler()\n>>> print(scaler.fit(data))\nStandardScaler(copy=True, with_mean=True, with_std=True)\n>>> print(scaler.mean_)\n[0.5 0.5]\n>>> print(scaler.transform(data))\n[[-1. -1.]\n [-1. -1.]\n [ 1.  1.]\n [ 1.  1.]]\n>>> print(scaler.transform([[2, 2]]))\n[[3. 3.]]\n```\n\n","slug":"机器学习手记","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cjof51pkt000orgueyliu9m0j","content":"<h3 id=\"机器学习的分类\"><a href=\"#机器学习的分类\" class=\"headerlink\" title=\"机器学习的分类\"></a>机器学习的分类</h3><blockquote><ul>\n<li><p><a href=\"https://en.wikipedia.org/wiki/Supervised_learning\" target=\"_blank\" rel=\"noopener\">监督学习</a> , 其中数据带有一个附加属性，即我们想要预测的结果值（ <a href=\"http://sklearn.apachecn.org/cn/0.19.0/supervised_learning.html#supervised-learning\" target=\"_blank\" rel=\"noopener\">点击此处</a> 转到 scikit-learn 监督学习页面）。这个问题可以是:</p>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Classification_in_machine_learning\" target=\"_blank\" rel=\"noopener\">分类</a> : 样本属于两个或更多个类，我们想从已经标记的数据中学习如何预测未标记数据的类别。 分类问题的一个例子是手写数字识别，其目的是将每个输入向量分配给有限数目的离散类别之一。 我们通常把分类视作监督学习的一个离散形式（区别于连续形式），从有限的类别中，给每个样本贴上正确的标签。</li>\n<li><a href=\"https://en.wikipedia.org/wiki/Regression_analysis\" target=\"_blank\" rel=\"noopener\">回归</a> : 如果期望的输出由一个或多个连续变量组成，则该任务称为 <em>回归</em> 。 回归问题的一个例子是利用历史数据判断未来天气温度数据。</li>\n</ul>\n</li>\n<li><p><a href=\"https://en.wikipedia.org/wiki/Unsupervised_learning\" target=\"_blank\" rel=\"noopener\">无监督学习</a>, 其中训练数据由没有任何相应目标值的一组输入向量x组成。这种问题的目标可能是在数据中发现彼此类似的示例所聚成的组，这种问题称为 <a href=\"https://en.wikipedia.org/wiki/Cluster_analysis\" target=\"_blank\" rel=\"noopener\">聚类</a> , 或者，确定输入空间内的数据分布，称为 <a href=\"https://en.wikipedia.org/wiki/Density_estimation\" target=\"_blank\" rel=\"noopener\">密度估计</a> ，又或从高维数据投影数据空间缩小到二维或三维以进行 <em>可视化</em> （<a href=\"http://sklearn.apachecn.org/cn/0.19.0/unsupervised_learning.html#unsupervised-learning\" target=\"_blank\" rel=\"noopener\">点击此处</a> 转到 scikit-learn 无监督学习页面）。</p>\n</li>\n</ul>\n<footer><cite><a href=\"http://sklearn.apachecn.org/cn/0.19.0/tutorial/basic/tutorial.html\" target=\"_blank\" rel=\"noopener\">机器学习：问题设置</a></cite></footer></blockquote>\n<h3 id=\"选择正确的评估器-estimator\"><a href=\"#选择正确的评估器-estimator\" class=\"headerlink\" title=\"选择正确的评估器(estimator)\"></a><a href=\"http://sklearn.apachecn.org/cn/0.19.0/tutorial/machine_learning_map/index.html#\" target=\"_blank\" rel=\"noopener\">选择正确的评估器(estimator)</a></h3><h3 id=\"垃圾进——垃圾出\"><a href=\"#垃圾进——垃圾出\" class=\"headerlink\" title=\"垃圾进——垃圾出\"></a>垃圾进——垃圾出</h3><blockquote><p>著名的“垃圾进——垃圾出”概念100%适用于机器学习的任何任务。在高质量数据上训练的简单模型，表现优于在未清理的数据上训练的复杂多模型集成。</p>\n<footer><cite><a href=\"https://zh.wikipedia.org/wiki/%E5%9E%83%E5%9C%BE%E8%BF%9B%EF%BC%8C%E5%9E%83%E5%9C%BE%E5%87%BA\" target=\"_blank\" rel=\"noopener\">垃圾进，垃圾出</a></cite></footer></blockquote>\n<h3 id=\"特征缩放\"><a href=\"#特征缩放\" class=\"headerlink\" title=\"特征缩放\"></a>特征缩放</h3><p>网上中文资料对于 <em>归一化</em>，<em>标准化</em> 的解释比较混乱。<a href=\"https://en.wikipedia.org/wiki/Feature_scaling\" target=\"_blank\" rel=\"noopener\">Feature scaling</a> 看英文版本较好。下面是我自己整理的解释。</p>\n<p>首先是个人对于这两个定义的理解：</p>\n<ul>\n<li>归一化首先确定最大最小的范围，使得数据在范围内缩放。</li>\n<li>标准化首先确定中间值，然后向两侧发散。</li>\n</ul>\n<h4 id=\"正则化-归一化（Normalization）\"><a href=\"#正则化-归一化（Normalization）\" class=\"headerlink\" title=\"正则化/归一化（Normalization）\"></a>正则化/归一化（Normalization）</h4><h5 id=\"Rescaling-min-max-normalization-重新缩放（min-max-正则化）\"><a href=\"#Rescaling-min-max-normalization-重新缩放（min-max-正则化）\" class=\"headerlink\" title=\"Rescaling (min-max normalization) 重新缩放（min-max 正则化）\"></a>Rescaling (min-max normalization) 重新缩放（min-max 正则化）</h5><p>把数据变为（0，1）之间的小数。主要是为了方便数据处理，因为<strong>将数据映射到0～1范围之内</strong>，可以使处理过程更加便捷、快速。</p>\n<p>${x}’=\\frac{x-min\\left ( x \\right )}{max\\left ( x \\right )-min\\left ( x \\right )}$</p>\n<figure class=\"highlight python\"><figcaption><span>MinMaxScaler</span><a href=\"https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.MinMaxScaler.html\" target=\"_blank\" rel=\"noopener\">sklearn.preprocessing.MinMaxScaler</a></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> sklearn.preprocessing <span class=\"keyword\">import</span> MinMaxScaler</span><br><span class=\"line\">&gt;&gt;&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>data = [[<span class=\"number\">-1</span>, <span class=\"number\">2</span>], [<span class=\"number\">-0.5</span>, <span class=\"number\">6</span>], [<span class=\"number\">0</span>, <span class=\"number\">10</span>], [<span class=\"number\">1</span>, <span class=\"number\">18</span>]]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>scaler = MinMaxScaler()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(scaler.fit(data))</span><br><span class=\"line\">MinMaxScaler(copy=<span class=\"keyword\">True</span>, feature_range=(<span class=\"number\">0</span>, <span class=\"number\">1</span>))</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(scaler.data_max_)</span><br><span class=\"line\">[ <span class=\"number\">1.</span> <span class=\"number\">18.</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(scaler.transform(data))</span><br><span class=\"line\">[[<span class=\"number\">0.</span>   <span class=\"number\">0.</span>  ]</span><br><span class=\"line\"> [<span class=\"number\">0.25</span> <span class=\"number\">0.25</span>]</span><br><span class=\"line\"> [<span class=\"number\">0.5</span>  <span class=\"number\">0.5</span> ]</span><br><span class=\"line\"> [<span class=\"number\">1.</span>   <span class=\"number\">1.</span>  ]]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(scaler.transform([[<span class=\"number\">2</span>, <span class=\"number\">2</span>]]))</span><br><span class=\"line\">[[<span class=\"number\">1.5</span> <span class=\"number\">0.</span> ]]</span><br></pre></td></tr></table></figure>\n<h5 id=\"Mean-normalization-均值归一化\"><a href=\"#Mean-normalization-均值归一化\" class=\"headerlink\" title=\"Mean normalization 均值归一化\"></a>Mean normalization 均值归一化</h5><p>${x}’=\\frac{x-average\\left ( x \\right )}{max\\left ( x \\right )-min\\left ( x \\right )}$</p>\n<h4 id=\"标准化（Standardization）\"><a href=\"#标准化（Standardization）\" class=\"headerlink\" title=\"标准化（Standardization）\"></a>标准化（Standardization）</h4><p>特征标准化使得数据中每个特征的值具有<strong>零均值</strong>（当减去分子中的平均值时）和<strong>单位方差</strong>。</p>\n<blockquote>\n<p>使得不同度量之间的特征具有可比性。同时不改变原始数据的分布。</p>\n</blockquote>\n<p>${x}’=\\frac{x - \\bar{x}}{\\sigma}$</p>\n<p>其中 $\\bar {x}={\\text{average}}(x)$， $\\sigma$ 是标准差。</p>\n<figure class=\"highlight python\"><figcaption><span>StandardScaler</span><a href=\"https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.StandardScaler.html#sklearn.preprocessing.StandardScaler\" target=\"_blank\" rel=\"noopener\">sklearn.preprocessing.StandardScaler</a></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> sklearn.preprocessing <span class=\"keyword\">import</span> StandardScaler</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>data = [[<span class=\"number\">0</span>, <span class=\"number\">0</span>], [<span class=\"number\">0</span>, <span class=\"number\">0</span>], [<span class=\"number\">1</span>, <span class=\"number\">1</span>], [<span class=\"number\">1</span>, <span class=\"number\">1</span>]]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>scaler = StandardScaler()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(scaler.fit(data))</span><br><span class=\"line\">StandardScaler(copy=<span class=\"keyword\">True</span>, with_mean=<span class=\"keyword\">True</span>, with_std=<span class=\"keyword\">True</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(scaler.mean_)</span><br><span class=\"line\">[<span class=\"number\">0.5</span> <span class=\"number\">0.5</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(scaler.transform(data))</span><br><span class=\"line\">[[<span class=\"number\">-1.</span> <span class=\"number\">-1.</span>]</span><br><span class=\"line\"> [<span class=\"number\">-1.</span> <span class=\"number\">-1.</span>]</span><br><span class=\"line\"> [ <span class=\"number\">1.</span>  <span class=\"number\">1.</span>]</span><br><span class=\"line\"> [ <span class=\"number\">1.</span>  <span class=\"number\">1.</span>]]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(scaler.transform([[<span class=\"number\">2</span>, <span class=\"number\">2</span>]]))</span><br><span class=\"line\">[[<span class=\"number\">3.</span> <span class=\"number\">3.</span>]]</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"机器学习的分类\"><a href=\"#机器学习的分类\" class=\"headerlink\" title=\"机器学习的分类\"></a>机器学习的分类</h3><blockquote><ul>\n<li><p><a href=\"https://en.wikipedia.org/wiki/Supervised_learning\" target=\"_blank\" rel=\"noopener\">监督学习</a> , 其中数据带有一个附加属性，即我们想要预测的结果值（ <a href=\"http://sklearn.apachecn.org/cn/0.19.0/supervised_learning.html#supervised-learning\" target=\"_blank\" rel=\"noopener\">点击此处</a> 转到 scikit-learn 监督学习页面）。这个问题可以是:</p>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Classification_in_machine_learning\" target=\"_blank\" rel=\"noopener\">分类</a> : 样本属于两个或更多个类，我们想从已经标记的数据中学习如何预测未标记数据的类别。 分类问题的一个例子是手写数字识别，其目的是将每个输入向量分配给有限数目的离散类别之一。 我们通常把分类视作监督学习的一个离散形式（区别于连续形式），从有限的类别中，给每个样本贴上正确的标签。</li>\n<li><a href=\"https://en.wikipedia.org/wiki/Regression_analysis\" target=\"_blank\" rel=\"noopener\">回归</a> : 如果期望的输出由一个或多个连续变量组成，则该任务称为 <em>回归</em> 。 回归问题的一个例子是利用历史数据判断未来天气温度数据。</li>\n</ul>\n</li>\n<li><p><a href=\"https://en.wikipedia.org/wiki/Unsupervised_learning\" target=\"_blank\" rel=\"noopener\">无监督学习</a>, 其中训练数据由没有任何相应目标值的一组输入向量x组成。这种问题的目标可能是在数据中发现彼此类似的示例所聚成的组，这种问题称为 <a href=\"https://en.wikipedia.org/wiki/Cluster_analysis\" target=\"_blank\" rel=\"noopener\">聚类</a> , 或者，确定输入空间内的数据分布，称为 <a href=\"https://en.wikipedia.org/wiki/Density_estimation\" target=\"_blank\" rel=\"noopener\">密度估计</a> ，又或从高维数据投影数据空间缩小到二维或三维以进行 <em>可视化</em> （<a href=\"http://sklearn.apachecn.org/cn/0.19.0/unsupervised_learning.html#unsupervised-learning\" target=\"_blank\" rel=\"noopener\">点击此处</a> 转到 scikit-learn 无监督学习页面）。</p>\n</li>\n</ul>\n<footer><cite><a href=\"http://sklearn.apachecn.org/cn/0.19.0/tutorial/basic/tutorial.html\" target=\"_blank\" rel=\"noopener\">机器学习：问题设置</a></cite></footer></blockquote>\n<h3 id=\"选择正确的评估器-estimator\"><a href=\"#选择正确的评估器-estimator\" class=\"headerlink\" title=\"选择正确的评估器(estimator)\"></a><a href=\"http://sklearn.apachecn.org/cn/0.19.0/tutorial/machine_learning_map/index.html#\" target=\"_blank\" rel=\"noopener\">选择正确的评估器(estimator)</a></h3><h3 id=\"垃圾进——垃圾出\"><a href=\"#垃圾进——垃圾出\" class=\"headerlink\" title=\"垃圾进——垃圾出\"></a>垃圾进——垃圾出</h3><blockquote><p>著名的“垃圾进——垃圾出”概念100%适用于机器学习的任何任务。在高质量数据上训练的简单模型，表现优于在未清理的数据上训练的复杂多模型集成。</p>\n<footer><cite><a href=\"https://zh.wikipedia.org/wiki/%E5%9E%83%E5%9C%BE%E8%BF%9B%EF%BC%8C%E5%9E%83%E5%9C%BE%E5%87%BA\" target=\"_blank\" rel=\"noopener\">垃圾进，垃圾出</a></cite></footer></blockquote>\n<h3 id=\"特征缩放\"><a href=\"#特征缩放\" class=\"headerlink\" title=\"特征缩放\"></a>特征缩放</h3><p>网上中文资料对于 <em>归一化</em>，<em>标准化</em> 的解释比较混乱。<a href=\"https://en.wikipedia.org/wiki/Feature_scaling\" target=\"_blank\" rel=\"noopener\">Feature scaling</a> 看英文版本较好。下面是我自己整理的解释。</p>\n<p>首先是个人对于这两个定义的理解：</p>\n<ul>\n<li>归一化首先确定最大最小的范围，使得数据在范围内缩放。</li>\n<li>标准化首先确定中间值，然后向两侧发散。</li>\n</ul>\n<h4 id=\"正则化-归一化（Normalization）\"><a href=\"#正则化-归一化（Normalization）\" class=\"headerlink\" title=\"正则化/归一化（Normalization）\"></a>正则化/归一化（Normalization）</h4><h5 id=\"Rescaling-min-max-normalization-重新缩放（min-max-正则化）\"><a href=\"#Rescaling-min-max-normalization-重新缩放（min-max-正则化）\" class=\"headerlink\" title=\"Rescaling (min-max normalization) 重新缩放（min-max 正则化）\"></a>Rescaling (min-max normalization) 重新缩放（min-max 正则化）</h5><p>把数据变为（0，1）之间的小数。主要是为了方便数据处理，因为<strong>将数据映射到0～1范围之内</strong>，可以使处理过程更加便捷、快速。</p>\n<p>${x}’=\\frac{x-min\\left ( x \\right )}{max\\left ( x \\right )-min\\left ( x \\right )}$</p>\n<figure class=\"highlight python\"><figcaption><span>MinMaxScaler</span><a href=\"https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.MinMaxScaler.html\" target=\"_blank\" rel=\"noopener\">sklearn.preprocessing.MinMaxScaler</a></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> sklearn.preprocessing <span class=\"keyword\">import</span> MinMaxScaler</span><br><span class=\"line\">&gt;&gt;&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>data = [[<span class=\"number\">-1</span>, <span class=\"number\">2</span>], [<span class=\"number\">-0.5</span>, <span class=\"number\">6</span>], [<span class=\"number\">0</span>, <span class=\"number\">10</span>], [<span class=\"number\">1</span>, <span class=\"number\">18</span>]]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>scaler = MinMaxScaler()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(scaler.fit(data))</span><br><span class=\"line\">MinMaxScaler(copy=<span class=\"keyword\">True</span>, feature_range=(<span class=\"number\">0</span>, <span class=\"number\">1</span>))</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(scaler.data_max_)</span><br><span class=\"line\">[ <span class=\"number\">1.</span> <span class=\"number\">18.</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(scaler.transform(data))</span><br><span class=\"line\">[[<span class=\"number\">0.</span>   <span class=\"number\">0.</span>  ]</span><br><span class=\"line\"> [<span class=\"number\">0.25</span> <span class=\"number\">0.25</span>]</span><br><span class=\"line\"> [<span class=\"number\">0.5</span>  <span class=\"number\">0.5</span> ]</span><br><span class=\"line\"> [<span class=\"number\">1.</span>   <span class=\"number\">1.</span>  ]]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(scaler.transform([[<span class=\"number\">2</span>, <span class=\"number\">2</span>]]))</span><br><span class=\"line\">[[<span class=\"number\">1.5</span> <span class=\"number\">0.</span> ]]</span><br></pre></td></tr></table></figure>\n<h5 id=\"Mean-normalization-均值归一化\"><a href=\"#Mean-normalization-均值归一化\" class=\"headerlink\" title=\"Mean normalization 均值归一化\"></a>Mean normalization 均值归一化</h5><p>${x}’=\\frac{x-average\\left ( x \\right )}{max\\left ( x \\right )-min\\left ( x \\right )}$</p>\n<h4 id=\"标准化（Standardization）\"><a href=\"#标准化（Standardization）\" class=\"headerlink\" title=\"标准化（Standardization）\"></a>标准化（Standardization）</h4><p>特征标准化使得数据中每个特征的值具有<strong>零均值</strong>（当减去分子中的平均值时）和<strong>单位方差</strong>。</p>\n<blockquote>\n<p>使得不同度量之间的特征具有可比性。同时不改变原始数据的分布。</p>\n</blockquote>\n<p>${x}’=\\frac{x - \\bar{x}}{\\sigma}$</p>\n<p>其中 $\\bar {x}={\\text{average}}(x)$， $\\sigma$ 是标准差。</p>\n<figure class=\"highlight python\"><figcaption><span>StandardScaler</span><a href=\"https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.StandardScaler.html#sklearn.preprocessing.StandardScaler\" target=\"_blank\" rel=\"noopener\">sklearn.preprocessing.StandardScaler</a></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> sklearn.preprocessing <span class=\"keyword\">import</span> StandardScaler</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>data = [[<span class=\"number\">0</span>, <span class=\"number\">0</span>], [<span class=\"number\">0</span>, <span class=\"number\">0</span>], [<span class=\"number\">1</span>, <span class=\"number\">1</span>], [<span class=\"number\">1</span>, <span class=\"number\">1</span>]]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>scaler = StandardScaler()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(scaler.fit(data))</span><br><span class=\"line\">StandardScaler(copy=<span class=\"keyword\">True</span>, with_mean=<span class=\"keyword\">True</span>, with_std=<span class=\"keyword\">True</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(scaler.mean_)</span><br><span class=\"line\">[<span class=\"number\">0.5</span> <span class=\"number\">0.5</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(scaler.transform(data))</span><br><span class=\"line\">[[<span class=\"number\">-1.</span> <span class=\"number\">-1.</span>]</span><br><span class=\"line\"> [<span class=\"number\">-1.</span> <span class=\"number\">-1.</span>]</span><br><span class=\"line\"> [ <span class=\"number\">1.</span>  <span class=\"number\">1.</span>]</span><br><span class=\"line\"> [ <span class=\"number\">1.</span>  <span class=\"number\">1.</span>]]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(scaler.transform([[<span class=\"number\">2</span>, <span class=\"number\">2</span>]]))</span><br><span class=\"line\">[[<span class=\"number\">3.</span> <span class=\"number\">3.</span>]]</span><br></pre></td></tr></table></figure>\n"},{"title":"概率论基础教程","date":"2018-07-18T02:45:26.000Z","updated":"2018-07-24T16:00:00.000Z","出版社":"人民邮电出版社","ISBN":9787115221100,"出版时间":"2010-03-31T16:00:00.000Z","description":"<!—more—->","mathjax":true,"typora-root-url":"概率论基础教程","_content":"\n#### 第一章 组合分析\n\n##### 1.2 计数基本法则\n\n有两个实验，其中实验一有 $m$ 种可能发生的结果，对应于实验一的每一个结果，实验二有 $n$ 中可能发生的结果，则对于这两个实验来说，一共有 $m\\times$$n$ 中可能的结果。\n\n*推广的计数基本法则：*\n\n一共有 $r$ 个实验。第一个实验有 $n_1$ 种可能结果；对应于第一个实验的每一种结果，第二个实验有 $n_2$ 种可能的结果；对应于头两个实验的每一种实验结果，第三个实验有 $n_3$ 种可能的结果；等等。那么，这 $r$ 个实验一共有 $n_1,n_2,\\cdots,n_n$ 种可能结果。\n\n> 例：车牌号是7位的，如果要求前3个位置必须是字母，后4个必须是数字，一共有多少种编排车牌号的方式？\n>\n> ​\t26$\\times$26$\\times$26$\\times$10$\\times$10$\\times$10$\\times$10$=$17576000\n\n##### 1.3 排列\n\n按随意顺序来排列字母 a,b,c，一共有多少种排列方式？通过推广的计数基本法则得到：在排列中的第一个位置可供选择的元素有 3 个，第二个位置是剩下的两个，第三个位置只能选择剩下的一个元素，因此一共有 3\\*2\\*1=6 种可能的排列。\n\n假设有 n 个元素，那么用上述类似的方法，可知一共有 `n(n-1)(n-2)=n!` 种不同的排列方式。\n\n> 例：一个垒球队共有 9 名队员，问一共有多少种击球顺序？\n>\n> ​\t9! = 362880\n>\n> 例：把10本书放到书架上，其中4本数学书、3本化学书、2本历史书和1本语文书。现在要求相同类别的书必须紧挨着放，问一共有多少种放法？\n>\n> ​\t如果数学书放在最前面，接下来放化学书，再下来放历史书，最后放语文书，那么一共有 `4!3!2!1!` 种排列方式。而这4种书的顺序又是 `4!` ，因此，答案应该是 `4!4!3!2!1!=6912`\n\n接下来讨论如果有 $n$ 个元素，其中有些是不可区分的，这种排列数如何计算？\n\n$n$ 个元素，如果其中 $n_1$ 个元素彼此不可区分，另 $n_2$ 个彼此不可区分，$n_r$ 个彼此不可区分，那么一共有 $\\frac {n!}{n_1!n_2!...n_r!} $ 中排列方式。\n\n> 例：一个棋类比赛一共有 10 个选手，其中 4 个来自俄罗斯，3个来自美国，2个来自英国，另一个来自巴西。如果比赛结果只记录选手的国籍，那么一共有多少种可能？\n>\n> ​        $\\frac{10!}{4!3!2!1!}  = 12600$\n\n##### 1.4 组合\n\n从 $n$ 个元素中取 $r$ 个，一共有多少种取法？比如，从A,B,C,D,E这5个元素中选取3个组成一组，一共有多少种取法？解答如下：取第一个有5种取法，取第二个有4中取法，取第三个有3种取法，所以，如果考虑顺序的话，那么一共有5\\*4\\*3种取法。但是，每一个包含3个元素的组都被计算了6此（ABC,ACB,BAC,BCA,CAB,CBA)。所以，如果考虑顺序的话组成方法数为：$\\frac{5\\times4\\times3}{3\\times2\\times1}=10$，定义$\\binom{r}{n}$如下：$\\binom{r}{n}=\\frac{n!}{(n-r)!r!}$ 并且说 $\\binom{r}{n}$ 表示了从 n 个元素中一次取 r 个可能组合数。\n\n> 例：从 20 人中选择 3 人组成委员会，一共有多少种取法？\n>\n> 一共有 $\\binom{20}{3}=\\frac{20\\times19\\times18}{3\\times2\\times1}=1140$种\n>\n> 例：有 12 人组成的团体，其中 5 位女士，7位男士，现从中选取2位女士，3位男士组成委员会，问有多少种取法？\n>\n> 有 $\\binom{5}{2}$种方式选取女士，有$\\binom{7}{2}$中方式选取男士。根据基本计数法则一共有$\\binom{5}{2}\\binom{7}{2}=\\frac{5\\times4}{2\\times1}\\times\\frac{7\\times6\\times5}{3\\times2\\times1}=350$种方式选取2位女士3位男士。\n>\n> 例：如果其中有2位男士之间有矛盾，并且坚决拒绝一起工作，那么又有多少种取法？\n>\n> 有$\\binom{2}{2}\\binom{5}{1}=5$种可能会同时包含该两位男士，所以一共有35-5种选取方法不同时包含那两位有矛盾的男士；另外，选取女士的方法仍然是$\\binom{5}{2}=10$种，所以一共有 $30\\times10=300$种选取方式。\n\n##### 1.5多项式系数\n\n有 $n$ 个不同的元素，分成 $r$ 组，每组分别有 $n_1,n_2,\\cdots,n_r$ 个元素，其中$\\sum_{i=1}^r n_i=n$，一共有多少种分法？\n\n根据推广的计数基本法则，将 $n$ 个元素分成 $r$ 组的分法总数一共是\n$$\n\\begin{align}\n&\\binom{n}{n_1}\\binom{n-n_1}{n2}\\cdots\\binom{n-n_1-n_2-\\cdots-n_{r-1}}{n_r} \\\\\\\\\n&=\\frac{n!}{(n-n_1)!n_1!}\\times\\frac{(n-n_1)!}{(n-n_1-n_2)!n_2!}\\cdots\\frac{(n-n_1-n_2-\\cdots-n_{r-1})!}{0!n_r!} \\\\\\\\\n&=\\frac{n!}{n_1!n_2! \\cdots n_r!}\n\\end{align}\n$$\n\n> 例： 某城市的警察局有 10 名警察，其中需要 5 名警察在接到巡逻，2 名警察在局里值班，另 3 名留在局里待命。问把 10 名警察分成这样的三组有多少种分法？\n>\n> 一共有 $\\frac{10!}{5!2!3!}=2520$种解法\n>\n> 例：10个小孩要分成A,B两队，每队5人。A队取参加一场比赛，B队取参加另一场比赛，一共有多少种分法？\n>\n> 一共有 $\\frac{10!}{5!5!}=252$种分法。\n\n\n\n#### 第二章 概率论公理化\n\n##### 2.2 样本空间和事件\n\n样本空间是包含了所有可能的结果的集合。\n\n> 若考察新生儿的性别，那么所有可能结果的集合是 $S=\\{g,b\\}$ 就是一个空间样本，其中 $g$ 表示女孩，$b$ 表示男孩。\n>\n> 赛马比赛中一共有7匹马参赛，这7匹马分别标以 1,2,3,4,5,6,7。考察比赛结果，所有可能的比赛结果的集合 $S=\\{(1,2,3,4,5,6,7)的所有7!种排列\\}$就是一个空间样本。比如(2,3,1,6,5,4,7)就表示2号马跑第一，3号马跑第二，接下来是一号码......这是比赛的一种可能结果。\n>\n> 掷两枚硬币，考察哪一面朝上，那么样本空间一共包含如下四种结果： $S=\\{(H,H),(H,T),(T,H),(T,T)\\}$。\n>\n> 掷两枚骰子，考察两枚骰子的点数，那么样本空间包含 $36$ 个结果：$S=\\{(i,j):i,j=1,2,3,4,5,6\\}$\n>\n> 考察一个晶体管的寿命（小时），那么样本空间是所有的非负实数，即 $S=\\{x:0 \\leq x<\\infty\\}$\n\n样本空间的任一自己 $E$ 称为事件(event)，事件是由实验的某些可能结果组成的一个集合。如果实验结果包含在 $E$ 中，那么就称 $E$ 发生了。\n\n> 接上面的例子：\n>\n> 令 $E=\\{g\\}$ ，那么 $E$ 就表示 “婴儿是个女孩” 这个事件；\n>\n> 如果 $E=\\{所有以3开头的排列\\}$，那么 $E$ 就表示 “3号马获得了第一”。\n>\n> 如果 $E=\\{(H,H),(H,T)\\}$，那么 $E$ 就表示 “第一枚硬币正面朝上”。\n>\n> 如果 $E=\\{(1,6),(2,5),(3,4),(4,3),(5,2),(6,1)\\}$，那么 $E$ 就表示 “两个骰子点数之和为 $7$”。\n>\n> 如果 $S=\\{x:0 \\leq x \\leq 5\\}$，那么就表示 “晶体管的寿命不超过 $5$ 个小时”\n\n**$E \\cup F$** -> **并集**\n\n**$E \\cap F$** -> **交集**\n\n![image-20180722140112814](image-20180722140112814.png)\n\n##### 2.3 概率论公理\n\n\n\n","source":"_posts/概率论基础教程.md","raw":"---\ntitle: 概率论基础教程\ndate: 2018-07-18 10:45:26\nupdated: 2018-07-25\ntags:\n - 数学\ncategories:\n - 数学\n出版社: 人民邮电出版社\nISBN: 9787115221100\n出版时间: 2010-04-01\ndescription: <!—more—->\nmathjax: true\ntypora-root-url: 概率论基础教程\n---\n\n#### 第一章 组合分析\n\n##### 1.2 计数基本法则\n\n有两个实验，其中实验一有 $m$ 种可能发生的结果，对应于实验一的每一个结果，实验二有 $n$ 中可能发生的结果，则对于这两个实验来说，一共有 $m\\times$$n$ 中可能的结果。\n\n*推广的计数基本法则：*\n\n一共有 $r$ 个实验。第一个实验有 $n_1$ 种可能结果；对应于第一个实验的每一种结果，第二个实验有 $n_2$ 种可能的结果；对应于头两个实验的每一种实验结果，第三个实验有 $n_3$ 种可能的结果；等等。那么，这 $r$ 个实验一共有 $n_1,n_2,\\cdots,n_n$ 种可能结果。\n\n> 例：车牌号是7位的，如果要求前3个位置必须是字母，后4个必须是数字，一共有多少种编排车牌号的方式？\n>\n> ​\t26$\\times$26$\\times$26$\\times$10$\\times$10$\\times$10$\\times$10$=$17576000\n\n##### 1.3 排列\n\n按随意顺序来排列字母 a,b,c，一共有多少种排列方式？通过推广的计数基本法则得到：在排列中的第一个位置可供选择的元素有 3 个，第二个位置是剩下的两个，第三个位置只能选择剩下的一个元素，因此一共有 3\\*2\\*1=6 种可能的排列。\n\n假设有 n 个元素，那么用上述类似的方法，可知一共有 `n(n-1)(n-2)=n!` 种不同的排列方式。\n\n> 例：一个垒球队共有 9 名队员，问一共有多少种击球顺序？\n>\n> ​\t9! = 362880\n>\n> 例：把10本书放到书架上，其中4本数学书、3本化学书、2本历史书和1本语文书。现在要求相同类别的书必须紧挨着放，问一共有多少种放法？\n>\n> ​\t如果数学书放在最前面，接下来放化学书，再下来放历史书，最后放语文书，那么一共有 `4!3!2!1!` 种排列方式。而这4种书的顺序又是 `4!` ，因此，答案应该是 `4!4!3!2!1!=6912`\n\n接下来讨论如果有 $n$ 个元素，其中有些是不可区分的，这种排列数如何计算？\n\n$n$ 个元素，如果其中 $n_1$ 个元素彼此不可区分，另 $n_2$ 个彼此不可区分，$n_r$ 个彼此不可区分，那么一共有 $\\frac {n!}{n_1!n_2!...n_r!} $ 中排列方式。\n\n> 例：一个棋类比赛一共有 10 个选手，其中 4 个来自俄罗斯，3个来自美国，2个来自英国，另一个来自巴西。如果比赛结果只记录选手的国籍，那么一共有多少种可能？\n>\n> ​        $\\frac{10!}{4!3!2!1!}  = 12600$\n\n##### 1.4 组合\n\n从 $n$ 个元素中取 $r$ 个，一共有多少种取法？比如，从A,B,C,D,E这5个元素中选取3个组成一组，一共有多少种取法？解答如下：取第一个有5种取法，取第二个有4中取法，取第三个有3种取法，所以，如果考虑顺序的话，那么一共有5\\*4\\*3种取法。但是，每一个包含3个元素的组都被计算了6此（ABC,ACB,BAC,BCA,CAB,CBA)。所以，如果考虑顺序的话组成方法数为：$\\frac{5\\times4\\times3}{3\\times2\\times1}=10$，定义$\\binom{r}{n}$如下：$\\binom{r}{n}=\\frac{n!}{(n-r)!r!}$ 并且说 $\\binom{r}{n}$ 表示了从 n 个元素中一次取 r 个可能组合数。\n\n> 例：从 20 人中选择 3 人组成委员会，一共有多少种取法？\n>\n> 一共有 $\\binom{20}{3}=\\frac{20\\times19\\times18}{3\\times2\\times1}=1140$种\n>\n> 例：有 12 人组成的团体，其中 5 位女士，7位男士，现从中选取2位女士，3位男士组成委员会，问有多少种取法？\n>\n> 有 $\\binom{5}{2}$种方式选取女士，有$\\binom{7}{2}$中方式选取男士。根据基本计数法则一共有$\\binom{5}{2}\\binom{7}{2}=\\frac{5\\times4}{2\\times1}\\times\\frac{7\\times6\\times5}{3\\times2\\times1}=350$种方式选取2位女士3位男士。\n>\n> 例：如果其中有2位男士之间有矛盾，并且坚决拒绝一起工作，那么又有多少种取法？\n>\n> 有$\\binom{2}{2}\\binom{5}{1}=5$种可能会同时包含该两位男士，所以一共有35-5种选取方法不同时包含那两位有矛盾的男士；另外，选取女士的方法仍然是$\\binom{5}{2}=10$种，所以一共有 $30\\times10=300$种选取方式。\n\n##### 1.5多项式系数\n\n有 $n$ 个不同的元素，分成 $r$ 组，每组分别有 $n_1,n_2,\\cdots,n_r$ 个元素，其中$\\sum_{i=1}^r n_i=n$，一共有多少种分法？\n\n根据推广的计数基本法则，将 $n$ 个元素分成 $r$ 组的分法总数一共是\n$$\n\\begin{align}\n&\\binom{n}{n_1}\\binom{n-n_1}{n2}\\cdots\\binom{n-n_1-n_2-\\cdots-n_{r-1}}{n_r} \\\\\\\\\n&=\\frac{n!}{(n-n_1)!n_1!}\\times\\frac{(n-n_1)!}{(n-n_1-n_2)!n_2!}\\cdots\\frac{(n-n_1-n_2-\\cdots-n_{r-1})!}{0!n_r!} \\\\\\\\\n&=\\frac{n!}{n_1!n_2! \\cdots n_r!}\n\\end{align}\n$$\n\n> 例： 某城市的警察局有 10 名警察，其中需要 5 名警察在接到巡逻，2 名警察在局里值班，另 3 名留在局里待命。问把 10 名警察分成这样的三组有多少种分法？\n>\n> 一共有 $\\frac{10!}{5!2!3!}=2520$种解法\n>\n> 例：10个小孩要分成A,B两队，每队5人。A队取参加一场比赛，B队取参加另一场比赛，一共有多少种分法？\n>\n> 一共有 $\\frac{10!}{5!5!}=252$种分法。\n\n\n\n#### 第二章 概率论公理化\n\n##### 2.2 样本空间和事件\n\n样本空间是包含了所有可能的结果的集合。\n\n> 若考察新生儿的性别，那么所有可能结果的集合是 $S=\\{g,b\\}$ 就是一个空间样本，其中 $g$ 表示女孩，$b$ 表示男孩。\n>\n> 赛马比赛中一共有7匹马参赛，这7匹马分别标以 1,2,3,4,5,6,7。考察比赛结果，所有可能的比赛结果的集合 $S=\\{(1,2,3,4,5,6,7)的所有7!种排列\\}$就是一个空间样本。比如(2,3,1,6,5,4,7)就表示2号马跑第一，3号马跑第二，接下来是一号码......这是比赛的一种可能结果。\n>\n> 掷两枚硬币，考察哪一面朝上，那么样本空间一共包含如下四种结果： $S=\\{(H,H),(H,T),(T,H),(T,T)\\}$。\n>\n> 掷两枚骰子，考察两枚骰子的点数，那么样本空间包含 $36$ 个结果：$S=\\{(i,j):i,j=1,2,3,4,5,6\\}$\n>\n> 考察一个晶体管的寿命（小时），那么样本空间是所有的非负实数，即 $S=\\{x:0 \\leq x<\\infty\\}$\n\n样本空间的任一自己 $E$ 称为事件(event)，事件是由实验的某些可能结果组成的一个集合。如果实验结果包含在 $E$ 中，那么就称 $E$ 发生了。\n\n> 接上面的例子：\n>\n> 令 $E=\\{g\\}$ ，那么 $E$ 就表示 “婴儿是个女孩” 这个事件；\n>\n> 如果 $E=\\{所有以3开头的排列\\}$，那么 $E$ 就表示 “3号马获得了第一”。\n>\n> 如果 $E=\\{(H,H),(H,T)\\}$，那么 $E$ 就表示 “第一枚硬币正面朝上”。\n>\n> 如果 $E=\\{(1,6),(2,5),(3,4),(4,3),(5,2),(6,1)\\}$，那么 $E$ 就表示 “两个骰子点数之和为 $7$”。\n>\n> 如果 $S=\\{x:0 \\leq x \\leq 5\\}$，那么就表示 “晶体管的寿命不超过 $5$ 个小时”\n\n**$E \\cup F$** -> **并集**\n\n**$E \\cap F$** -> **交集**\n\n![image-20180722140112814](image-20180722140112814.png)\n\n##### 2.3 概率论公理\n\n\n\n","slug":"概率论基础教程","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cjof51pkw000rrgueqcszgmir","content":"<h4 id=\"第一章-组合分析\"><a href=\"#第一章-组合分析\" class=\"headerlink\" title=\"第一章 组合分析\"></a>第一章 组合分析</h4><h5 id=\"1-2-计数基本法则\"><a href=\"#1-2-计数基本法则\" class=\"headerlink\" title=\"1.2 计数基本法则\"></a>1.2 计数基本法则</h5><p>有两个实验，其中实验一有 $m$ 种可能发生的结果，对应于实验一的每一个结果，实验二有 $n$ 中可能发生的结果，则对于这两个实验来说，一共有 $m\\times$$n$ 中可能的结果。</p>\n<p><em>推广的计数基本法则：</em></p>\n<p>一共有 $r$ 个实验。第一个实验有 $n_1$ 种可能结果；对应于第一个实验的每一种结果，第二个实验有 $n_2$ 种可能的结果；对应于头两个实验的每一种实验结果，第三个实验有 $n_3$ 种可能的结果；等等。那么，这 $r$ 个实验一共有 $n_1,n_2,\\cdots,n_n$ 种可能结果。</p>\n<blockquote>\n<p>例：车牌号是7位的，如果要求前3个位置必须是字母，后4个必须是数字，一共有多少种编排车牌号的方式？</p>\n<p>​    26$\\times$26$\\times$26$\\times$10$\\times$10$\\times$10$\\times$10$=$17576000</p>\n</blockquote>\n<h5 id=\"1-3-排列\"><a href=\"#1-3-排列\" class=\"headerlink\" title=\"1.3 排列\"></a>1.3 排列</h5><p>按随意顺序来排列字母 a,b,c，一共有多少种排列方式？通过推广的计数基本法则得到：在排列中的第一个位置可供选择的元素有 3 个，第二个位置是剩下的两个，第三个位置只能选择剩下的一个元素，因此一共有 3*2*1=6 种可能的排列。</p>\n<p>假设有 n 个元素，那么用上述类似的方法，可知一共有 <code>n(n-1)(n-2)=n!</code> 种不同的排列方式。</p>\n<blockquote>\n<p>例：一个垒球队共有 9 名队员，问一共有多少种击球顺序？</p>\n<p>​    9! = 362880</p>\n<p>例：把10本书放到书架上，其中4本数学书、3本化学书、2本历史书和1本语文书。现在要求相同类别的书必须紧挨着放，问一共有多少种放法？</p>\n<p>​    如果数学书放在最前面，接下来放化学书，再下来放历史书，最后放语文书，那么一共有 <code>4!3!2!1!</code> 种排列方式。而这4种书的顺序又是 <code>4!</code> ，因此，答案应该是 <code>4!4!3!2!1!=6912</code></p>\n</blockquote>\n<p>接下来讨论如果有 $n$ 个元素，其中有些是不可区分的，这种排列数如何计算？</p>\n<p>$n$ 个元素，如果其中 $n_1$ 个元素彼此不可区分，另 $n_2$ 个彼此不可区分，$n_r$ 个彼此不可区分，那么一共有 $\\frac {n!}{n_1!n_2!…n_r!} $ 中排列方式。</p>\n<blockquote>\n<p>例：一个棋类比赛一共有 10 个选手，其中 4 个来自俄罗斯，3个来自美国，2个来自英国，另一个来自巴西。如果比赛结果只记录选手的国籍，那么一共有多少种可能？</p>\n<p>​        $\\frac{10!}{4!3!2!1!}  = 12600$</p>\n</blockquote>\n<h5 id=\"1-4-组合\"><a href=\"#1-4-组合\" class=\"headerlink\" title=\"1.4 组合\"></a>1.4 组合</h5><p>从 $n$ 个元素中取 $r$ 个，一共有多少种取法？比如，从A,B,C,D,E这5个元素中选取3个组成一组，一共有多少种取法？解答如下：取第一个有5种取法，取第二个有4中取法，取第三个有3种取法，所以，如果考虑顺序的话，那么一共有5*4*3种取法。但是，每一个包含3个元素的组都被计算了6此（ABC,ACB,BAC,BCA,CAB,CBA)。所以，如果考虑顺序的话组成方法数为：$\\frac{5\\times4\\times3}{3\\times2\\times1}=10$，定义$\\binom{r}{n}$如下：$\\binom{r}{n}=\\frac{n!}{(n-r)!r!}$ 并且说 $\\binom{r}{n}$ 表示了从 n 个元素中一次取 r 个可能组合数。</p>\n<blockquote>\n<p>例：从 20 人中选择 3 人组成委员会，一共有多少种取法？</p>\n<p>一共有 $\\binom{20}{3}=\\frac{20\\times19\\times18}{3\\times2\\times1}=1140$种</p>\n<p>例：有 12 人组成的团体，其中 5 位女士，7位男士，现从中选取2位女士，3位男士组成委员会，问有多少种取法？</p>\n<p>有 $\\binom{5}{2}$种方式选取女士，有$\\binom{7}{2}$中方式选取男士。根据基本计数法则一共有$\\binom{5}{2}\\binom{7}{2}=\\frac{5\\times4}{2\\times1}\\times\\frac{7\\times6\\times5}{3\\times2\\times1}=350$种方式选取2位女士3位男士。</p>\n<p>例：如果其中有2位男士之间有矛盾，并且坚决拒绝一起工作，那么又有多少种取法？</p>\n<p>有$\\binom{2}{2}\\binom{5}{1}=5$种可能会同时包含该两位男士，所以一共有35-5种选取方法不同时包含那两位有矛盾的男士；另外，选取女士的方法仍然是$\\binom{5}{2}=10$种，所以一共有 $30\\times10=300$种选取方式。</p>\n</blockquote>\n<h5 id=\"1-5多项式系数\"><a href=\"#1-5多项式系数\" class=\"headerlink\" title=\"1.5多项式系数\"></a>1.5多项式系数</h5><p>有 $n$ 个不同的元素，分成 $r$ 组，每组分别有 $n_1,n_2,\\cdots,n_r$ 个元素，其中$\\sum_{i=1}^r n_i=n$，一共有多少种分法？</p>\n<p>根据推广的计数基本法则，将 $n$ 个元素分成 $r$ 组的分法总数一共是<br>$$<br>\\begin{align}<br>&amp;\\binom{n}{n_1}\\binom{n-n_1}{n2}\\cdots\\binom{n-n_1-n_2-\\cdots-n_{r-1}}{n_r} \\\\<br>&amp;=\\frac{n!}{(n-n_1)!n_1!}\\times\\frac{(n-n_1)!}{(n-n_1-n_2)!n_2!}\\cdots\\frac{(n-n_1-n_2-\\cdots-n_{r-1})!}{0!n_r!} \\\\<br>&amp;=\\frac{n!}{n_1!n_2! \\cdots n_r!}<br>\\end{align}<br>$$</p>\n<blockquote>\n<p>例： 某城市的警察局有 10 名警察，其中需要 5 名警察在接到巡逻，2 名警察在局里值班，另 3 名留在局里待命。问把 10 名警察分成这样的三组有多少种分法？</p>\n<p>一共有 $\\frac{10!}{5!2!3!}=2520$种解法</p>\n<p>例：10个小孩要分成A,B两队，每队5人。A队取参加一场比赛，B队取参加另一场比赛，一共有多少种分法？</p>\n<p>一共有 $\\frac{10!}{5!5!}=252$种分法。</p>\n</blockquote>\n<h4 id=\"第二章-概率论公理化\"><a href=\"#第二章-概率论公理化\" class=\"headerlink\" title=\"第二章 概率论公理化\"></a>第二章 概率论公理化</h4><h5 id=\"2-2-样本空间和事件\"><a href=\"#2-2-样本空间和事件\" class=\"headerlink\" title=\"2.2 样本空间和事件\"></a>2.2 样本空间和事件</h5><p>样本空间是包含了所有可能的结果的集合。</p>\n<blockquote>\n<p>若考察新生儿的性别，那么所有可能结果的集合是 $S={g,b}$ 就是一个空间样本，其中 $g$ 表示女孩，$b$ 表示男孩。</p>\n<p>赛马比赛中一共有7匹马参赛，这7匹马分别标以 1,2,3,4,5,6,7。考察比赛结果，所有可能的比赛结果的集合 $S={(1,2,3,4,5,6,7)的所有7!种排列}$就是一个空间样本。比如(2,3,1,6,5,4,7)就表示2号马跑第一，3号马跑第二，接下来是一号码……这是比赛的一种可能结果。</p>\n<p>掷两枚硬币，考察哪一面朝上，那么样本空间一共包含如下四种结果： $S={(H,H),(H,T),(T,H),(T,T)}$。</p>\n<p>掷两枚骰子，考察两枚骰子的点数，那么样本空间包含 $36$ 个结果：$S={(i,j):i,j=1,2,3,4,5,6}$</p>\n<p>考察一个晶体管的寿命（小时），那么样本空间是所有的非负实数，即 $S={x:0 \\leq x&lt;\\infty}$</p>\n</blockquote>\n<p>样本空间的任一自己 $E$ 称为事件(event)，事件是由实验的某些可能结果组成的一个集合。如果实验结果包含在 $E$ 中，那么就称 $E$ 发生了。</p>\n<blockquote>\n<p>接上面的例子：</p>\n<p>令 $E={g}$ ，那么 $E$ 就表示 “婴儿是个女孩” 这个事件；</p>\n<p>如果 $E={所有以3开头的排列}$，那么 $E$ 就表示 “3号马获得了第一”。</p>\n<p>如果 $E={(H,H),(H,T)}$，那么 $E$ 就表示 “第一枚硬币正面朝上”。</p>\n<p>如果 $E={(1,6),(2,5),(3,4),(4,3),(5,2),(6,1)}$，那么 $E$ 就表示 “两个骰子点数之和为 $7$”。</p>\n<p>如果 $S={x:0 \\leq x \\leq 5}$，那么就表示 “晶体管的寿命不超过 $5$ 个小时”</p>\n</blockquote>\n<p><strong>$E \\cup F$</strong> -&gt; <strong>并集</strong></p>\n<p><strong>$E \\cap F$</strong> -&gt; <strong>交集</strong></p>\n<p><img src=\"image-20180722140112814.png\" alt=\"image-20180722140112814\"></p>\n<h5 id=\"2-3-概率论公理\"><a href=\"#2-3-概率论公理\" class=\"headerlink\" title=\"2.3 概率论公理\"></a>2.3 概率论公理</h5>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"第一章-组合分析\"><a href=\"#第一章-组合分析\" class=\"headerlink\" title=\"第一章 组合分析\"></a>第一章 组合分析</h4><h5 id=\"1-2-计数基本法则\"><a href=\"#1-2-计数基本法则\" class=\"headerlink\" title=\"1.2 计数基本法则\"></a>1.2 计数基本法则</h5><p>有两个实验，其中实验一有 $m$ 种可能发生的结果，对应于实验一的每一个结果，实验二有 $n$ 中可能发生的结果，则对于这两个实验来说，一共有 $m\\times$$n$ 中可能的结果。</p>\n<p><em>推广的计数基本法则：</em></p>\n<p>一共有 $r$ 个实验。第一个实验有 $n_1$ 种可能结果；对应于第一个实验的每一种结果，第二个实验有 $n_2$ 种可能的结果；对应于头两个实验的每一种实验结果，第三个实验有 $n_3$ 种可能的结果；等等。那么，这 $r$ 个实验一共有 $n_1,n_2,\\cdots,n_n$ 种可能结果。</p>\n<blockquote>\n<p>例：车牌号是7位的，如果要求前3个位置必须是字母，后4个必须是数字，一共有多少种编排车牌号的方式？</p>\n<p>​    26$\\times$26$\\times$26$\\times$10$\\times$10$\\times$10$\\times$10$=$17576000</p>\n</blockquote>\n<h5 id=\"1-3-排列\"><a href=\"#1-3-排列\" class=\"headerlink\" title=\"1.3 排列\"></a>1.3 排列</h5><p>按随意顺序来排列字母 a,b,c，一共有多少种排列方式？通过推广的计数基本法则得到：在排列中的第一个位置可供选择的元素有 3 个，第二个位置是剩下的两个，第三个位置只能选择剩下的一个元素，因此一共有 3*2*1=6 种可能的排列。</p>\n<p>假设有 n 个元素，那么用上述类似的方法，可知一共有 <code>n(n-1)(n-2)=n!</code> 种不同的排列方式。</p>\n<blockquote>\n<p>例：一个垒球队共有 9 名队员，问一共有多少种击球顺序？</p>\n<p>​    9! = 362880</p>\n<p>例：把10本书放到书架上，其中4本数学书、3本化学书、2本历史书和1本语文书。现在要求相同类别的书必须紧挨着放，问一共有多少种放法？</p>\n<p>​    如果数学书放在最前面，接下来放化学书，再下来放历史书，最后放语文书，那么一共有 <code>4!3!2!1!</code> 种排列方式。而这4种书的顺序又是 <code>4!</code> ，因此，答案应该是 <code>4!4!3!2!1!=6912</code></p>\n</blockquote>\n<p>接下来讨论如果有 $n$ 个元素，其中有些是不可区分的，这种排列数如何计算？</p>\n<p>$n$ 个元素，如果其中 $n_1$ 个元素彼此不可区分，另 $n_2$ 个彼此不可区分，$n_r$ 个彼此不可区分，那么一共有 $\\frac {n!}{n_1!n_2!…n_r!} $ 中排列方式。</p>\n<blockquote>\n<p>例：一个棋类比赛一共有 10 个选手，其中 4 个来自俄罗斯，3个来自美国，2个来自英国，另一个来自巴西。如果比赛结果只记录选手的国籍，那么一共有多少种可能？</p>\n<p>​        $\\frac{10!}{4!3!2!1!}  = 12600$</p>\n</blockquote>\n<h5 id=\"1-4-组合\"><a href=\"#1-4-组合\" class=\"headerlink\" title=\"1.4 组合\"></a>1.4 组合</h5><p>从 $n$ 个元素中取 $r$ 个，一共有多少种取法？比如，从A,B,C,D,E这5个元素中选取3个组成一组，一共有多少种取法？解答如下：取第一个有5种取法，取第二个有4中取法，取第三个有3种取法，所以，如果考虑顺序的话，那么一共有5*4*3种取法。但是，每一个包含3个元素的组都被计算了6此（ABC,ACB,BAC,BCA,CAB,CBA)。所以，如果考虑顺序的话组成方法数为：$\\frac{5\\times4\\times3}{3\\times2\\times1}=10$，定义$\\binom{r}{n}$如下：$\\binom{r}{n}=\\frac{n!}{(n-r)!r!}$ 并且说 $\\binom{r}{n}$ 表示了从 n 个元素中一次取 r 个可能组合数。</p>\n<blockquote>\n<p>例：从 20 人中选择 3 人组成委员会，一共有多少种取法？</p>\n<p>一共有 $\\binom{20}{3}=\\frac{20\\times19\\times18}{3\\times2\\times1}=1140$种</p>\n<p>例：有 12 人组成的团体，其中 5 位女士，7位男士，现从中选取2位女士，3位男士组成委员会，问有多少种取法？</p>\n<p>有 $\\binom{5}{2}$种方式选取女士，有$\\binom{7}{2}$中方式选取男士。根据基本计数法则一共有$\\binom{5}{2}\\binom{7}{2}=\\frac{5\\times4}{2\\times1}\\times\\frac{7\\times6\\times5}{3\\times2\\times1}=350$种方式选取2位女士3位男士。</p>\n<p>例：如果其中有2位男士之间有矛盾，并且坚决拒绝一起工作，那么又有多少种取法？</p>\n<p>有$\\binom{2}{2}\\binom{5}{1}=5$种可能会同时包含该两位男士，所以一共有35-5种选取方法不同时包含那两位有矛盾的男士；另外，选取女士的方法仍然是$\\binom{5}{2}=10$种，所以一共有 $30\\times10=300$种选取方式。</p>\n</blockquote>\n<h5 id=\"1-5多项式系数\"><a href=\"#1-5多项式系数\" class=\"headerlink\" title=\"1.5多项式系数\"></a>1.5多项式系数</h5><p>有 $n$ 个不同的元素，分成 $r$ 组，每组分别有 $n_1,n_2,\\cdots,n_r$ 个元素，其中$\\sum_{i=1}^r n_i=n$，一共有多少种分法？</p>\n<p>根据推广的计数基本法则，将 $n$ 个元素分成 $r$ 组的分法总数一共是<br>$$<br>\\begin{align}<br>&amp;\\binom{n}{n_1}\\binom{n-n_1}{n2}\\cdots\\binom{n-n_1-n_2-\\cdots-n_{r-1}}{n_r} \\\\<br>&amp;=\\frac{n!}{(n-n_1)!n_1!}\\times\\frac{(n-n_1)!}{(n-n_1-n_2)!n_2!}\\cdots\\frac{(n-n_1-n_2-\\cdots-n_{r-1})!}{0!n_r!} \\\\<br>&amp;=\\frac{n!}{n_1!n_2! \\cdots n_r!}<br>\\end{align}<br>$$</p>\n<blockquote>\n<p>例： 某城市的警察局有 10 名警察，其中需要 5 名警察在接到巡逻，2 名警察在局里值班，另 3 名留在局里待命。问把 10 名警察分成这样的三组有多少种分法？</p>\n<p>一共有 $\\frac{10!}{5!2!3!}=2520$种解法</p>\n<p>例：10个小孩要分成A,B两队，每队5人。A队取参加一场比赛，B队取参加另一场比赛，一共有多少种分法？</p>\n<p>一共有 $\\frac{10!}{5!5!}=252$种分法。</p>\n</blockquote>\n<h4 id=\"第二章-概率论公理化\"><a href=\"#第二章-概率论公理化\" class=\"headerlink\" title=\"第二章 概率论公理化\"></a>第二章 概率论公理化</h4><h5 id=\"2-2-样本空间和事件\"><a href=\"#2-2-样本空间和事件\" class=\"headerlink\" title=\"2.2 样本空间和事件\"></a>2.2 样本空间和事件</h5><p>样本空间是包含了所有可能的结果的集合。</p>\n<blockquote>\n<p>若考察新生儿的性别，那么所有可能结果的集合是 $S={g,b}$ 就是一个空间样本，其中 $g$ 表示女孩，$b$ 表示男孩。</p>\n<p>赛马比赛中一共有7匹马参赛，这7匹马分别标以 1,2,3,4,5,6,7。考察比赛结果，所有可能的比赛结果的集合 $S={(1,2,3,4,5,6,7)的所有7!种排列}$就是一个空间样本。比如(2,3,1,6,5,4,7)就表示2号马跑第一，3号马跑第二，接下来是一号码……这是比赛的一种可能结果。</p>\n<p>掷两枚硬币，考察哪一面朝上，那么样本空间一共包含如下四种结果： $S={(H,H),(H,T),(T,H),(T,T)}$。</p>\n<p>掷两枚骰子，考察两枚骰子的点数，那么样本空间包含 $36$ 个结果：$S={(i,j):i,j=1,2,3,4,5,6}$</p>\n<p>考察一个晶体管的寿命（小时），那么样本空间是所有的非负实数，即 $S={x:0 \\leq x&lt;\\infty}$</p>\n</blockquote>\n<p>样本空间的任一自己 $E$ 称为事件(event)，事件是由实验的某些可能结果组成的一个集合。如果实验结果包含在 $E$ 中，那么就称 $E$ 发生了。</p>\n<blockquote>\n<p>接上面的例子：</p>\n<p>令 $E={g}$ ，那么 $E$ 就表示 “婴儿是个女孩” 这个事件；</p>\n<p>如果 $E={所有以3开头的排列}$，那么 $E$ 就表示 “3号马获得了第一”。</p>\n<p>如果 $E={(H,H),(H,T)}$，那么 $E$ 就表示 “第一枚硬币正面朝上”。</p>\n<p>如果 $E={(1,6),(2,5),(3,4),(4,3),(5,2),(6,1)}$，那么 $E$ 就表示 “两个骰子点数之和为 $7$”。</p>\n<p>如果 $S={x:0 \\leq x \\leq 5}$，那么就表示 “晶体管的寿命不超过 $5$ 个小时”</p>\n</blockquote>\n<p><strong>$E \\cup F$</strong> -&gt; <strong>并集</strong></p>\n<p><strong>$E \\cap F$</strong> -&gt; <strong>交集</strong></p>\n<p><img src=\"image-20180722140112814.png\" alt=\"image-20180722140112814\"></p>\n<h5 id=\"2-3-概率论公理\"><a href=\"#2-3-概率论公理\" class=\"headerlink\" title=\"2.3 概率论公理\"></a>2.3 概率论公理</h5>"}],"PostAsset":[{"_id":"source/_posts/machine-learning-for-trading/1534238787357.png","slug":"1534238787357.png","post":"cjof51pja0000rgueytd1x2ru","modified":1,"renderable":0},{"_id":"source/_posts/pythoncore/pythoncore.png","slug":"pythoncore.png","post":"cjof51pju0007rgue4mz3f04j","modified":1,"renderable":0},{"_id":"source/_posts/rljs/rljs.png","slug":"rljs.png","post":"cjof51pjx0008rgueyozx92q4","modified":1,"renderable":0},{"_id":"source/_posts/machine-learning-for-trading/1533869822902.png","slug":"1533869822902.png","post":"cjof51pja0000rgueytd1x2ru","modified":1,"renderable":0},{"_id":"source/_posts/machine-learning-for-trading/1536045019373.png","slug":"1536045019373.png","post":"cjof51pja0000rgueytd1x2ru","modified":1,"renderable":0},{"_id":"source/_posts/rljs/timg.jpg","slug":"timg.jpg","post":"cjof51pjx0008rgueyozx92q4","modified":1,"renderable":0},{"_id":"source/_posts/website/website.png","slug":"website.png","post":"cjof51pk1000brguecpokmzws","modified":1,"renderable":0},{"_id":"source/_posts/概率论基础教程/image-20180722140112814.png","slug":"image-20180722140112814.png","post":"cjof51pkw000rrgueqcszgmir","modified":1,"renderable":0},{"_id":"source/_posts/minjiekaifa/minjiekaifa.png","slug":"minjiekaifa.png","post":"cjof51pjh0002rguexv73xx9s","modified":1,"renderable":0},{"_id":"source/_posts/wuhezhizhong/wuhezhizhong.png","slug":"wuhezhizhong.png","post":"cjof51pk6000frgueaf6t66l5","modified":1,"renderable":0},{"_id":"source/_posts/机器学习开放课程：五、Bagging与随机森林/credit_scoring_sample.csv","slug":"credit_scoring_sample.csv","post":"cjof51pke000grgue45hf4ov1","modified":1,"renderable":0},{"_id":"source/_posts/机器学习开放课程：四、线性分类与线性回归/TIM20181031095548.png","post":"cjof51pkr000krguedgqkh3gs","slug":"TIM20181031095548.png","modified":1,"renderable":1},{"_id":"source/_posts/机器学习开放课程：四、线性分类与线性回归/TIM20181031100050.png","post":"cjof51pkr000krguedgqkh3gs","slug":"TIM20181031100050.png","modified":1,"renderable":1},{"_id":"source/_posts/概率论基础教程/image-20180722135552842.png","post":"cjof51pkw000rrgueqcszgmir","slug":"image-20180722135552842.png","modified":1,"renderable":1},{"_id":"source/_posts/minjiekaifa/498627-20160828231647539-1014399922.png","post":"cjof51pjh0002rguexv73xx9s","slug":"498627-20160828231647539-1014399922.png","modified":1,"renderable":1},{"_id":"source/_posts/minjiekaifa/498627-20160828231739089-846443922.png","post":"cjof51pjh0002rguexv73xx9s","slug":"498627-20160828231739089-846443922.png","modified":1,"renderable":1},{"_id":"source/_posts/机器学习开放课程：三、分类、决策树和K近邻/3VT+hGyI.png","post":"cjof51pk3000crgueiz9o2yem","slug":"3VT+hGyI.png","modified":1,"renderable":1},{"_id":"source/_posts/机器学习开放课程：三、分类、决策树和K近邻/NZXca6g.png","post":"cjof51pk3000crgueiz9o2yem","slug":"NZXca6g.png","modified":1,"renderable":1},{"_id":"source/_posts/机器学习开放课程：三、分类、决策树和K近邻/mlbootcamp5_train.csv","slug":"mlbootcamp5_train.csv","post":"cjof51pk3000crgueiz9o2yem","modified":1,"renderable":0},{"_id":"source/_posts/机器学习开放课程：三、分类、决策树和K近邻/tmp_w3pmy_5.png","post":"cjof51pk3000crgueiz9o2yem","slug":"tmp_w3pmy_5.png","modified":1,"renderable":1},{"_id":"source/_posts/机器学习开放课程：六、特征工程和特征选取/1542006955920.png","post":"cjof51pki000jrguexvpf29ye","slug":"1542006955920.png","modified":1,"renderable":1},{"_id":"source/_posts/机器学习开放课程：六、特征工程和特征选取/1542007030968.png","post":"cjof51pki000jrguexvpf29ye","slug":"1542007030968.png","modified":1,"renderable":1},{"_id":"source/_posts/机器学习开放课程：六、特征工程和特征选取/314px-Max_pooling.png","post":"cjof51pki000jrguexvpf29ye","slug":"314px-Max_pooling.png","modified":1,"renderable":1},{"_id":"source/_posts/机器学习开放课程：六、特征工程和特征选取/信息检索导论.pdf","slug":"信息检索导论.pdf","post":"cjof51pki000jrguexvpf29ye","modified":1,"renderable":0},{"_id":"source/_posts/python_for_finance/1533087934260.png","post":"cjof51pjr0006rguerpqip4yn","slug":"1533087934260.png","modified":1,"renderable":1},{"_id":"source/_posts/python_for_finance/1533087972105.png","post":"cjof51pjr0006rguerpqip4yn","slug":"1533087972105.png","modified":1,"renderable":1},{"_id":"source/_posts/python_for_finance/1533088423103.png","post":"cjof51pjr0006rguerpqip4yn","slug":"1533088423103.png","modified":1,"renderable":1},{"_id":"source/_posts/python_for_finance/1533088473653.png","post":"cjof51pjr0006rguerpqip4yn","slug":"1533088473653.png","modified":1,"renderable":1},{"_id":"source/_posts/python_for_finance/1533088496598.png","post":"cjof51pjr0006rguerpqip4yn","slug":"1533088496598.png","modified":1,"renderable":1},{"_id":"source/_posts/machine-learning-for-trading/1531304006175.png","post":"cjof51pja0000rgueytd1x2ru","slug":"1531304006175.png","modified":1,"renderable":1},{"_id":"source/_posts/machine-learning-for-trading/1531383436936.png","post":"cjof51pja0000rgueytd1x2ru","slug":"1531383436936.png","modified":1,"renderable":1},{"_id":"source/_posts/machine-learning-for-trading/1531384011994.png","post":"cjof51pja0000rgueytd1x2ru","slug":"1531384011994.png","modified":1,"renderable":1},{"_id":"source/_posts/machine-learning-for-trading/1531465284221.png","post":"cjof51pja0000rgueytd1x2ru","slug":"1531465284221.png","modified":1,"renderable":1},{"_id":"source/_posts/machine-learning-for-trading/1531632440578.png","post":"cjof51pja0000rgueytd1x2ru","slug":"1531632440578.png","modified":1,"renderable":1},{"_id":"source/_posts/machine-learning-for-trading/1531634310060.png","post":"cjof51pja0000rgueytd1x2ru","slug":"1531634310060.png","modified":1,"renderable":1},{"_id":"source/_posts/machine-learning-for-trading/1531635134977.png","post":"cjof51pja0000rgueytd1x2ru","slug":"1531635134977.png","modified":1,"renderable":1},{"_id":"source/_posts/machine-learning-for-trading/1532508260900.png","post":"cjof51pja0000rgueytd1x2ru","slug":"1532508260900.png","modified":1,"renderable":1},{"_id":"source/_posts/machine-learning-for-trading/1532508276951.png","post":"cjof51pja0000rgueytd1x2ru","slug":"1532508276951.png","modified":1,"renderable":1},{"_id":"source/_posts/machine-learning-for-trading/1532570705884.png","post":"cjof51pja0000rgueytd1x2ru","slug":"1532570705884.png","modified":1,"renderable":1},{"_id":"source/_posts/machine-learning-for-trading/1532570720355.png","post":"cjof51pja0000rgueytd1x2ru","slug":"1532570720355.png","modified":1,"renderable":1},{"_id":"source/_posts/machine-learning-for-trading/1532571574686.png","post":"cjof51pja0000rgueytd1x2ru","slug":"1532571574686.png","modified":1,"renderable":1},{"_id":"source/_posts/machine-learning-for-trading/1532659982849.png","post":"cjof51pja0000rgueytd1x2ru","slug":"1532659982849.png","modified":1,"renderable":1},{"_id":"source/_posts/machine-learning-for-trading/1532660052844.png","post":"cjof51pja0000rgueytd1x2ru","slug":"1532660052844.png","modified":1,"renderable":1},{"_id":"source/_posts/machine-learning-for-trading/1532675498707.png","post":"cjof51pja0000rgueytd1x2ru","slug":"1532675498707.png","modified":1,"renderable":1},{"_id":"source/_posts/machine-learning-for-trading/1532677809156.png","post":"cjof51pja0000rgueytd1x2ru","slug":"1532677809156.png","modified":1,"renderable":1},{"_id":"source/_posts/machine-learning-for-trading/1532677939302.png","post":"cjof51pja0000rgueytd1x2ru","slug":"1532677939302.png","modified":1,"renderable":1},{"_id":"source/_posts/machine-learning-for-trading/1532678552063.png","post":"cjof51pja0000rgueytd1x2ru","slug":"1532678552063.png","modified":1,"renderable":1},{"_id":"source/_posts/machine-learning-for-trading/1533883259793.png","slug":"1533883259793.png","post":"cjof51pja0000rgueytd1x2ru","modified":1,"renderable":0},{"_id":"source/_posts/machine-learning-for-trading/1533883675299.png","slug":"1533883675299.png","post":"cjof51pja0000rgueytd1x2ru","modified":1,"renderable":0},{"_id":"source/_posts/machine-learning-for-trading/1533886709495.png","slug":"1533886709495.png","post":"cjof51pja0000rgueytd1x2ru","modified":1,"renderable":0},{"_id":"source/_posts/machine-learning-for-trading/1533890419564.png","slug":"1533890419564.png","post":"cjof51pja0000rgueytd1x2ru","modified":1,"renderable":0},{"_id":"source/_posts/machine-learning-for-trading/1535439244770.png","slug":"1535439244770.png","post":"cjof51pja0000rgueytd1x2ru","modified":1,"renderable":0},{"_id":"source/_posts/machine-learning-for-trading/image-20180811213410404.png","post":"cjof51pja0000rgueytd1x2ru","slug":"image-20180811213410404.png","modified":1,"renderable":1}],"PostCategory":[{"post_id":"cjof51pju0007rgue4mz3f04j","category_id":"cjof51pjo0004rgue255kmxn1","_id":"cjof51pks000mrgue7m4oh41q"},{"post_id":"cjof51pju0007rgue4mz3f04j","category_id":"cjof51pk5000drgue5mw9qc58","_id":"cjof51pkw000prgueobhfqu69"},{"post_id":"cjof51pjx0008rgueyozx92q4","category_id":"cjof51pks000lrgueg8jzb780","_id":"cjof51pl0000xrgueqbmz8vjq"},{"post_id":"cjof51pk6000frgueaf6t66l5","category_id":"cjof51pks000lrgueg8jzb780","_id":"cjof51pl70017rgueol438upo"},{"post_id":"cjof51pke000grgue45hf4ov1","category_id":"cjof51pjo0004rgue255kmxn1","_id":"cjof51pl9001brgueyqdcanc1"},{"post_id":"cjof51pke000grgue45hf4ov1","category_id":"cjof51pk5000drgue5mw9qc58","_id":"cjof51pla001drgueylymhyvd"},{"post_id":"cjof51pke000grgue45hf4ov1","category_id":"cjof51pl40013rguee9aotn9b","_id":"cjof51plb001erguexod38w6u"},{"post_id":"cjof51pki000jrguexvpf29ye","category_id":"cjof51pjo0004rgue255kmxn1","_id":"cjof51plc001hrgueltjynpws"},{"post_id":"cjof51pki000jrguexvpf29ye","category_id":"cjof51pk5000drgue5mw9qc58","_id":"cjof51plc001jrgue4qaex8e5"},{"post_id":"cjof51pki000jrguexvpf29ye","category_id":"cjof51pl40013rguee9aotn9b","_id":"cjof51pld001nrguen04uz47b"},{"post_id":"cjof51pkr000krguedgqkh3gs","category_id":"cjof51pjo0004rgue255kmxn1","_id":"cjof51ple001qrgue9n3uzw6v"},{"post_id":"cjof51pkr000krguedgqkh3gs","category_id":"cjof51pk5000drgue5mw9qc58","_id":"cjof51plf001trgue9cm4dawn"},{"post_id":"cjof51pkr000krguedgqkh3gs","category_id":"cjof51pl40013rguee9aotn9b","_id":"cjof51plf001vrgue5ur6v9tb"},{"post_id":"cjof51pkt000orgueyliu9m0j","category_id":"cjof51pjo0004rgue255kmxn1","_id":"cjof51plh001yrgueif5inm2j"},{"post_id":"cjof51pkt000orgueyliu9m0j","category_id":"cjof51pk5000drgue5mw9qc58","_id":"cjof51plh0020rgueln6rhw45"},{"post_id":"cjof51pkt000orgueyliu9m0j","category_id":"cjof51pl40013rguee9aotn9b","_id":"cjof51pli0022rgue1sgcbaiz"},{"post_id":"cjof51pkw000rrgueqcszgmir","category_id":"cjof51ple001prgueptuwmxvo","_id":"cjof51plj0024rgue7dtlu9uk"},{"post_id":"cjof51pk3000crgueiz9o2yem","category_id":"cjof51pjo0004rgue255kmxn1","_id":"cjof51pll0027rguehvttnz6r"},{"post_id":"cjof51pk3000crgueiz9o2yem","category_id":"cjof51pk5000drgue5mw9qc58","_id":"cjof51plm002argueviall4vh"},{"post_id":"cjof51pk3000crgueiz9o2yem","category_id":"cjof51pl40013rguee9aotn9b","_id":"cjof51plo002drguefpkhf3he"},{"post_id":"cjof51pja0000rgueytd1x2ru","category_id":"cjof51pjo0004rgue255kmxn1","_id":"cjof51plo002frgue51lzsxxa"},{"post_id":"cjof51pja0000rgueytd1x2ru","category_id":"cjof51pk5000drgue5mw9qc58","_id":"cjof51plp002irguefayl4bs2"},{"post_id":"cjof51pja0000rgueytd1x2ru","category_id":"cjof51pl9001arguexmk5ctax","_id":"cjof51plp002jrgue4h5gvp3p"},{"post_id":"cjof51pja0000rgueytd1x2ru","category_id":"cjof51plj0025rgue1bs6w71d","_id":"cjof51plq002krguep04w51n0"},{"post_id":"cjof51pjr0006rguerpqip4yn","category_id":"cjof51pjo0004rgue255kmxn1","_id":"cjof51plq002mrgueh3ir7mlt"},{"post_id":"cjof51pjr0006rguerpqip4yn","category_id":"cjof51pk5000drgue5mw9qc58","_id":"cjof51plq002nrgue1ileuy6m"},{"post_id":"cjof51pjr0006rguerpqip4yn","category_id":"cjof51pl9001arguexmk5ctax","_id":"cjof51plr002prguerq858n3a"},{"post_id":"cjof51pjr0006rguerpqip4yn","category_id":"cjof51plj0025rgue1bs6w71d","_id":"cjof51pls002rrguecon35v5f"}],"PostTag":[{"post_id":"cjof51pja0000rgueytd1x2ru","tag_id":"cjof51pjq0005rgue0lyz34qz","_id":"cjof51pkw000qrgue300sl1kc"},{"post_id":"cjof51pja0000rgueytd1x2ru","tag_id":"cjof51pjy000arguetnmqqj4h","_id":"cjof51pky000trguewbtx4mx9"},{"post_id":"cjof51pja0000rgueytd1x2ru","tag_id":"cjof51pk6000erguef56xjnrl","_id":"cjof51pkz000vrguevx62zwj9"},{"post_id":"cjof51pja0000rgueytd1x2ru","tag_id":"cjof51pki000irguem6q95wvg","_id":"cjof51pl0000yrgue4cq0fz94"},{"post_id":"cjof51pjh0002rguexv73xx9s","tag_id":"cjof51pkt000nrgueb5zc9am1","_id":"cjof51pl40012rgue0dytr97e"},{"post_id":"cjof51pjh0002rguexv73xx9s","tag_id":"cjof51pkz000urgueo5hwsuxa","_id":"cjof51pl50014rguec7om3wyl"},{"post_id":"cjof51pjh0002rguexv73xx9s","tag_id":"cjof51pl1000zrgueb2w26gd6","_id":"cjof51pl70016rgue9ltanqrw"},{"post_id":"cjof51pjr0006rguerpqip4yn","tag_id":"cjof51pjq0005rgue0lyz34qz","_id":"cjof51plc001irgueyzzk9iw3"},{"post_id":"cjof51pjr0006rguerpqip4yn","tag_id":"cjof51pjy000arguetnmqqj4h","_id":"cjof51pld001lrguemtlxi6qs"},{"post_id":"cjof51pjr0006rguerpqip4yn","tag_id":"cjof51pk6000erguef56xjnrl","_id":"cjof51ple001orguejio208pv"},{"post_id":"cjof51pjr0006rguerpqip4yn","tag_id":"cjof51pki000irguem6q95wvg","_id":"cjof51ple001rrguemasks96b"},{"post_id":"cjof51pju0007rgue4mz3f04j","tag_id":"cjof51pjq0005rgue0lyz34qz","_id":"cjof51plf001urgue8idlyfz7"},{"post_id":"cjof51pju0007rgue4mz3f04j","tag_id":"cjof51pjy000arguetnmqqj4h","_id":"cjof51plg001xrguehwdzk43w"},{"post_id":"cjof51pjx0008rgueyozx92q4","tag_id":"cjof51pld001mrgueqvosptf6","_id":"cjof51plm0028rguee4eoxvu0"},{"post_id":"cjof51pjx0008rgueyozx92q4","tag_id":"cjof51plf001srgueq5vn1mzf","_id":"cjof51pln002brguecc7lnd60"},{"post_id":"cjof51pjx0008rgueyozx92q4","tag_id":"cjof51plh001zrgue6nv483n7","_id":"cjof51plo002ergueeo6xscqw"},{"post_id":"cjof51pjx0008rgueyozx92q4","tag_id":"cjof51pli0023rguef66cwf78","_id":"cjof51plo002grgue5a44gmbf"},{"post_id":"cjof51pk3000crgueiz9o2yem","tag_id":"cjof51pjq0005rgue0lyz34qz","_id":"cjof51plr002qrgue3bjy1065"},{"post_id":"cjof51pk3000crgueiz9o2yem","tag_id":"cjof51pjy000arguetnmqqj4h","_id":"cjof51pls002srguesz9r9zae"},{"post_id":"cjof51pk3000crgueiz9o2yem","tag_id":"cjof51pll0026rgue0iz7njyo","_id":"cjof51pls002urgue36rd4u52"},{"post_id":"cjof51pk3000crgueiz9o2yem","tag_id":"cjof51pln002crgueara6tagt","_id":"cjof51plt002vrgue1xaqzzmt"},{"post_id":"cjof51pk3000crgueiz9o2yem","tag_id":"cjof51plp002hrgueq0dpm2bf","_id":"cjof51plt002xrgue48yl9rwc"},{"post_id":"cjof51pk3000crgueiz9o2yem","tag_id":"cjof51plq002lrgue6go2nkg5","_id":"cjof51plu002yrguenxm9gl0j"},{"post_id":"cjof51pk6000frgueaf6t66l5","tag_id":"cjof51pld001mrgueqvosptf6","_id":"cjof51plu0030rgueken4c83h"},{"post_id":"cjof51pk6000frgueaf6t66l5","tag_id":"cjof51pls002trgue3f51iuq8","_id":"cjof51plu0031rguefbriu4c1"},{"post_id":"cjof51pke000grgue45hf4ov1","tag_id":"cjof51pjq0005rgue0lyz34qz","_id":"cjof51pm1003ergue2vpglko5"},{"post_id":"cjof51pke000grgue45hf4ov1","tag_id":"cjof51pjy000arguetnmqqj4h","_id":"cjof51pm1003frguea6iusuzx"},{"post_id":"cjof51pke000grgue45hf4ov1","tag_id":"cjof51pll0026rgue0iz7njyo","_id":"cjof51pm2003hrgue8uh0hzjo"},{"post_id":"cjof51pke000grgue45hf4ov1","tag_id":"cjof51plu002zrguegg6garse","_id":"cjof51pm2003irgue1fvs724g"},{"post_id":"cjof51pke000grgue45hf4ov1","tag_id":"cjof51plv0032rguekdkcidio","_id":"cjof51pm3003krgue5bz2bj1f"},{"post_id":"cjof51pke000grgue45hf4ov1","tag_id":"cjof51plv0033rguer9n5mfix","_id":"cjof51pm3003lrgue8m5f8miy"},{"post_id":"cjof51pke000grgue45hf4ov1","tag_id":"cjof51plw0034rgueyj9vb0p7","_id":"cjof51pm4003nrguea08xp45b"},{"post_id":"cjof51pke000grgue45hf4ov1","tag_id":"cjof51plw0035rgue6wfyhh12","_id":"cjof51pm4003orguefa96mrns"},{"post_id":"cjof51pke000grgue45hf4ov1","tag_id":"cjof51plx0036rguehs1kuosq","_id":"cjof51pm4003qrgue75miwomf"},{"post_id":"cjof51pke000grgue45hf4ov1","tag_id":"cjof51plx0037rgue1t8py009","_id":"cjof51pm5003rrguetygpu46t"},{"post_id":"cjof51pke000grgue45hf4ov1","tag_id":"cjof51ply0038rgueaxpasd2o","_id":"cjof51pm5003srgueaszvpzux"},{"post_id":"cjof51pke000grgue45hf4ov1","tag_id":"cjof51ply0039rguer66rzbye","_id":"cjof51pm5003urgueocvue328"},{"post_id":"cjof51pke000grgue45hf4ov1","tag_id":"cjof51ply003arguegzvi6edc","_id":"cjof51pm5003vrgueiw6gm90e"},{"post_id":"cjof51pke000grgue45hf4ov1","tag_id":"cjof51ply003brgue6lf1a5he","_id":"cjof51pm6003xrguepmdzp5jg"},{"post_id":"cjof51pke000grgue45hf4ov1","tag_id":"cjof51plz003crguepy00jtj0","_id":"cjof51pm6003yrguea45zyck2"},{"post_id":"cjof51pki000jrguexvpf29ye","tag_id":"cjof51pjq0005rgue0lyz34qz","_id":"cjof51pm80043rgueuagwheet"},{"post_id":"cjof51pki000jrguexvpf29ye","tag_id":"cjof51pjy000arguetnmqqj4h","_id":"cjof51pm80044rguer88b34vi"},{"post_id":"cjof51pki000jrguexvpf29ye","tag_id":"cjof51pll0026rgue0iz7njyo","_id":"cjof51pm80046rgueym4fl2hf"},{"post_id":"cjof51pki000jrguexvpf29ye","tag_id":"cjof51pm1003grgue9ud84ate","_id":"cjof51pm80047rguezdov5f5m"},{"post_id":"cjof51pki000jrguexvpf29ye","tag_id":"cjof51pm2003jrguetj3sm3jq","_id":"cjof51pm90049rgueh4bvg36a"},{"post_id":"cjof51pki000jrguexvpf29ye","tag_id":"cjof51pm3003mrgue9b21ec4a","_id":"cjof51pm9004arguel8kezrpz"},{"post_id":"cjof51pki000jrguexvpf29ye","tag_id":"cjof51pm4003prguev9qmuq7t","_id":"cjof51pma004crguewbm12ruy"},{"post_id":"cjof51pki000jrguexvpf29ye","tag_id":"cjof51pm5003trgueqpqks3ly","_id":"cjof51pma004drguepvfiriru"},{"post_id":"cjof51pki000jrguexvpf29ye","tag_id":"cjof51pm5003wrguempt4tldk","_id":"cjof51pmb004frguepld6640m"},{"post_id":"cjof51pki000jrguexvpf29ye","tag_id":"cjof51pm6003zrgueoasjp6jx","_id":"cjof51pmb004grguetse445oq"},{"post_id":"cjof51pki000jrguexvpf29ye","tag_id":"cjof51pm60040rgue8kjqz8dj","_id":"cjof51pmb004irgue0ncepsmg"},{"post_id":"cjof51pki000jrguexvpf29ye","tag_id":"cjof51pm60041rgueozb02iw0","_id":"cjof51pmc004jrguep8osf55k"},{"post_id":"cjof51pkr000krguedgqkh3gs","tag_id":"cjof51pjq0005rgue0lyz34qz","_id":"cjof51pmc004krguefusf8r7i"},{"post_id":"cjof51pkr000krguedgqkh3gs","tag_id":"cjof51pjy000arguetnmqqj4h","_id":"cjof51pmc004lrgue04ymojyj"},{"post_id":"cjof51pkr000krguedgqkh3gs","tag_id":"cjof51pll0026rgue0iz7njyo","_id":"cjof51pmc004mrgue2yhl3blp"},{"post_id":"cjof51pkr000krguedgqkh3gs","tag_id":"cjof51pm80045rgue80hbz8uf","_id":"cjof51pmc004nrgueq8hvlui1"},{"post_id":"cjof51pkt000orgueyliu9m0j","tag_id":"cjof51pjq0005rgue0lyz34qz","_id":"cjof51pmc004orguez76p94lq"},{"post_id":"cjof51pkt000orgueyliu9m0j","tag_id":"cjof51pjy000arguetnmqqj4h","_id":"cjof51pmd004prgueoril57ov"},{"post_id":"cjof51pkt000orgueyliu9m0j","tag_id":"cjof51pll0026rgue0iz7njyo","_id":"cjof51pmd004qrguekfs8pcuu"},{"post_id":"cjof51pkt000orgueyliu9m0j","tag_id":"cjof51pm9004brgue8zv6drut","_id":"cjof51pmd004rrguebidbytgy"},{"post_id":"cjof51pkt000orgueyliu9m0j","tag_id":"cjof51pma004ergue6tmyoinf","_id":"cjof51pmd004srguexgpxwrxp"},{"post_id":"cjof51pkw000rrgueqcszgmir","tag_id":"cjof51pmb004hrgueqjxpat79","_id":"cjof51pmd004trgueezswl4j2"}],"Tag":[{"name":"编程","_id":"cjof51pjq0005rgue0lyz34qz"},{"name":"Python","_id":"cjof51pjy000arguetnmqqj4h"},{"name":"金融","_id":"cjof51pk6000erguef56xjnrl"},{"name":"股票","_id":"cjof51pki000irguem6q95wvg"},{"name":"读书","_id":"cjof51pkt000nrgueb5zc9am1"},{"name":"开发","_id":"cjof51pkz000urgueo5hwsuxa"},{"name":"原则","_id":"cjof51pl1000zrgueb2w26gd6"},{"name":"阅读","_id":"cjof51pld001mrgueqvosptf6"},{"name":"人文","_id":"cjof51plf001srgueq5vn1mzf"},{"name":"历史","_id":"cjof51plh001zrgue6nv483n7"},{"name":"社会科学","_id":"cjof51pli0023rguef66cwf78"},{"name":"机器学习","_id":"cjof51pll0026rgue0iz7njyo"},{"name":"决策树","_id":"cjof51pln002crgueara6tagt"},{"name":"K近邻","_id":"cjof51plp002hrgueq0dpm2bf"},{"name":"熵","_id":"cjof51plq002lrgue6go2nkg5"},{"name":"心理学","_id":"cjof51pls002trgue3f51iuq8"},{"name":"随机森林","_id":"cjof51plu002zrguegg6garse"},{"name":"scipy.special.comb","_id":"cjof51plv0032rguekdkcidio"},{"name":"评审团定理","_id":"cjof51plv0033rguer9n5mfix"},{"name":"Bootstraping（自助抽样法）","_id":"cjof51plw0034rgueyj9vb0p7"},{"name":"Bagging（装袋算法）","_id":"cjof51plw0035rgue6wfyhh12"},{"name":"袋外误差","_id":"cjof51plx0036rguehs1kuosq"},{"name":".632自助法","_id":"cjof51plx0037rgue1t8py009"},{"name":"分类","_id":"cjof51ply0038rgueaxpasd2o"},{"name":"sklearn.model_selection.cross_val_score","_id":"cjof51ply0039rguer66rzbye"},{"name":"sklearn.ensemble.RandomForestClassifier","_id":"cjof51ply003arguegzvi6edc"},{"name":"sklearn.ensemble.BaggingClassifier","_id":"cjof51ply003brgue6lf1a5he"},{"name":"sklearn.tree.DecisionTreeClassifier","_id":"cjof51plz003crguepy00jtj0"},{"name":"sklearn.feature_extraction.text.CountVectorizer","_id":"cjof51pm1003grgue9ud84ate"},{"name":"pytesseract","_id":"cjof51pm2003jrguetj3sm3jq"},{"name":"OCR tool for python","_id":"cjof51pm3003mrgue9b21ec4a"},{"name":"geopy","_id":"cjof51pm4003prguev9qmuq7t"},{"name":"tsfresh","_id":"cjof51pm5003trgueqpqks3ly"},{"name":"scipy.stats.shapiro","_id":"cjof51pm5003wrguempt4tldk"},{"name":"零假设","_id":"cjof51pm6003zrgueoasjp6jx"},{"name":"p值","_id":"cjof51pm60040rgue8kjqz8dj"},{"name":"alpha级别","_id":"cjof51pm60041rgueozb02iw0"},{"name":"稀疏矩阵","_id":"cjof51pm80045rgue80hbz8uf"},{"name":"sklearn.preprocessing.MinMaxScaler","_id":"cjof51pm9004brgue8zv6drut"},{"name":"sklearn.preprocessing.StandardScaler","_id":"cjof51pma004ergue6tmyoinf"},{"name":"数学","_id":"cjof51pmb004hrgueqjxpat79"}]}}